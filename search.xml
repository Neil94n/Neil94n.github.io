<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML基础面试题（附答案）]]></title>
    <url>%2F2018%2F12%2F05%2FHTML%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E9%99%84%E7%AD%94%E6%A1%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.DOCTYPE有什么作用？标准模式与混杂模式如何区分？它们有何意义?（1）&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 标签之前。告诉浏览器的解析器，用什么文档类型规范来解析这个文档。 （2）严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。（3）在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 （4）DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 （5）加入XMl声明可触发，解析方式更改为IE5.5 拥有IE5.5的bug 2.HTML5为什么只需要写 &lt;!DOCTYPE HTML&gt;？HTML5不基于SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；HTML4.01基于SGML，所以需要对DTD进行引用，才能让浏览器知道该文档所使用的文档类型。 3.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？CSS的盒模型?声明：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。 1234（1）行内元素有：a b span img input select strong（强调的语气）（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p（3）常见的空元素：&lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; &lt;br&gt; 鲜为人知的空元素： &lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt; 4.CSS引入的方式有哪些? 页面导入样式时，使用link和@import有什么区别？内联, 内嵌 ,外链, 导入。 link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; 5.无样式内容闪烁（FOUC）Flash of Unstyle Content@import导入CSS文件会等到文档加载完后再加载CSS样式表。因此，在页面DOM加载完成到CSS导入完成之间会有一段时间页面上的内容是没有样式的。 解决方法：使用link标签加载CSS样式文件。因为link是顺序加载的，这样页面会等到CSS下载完之后再下载HTML文件，这样先布局好，就不会出现FOUC问题。 6.介绍一下你对浏览器内核的理解？主要分成两部分：渲染引擎(Layout Engine或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。JS引擎：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 7.常见的浏览器内核有哪些？Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等。 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）] EdgeHTML内核：Microsoft Edge。 [此内核其实是从MSHTML fork而来，删掉了几乎所有的IE私有特性] 8.HTML5有哪些新特性,移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分HTML和HTML5？新增加了图像、位置、存储、多任务等功能。新增元素： canvas 用于媒介回放的video和audio元素 本地离线存储。localStorage长期存储数据，浏览器关闭后数据不丢失;sessionStorage的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article footer header nav section 位置API：Geolocation 表单控件，calendar date time email url search 新的技术：web worker(web worker是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行) web socket 拖放API：drag、drop 移除的元素： 纯表现的元素：basefont big center font s strike tt u 性能较差元素：frame frameset noframes 区分： DOCTYPE声明的方式是区分重要因素 根据新增加的结构、功能来区分 9.什么是语义化的HTML，语义化的作用是什么？语义化的HTML就是写出的HTML代码，符合内容的结构化（内容语义化），选择合适的标签（代码语义化），能够便于开发者阅读和写出更规范性代码的同时让浏览器的爬虫和机器很好地解析。 作用： a.有利于SEO，有利于搜索引擎爬虫更好的理解我们的网页，从而获取更多的有效信息，提升网页的权重。 b.在没有CSS的时候能够清晰的看出网页的结构，增强可读性。 c.便于团队开发和维护，语义化的HTML可以让开发者更容易的看明白，从而提高团队的效率和协调能力。 d.支持多终端设备的浏览器渲染。 10.HTML5的文件离线储存怎么使用，工作原理是什么？浏览器是怎么对HTML5的离线存储资源进行管理和加载的？在线情况下，浏览器发现HTML头部有manifest属性，它会请求manifest文件，如果是第一次访问，那么浏览器就会根据manifest文件的内容下载相应的资源，并进行离线存储。如果已经访问过并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面。然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不会做任何操作，如果文件改变了，那么就会重新下载文件中的资源，并且进行离线存储。例如， 在页面头部加入manifest属性 1&lt;html manifest=&apos;cache.manifest&apos;&gt; 在cache.manifest文件中编写离线存储的资源 123456789CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:Resourse/logo.pngFALLBACK: //offline.html 在离线状态时，操作 window.applicationCache 进行需求实现。在线情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 11.cookies，sessionStorage和localStorage的区别？共同点：都是保存在浏览器端，且是同源的。 区别： cookies是为了标识用户身份而存储在用户本地终端上的数据，始终在同源http请求中携带，即cookies在浏览器和服务器间来回传递，而sessionstorage和localstorage不会自动把数据发给服务器，仅在本地保存。 存储大小的限制不同。cookie保存的数据很小，不能超过4k，而sessionstorage和localstorage保存的数据大，可达到5M。 数据的有效期不同。cookie在设置的cookie过期时间之前一直有效，即使窗口或者浏览器关闭。sessionstorage仅在浏览器窗口关闭之前有效。localstorage始终有效，窗口和浏览器关闭也一直保存，用作长久数据保存。 作用域不同。cookie在所有的同源窗口都是共享；sessionstorage不在不同的浏览器共享，即使同一页面；localstorage在所有同源窗口都是共享 12.iframe框架有那些优缺点？优点： iframe能够原封不动的把嵌入的网页展现出来。 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 缺点： iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO； iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好通过JavaScript动态给iframe添加src属性值，这样可以绕开以上两个问题。 13.label的作用是什么? 是怎么用的?label标签用来定义表单控件间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。label 中有两个属性是非常有用的, FOR和ACCESSKEY。FOR属性功能：表示label标签要绑定的HTML元素，你点击这个标签的时候，所绑定的元素将获取焦点。例如， 1&lt;Label FOR=&quot;InputBox&quot;&gt;姓名&lt;/Label&gt;&lt;input ID=&quot;InputBox&quot; type=&quot;text&quot;&gt; ACCESSKEY属性功能：表示访问label标签所绑定的元素的热键，当您按下热键，所绑定的元素将获取焦点。例如， 1&lt;Label FOR=&quot;InputBox&quot; ACCESSKEY＝&quot;N&quot;&gt;姓名&lt;/Label&gt;&lt;input ID=&quot;InputBox&quot; type=&quot;text&quot;&gt; 14.HTML5的form如何关闭自动完成功能？HTML的输入框可以拥有自动完成的功能，当你往输入框输入内容的时候，浏览器会从你以前的同名输入框的历史记录中查找出类似的内容并列在输入框下面，这样就不用全部输入进去了，直接选择列表中的项目就可以了。但有时候我们希望关闭输入框的自动完成功能，例如当用户输入内容的时候，我们希望使用AJAX技术从数据库搜索并列举而不是在用户的历史记录中搜索。 方法： 在IE的internet选项菜单中里的自动完成里面设置 设置form输入框的autocomplete为on或者off来来开启输入框的自动完成功能 15.如何实现浏览器内多个标签页之间的通信? WebSocket SharedWorker 也可以调用 localstorge、cookies 等本地存储方式。 localstorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。 ​ 注意：Safari 在无痕模式下设置 localstorge 值时会抛出QuotaExceededError 的异常 16.webSocket如何兼容低浏览器？ Adobe Flash Socket ActiveX HTMLFile (IE) 基于 multipart 编码发送 XHR 基于长轮询的 XHR 引用WebSocket.js这个文件来兼容低版本浏览器。 17.页面可见性（Page Visibility）API 可以有哪些用途？ 通过visibility state的值得检测页面当前是否可见，以及打开网页的时间。 在页面被切换到其他后台进程时，自动暂停音乐或视频的播放。 18.如何在页面上实现一个圆形的可点击区域？ map+area或者svg border-radius 纯js实现，一个点不在圆上的算法 19.实现不使用 border 画出1px高的线，在不同浏览器的Quirks mode和CSS Compat模式下都能保持同一效果1&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt; 20.网页验证码是干嘛的，是为了解决什么安全问题？ 区分用户是计算机还是人的程序; 可以防止恶意破解密码、刷票、论坛灌水； 21.title与h1的区别、b与strong的区别、i与em的区别？title属性没有明确意义，只表示标题；h1表示层次明确的标题，对页面信息的抓取也有很大的影响strong标明重点内容，语气加强含义；b是无意义的视觉表示em表示强调文本；i是斜体，是无意义的视觉表示视觉样式标签：b i u s语义样式标签：strong em ins del code 22.元素的alt和title有什么异同？在alt和title同时设置的时候，alt作为图片的替代文字出现，title是图片的解释文字。23.xhtml和html有什么区别? 区别是： XHTML 元素必须被正确地嵌套。 XHTML 元素必须被关闭。 标签名必须用小写字母。 XHTML 文档必须拥有根元素。 23.对WEB标准以及W3C的理解与认识？标签闭合、标签小写、不乱嵌套、提高搜索引擎、使用外链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性. 24.前端页面有哪三层构成，分别是什么?作用是什么?Hnml结构层，css表示层，js行为层 作用是：实现分离。使用html去创建文档的结构，使用css去设置文档的呈现效果，使用js脚本去实现文档的行为。 25.CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?标签选择符 类选择符 id选择符 继承不如指定 Id&gt;class&gt;标签选择 后者优先级高 26.css的基本语句构成是?选择器{属性1:值1;属性2:值2;……} 27.写出几种IE6 BUG的解决方法a.双边距BUG float引起的 使用display b.像素问题 使用float引起的 使用dislpay:inline -3px c.超链接hover 点击后失效 使用正确的书写顺序 link visited hover active d.Ie z-index问题 给父级添加position:relative e.Png 透明 使用js代码 改 f.Min-height 最小高度 ！Important 解决’ g.select 在ie6下遮盖 使用iframe嵌套 h.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px） 28.浏览器标准模式和怪异模式之间的区别是什么?盒子模型 渲染模式的不同 使用 window.top.document.compatMode 可显示为什么模式 29.你如何对网站的文件和资源进行优化?期待的解决方案包括：文件合并 文件最小化/文件压缩 使用CDN托管 缓存的使用 30.描述css reset的作用和用途。Reset重置浏览器的css默认属性 浏览器的品种不同，样式不同，然后重置，让他们统一. 31.解释css sprites，如何使用。Css 精灵 把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量. 32.清除浮动的几种方式，各自的优缺点?a使用空标签清除浮动 clear:both（理论上能清除任何标签，增加无意义的标签） b.使用overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE） c.是用afert伪元素清除浮动(用于非IE浏览器 33.浏览器标准模式和怪异模式之间的区别是什么?盒子模型 渲染模式的不同 使用 window.top.document.compatMode 可显示为什么模式 34.如何优化代码？​ a.代码重用 ​ b.避免全局变量（命名空间，封闭空间，模块化mvc..） ​ c.拆分函数避免函数过于臃肿 ​ d.注释 ​ e.代码压缩 ​ f.减少http请求 ​ g.图片css sprite 35.什么是媒体查询，如何使用？媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成。媒体查询中可用于检测的媒体特性有 width 、 height 和 color （等）。使用媒体查询，可以在不改变页面内容的情况下，为特定的一些输出设备定制显示效果。 一，首先需要在html文档中添加以下代码，用来兼容移动设备的显示效果 123456789&lt;meta name=&quot;viewport content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot;/&gt;注意：width=device-width:宽度等于当前设备的宽度initial-scale=1：初始的缩放比例（默认为1）maximum-scale=1：允许用户缩放到得最大比例（默认为1）user-scalable=no：用户不能手动缩放 二，在CSS文件中写CSS响应式媒体查询 例: 123456789@media screen and (max-width:720px) and (min-width:320px)&#123; body&#123;​ background-color:red;​ &#125;@media screen and (max-width:320px)&#123; body&#123;​ background-color:blue; &#125;&#125; 该段媒体查询的意思是：当设备屏幕宽度在320px——720px之间时，媒体查询中body的背景色（background-color:red;）会重叠之前的body背景色，当设备屏幕宽度在320px以下时，媒体查询中body的body背景色（background-color:blue;）会重叠之前的body背景色 怎么样才能做到屏幕适配？ 需要用的是： meta viewport 中有6个通用属性： 1）width 设置layout viewport的宽度 正整数或字符串 ‘width-device’ 2）initial-scale 设置页面的初始缩放值，数字或小数 3）minimum-scale 允许用户的最小缩放值 数字或小数 4）maximum-scale 允许用户的最大缩放值 数字或小数 5）height 设置layout viewport 的高度，这个属性很少用到 6）user-scaleabel 是否允许用户进行缩放 ‘no’或‘yes’ 还有2个需要特别注意的两个属性 7）target-densitydpi 在andriod 4.0一下的设备中，不支持设置viewport的width，android 自带浏览器支持设置 target-densitydpi来达到目的； 36.请说出三种减低页面加载时间的方法a、压缩css、js文件 b、合并js、css文件，减少http请求 c、外部js、css文件放在最底下 d、减少dom操作，尽可能用变量替代不必要的dom操作 37.http和https有什么区别?​ 在URL前加https://前缀表明是用SSL加密的。 你的电脑与服务器之间收发的信息传输将更加安全。 Web服务器启用SSL需要获得一个服务器证书并将该证书与要使用SSL的服务器绑定。​ http和https使用的是完全不同的连接方式,用的端口也不一样,前者是80,后者是443。​ http的连接很简单,是无状态的,…​ HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全 38.浏览器缓存有几种，有什么区别？ 网站后台缓存 是网站程序产生的一些临时文件，如PHP程序最喜欢。这个文件一般是在网站程序目录。​ 服务器缓存是服务器为了提升速度而产生的一些临时文件，如gzip的文件，一般是防在特定的目录。​ 浏览器缓存是用户本地浏览器缓存的网页文件，比如我们第一次打开一个网站速度会慢一些，第二次打开就很快，就是缓存在了本地。 39.有做过页面性能优化么？如何做的？​ 把样式表置于顶部​ 把脚本置于页面底部​ 避免使用 CSS 表达式（Expression）​ 使用外部 JavaScript 和 CSS​ 削减 JavaScript 和 CSS​ 用 代替 @import​ 避免使用滤镜​ 剔除重复脚本​ 减少DOM访问​ 开发智能事件处理程序​ Coockie:​ 减小Cookie体积​ 对于页面内容使用无coockie域名​ 图片：​ 优化图像​ 优化CSS Spirite​ 不要在HTML中缩放图像​ favicon.ico要小而且可缓存 40.XML和JSON的区别？(1).数据体积方面。 JSON相对于XML来讲，数据的体积小，传递的速度更快些。 (2).数据交互方面。 JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。 (3).数据描述方面。 JSON对数据的描述性比XML较差。 (4).传输速度方面。 JSON的速度要远远快于XML。 41.CSS3有哪些新特性？CSS3实现圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform），transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜，增加了更多的CSS选择器 多背景 rgba，在CSS3中唯一引入的伪元素是::selection.，媒体查询，多栏布局，border-image 未完待续，不定期更新…]]></content>
      <categories>
        <category>面试题</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对JavaScript吧!:03流程控制判断]]></title>
    <url>%2F2018%2F12%2F03%2F%E9%9D%A2%E5%AF%B9JavaScript%E5%90%A7%EF%BC%81%EF%BC%9A03%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[一、if语句if语句是编程语言最常用的语句， 1、语法：12345if(condition)&#123; //true statement &#125;else &#123; //false statement &#125; 其中condition可以是任意表达式，结果不一定是布尔值，JavaScript解释器会自动调用Boolean()将表达式结果转为布尔值，如果表达式为真，执行第一个代码块内语句；如果为假，执行第二个代码块内语句 if语句可以单独使用，也可以和多个else连续使用 123456789101112/* 满足这些条件做对应的事情*/ if(a &gt; 2)&#123; // statement &#125; if( a == 1)&#123; &#125;else if(a == 2)&#123; &#125;else if(a == 3 )&#123; &#125;else&#123; &#125; 2、例子:1234567var a = 1 if(a === 1)&#123; console.log(&apos;ok&apos;) &#125;else&#123; console.log(&apos;not ok&apos;) &#125; ---&gt;&quot;ok&quot; 二、switch语句注： JavaScript switch语句虽然参考的C语言的写法，但是有特殊性 switch和case可以使用任意表达式，不一定是常量 switch语句进行比较的时候是全等于（===）操作，不会发生类型转换 1、语法：12345678910switch(expresstion)&#123; case value1: //该条件：（满足）这个值 statement; //则执行该语句 break; //强制输出 case value2: statement; break; default: statement; &#125; 2、例子： 123456789var score =prompt(&apos;请输入分数&apos;) switch (score)&#123; case 100: console.log(&apos;100分&apos;) break; case 99: consolelog(&apos;99分&apos;) break; default: console.log(&apos;其他分数&apos;) &#125; --&gt;可弹出一个表单输入框输入分数 题外话：break，如果表达式等于case的值，对应的语句就会执行，break关键字会使程序跳出switch语句，很多编程规范强调必须添加break，不添加不会有语法错误，程序会多次判断case，进入相应流程。 当没有一个值符合case或者没有break，流程则进入default子句，很多规范也强调必须添加default部分 break VS continuebreak关键字在switch语句中已经见过，这两个关键字多用在循环语句中 break 用于强制退出循环体，执行循环后面的语句 continue 用于退出本次循环，执行下次循环 例子： break 12345for(var i = 1; i&lt; 10; //第一步 i++ //第三步（2）（如果不符合函数：i % 4 === 0，继续循环）)&#123; if(i % 4 === 0)&#123; break; &#125;//第二步 console.log(i); //第三步（1）（如果符合函数：i % 4 === 0，输出相应值，；如果不符合， 输出当值，继续执行第三步（2）） &#125; continue 12345for(var i = 1; i&lt; 10; i++)&#123; if(i % 4 === 0)&#123; continue; //如果符合函数条件：i % 4 === 0，那么则直接退出本循环，不输出（跳过） 此次结果，继续执行i&lt; 10这个条件的循环 &#125; console.log(i); &#125; 三、循环语句：while和do-while1、while循环 先条件判断，后执行 while 语句，属于前测试循环语句，也就是在循环体内的代码被执行之前，就会对条件求值，不符合的话就不会执行（1）语法： 123while(expression)&#123; statement; &#125; （2）例子： 1234var i = 10; while(i &gt; 0)&#123; console.log(i); i--; &#125; 2、do-while循环 先执行，后条件判断 do-while是后测试循环语句，在出口条件判断之前就会执行一次代码语法： 123 do&#123; statement;&#125;while(expression); 例子： 12345var i = 4; do&#123; console.log(i); i--; &#125;while(i &gt; 5); --&gt;4 3、for循环（1）for语句，前测试循环语句。具备在执行循环代码以前初始化变量和定义循环后要执行代码的能力，改造一下while语句A、语法： 123for(var i = 10; i &gt; 0;//第一步 i-- //第三步)&#123; console.log(i);//第二步 &#125; （2）for-in语句for-in是一种迭代语句，用于枚举对象的属性A、语法： 123 for(property in object)&#123; statement &#125; B、例子： 123for(var prop in window)&#123; console.log(prop); &#125; 因为ECMAScript规定对象中的属性没有顺序，所以for-in遍历出来的属性的顺序也不是固定的（虽然大部分浏览器是按属性名称排序，我们不能依赖这个） 四、label语句label语句是很多熟练的jser都会忽略的知识，我们可以为代码添加标签，方便后续使用。label语句单独使用的时候没有什么作用几乎，经常和其它语句结合使用。 1、语法：1labelname: statement; 2、例子：1234567var a = 1, b = 2, c = 3, d = 4, e = 5, f = 6; a:b:c:d:e:f:7;]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对JavaScript吧!:02数据类型、运算符、运算符优先级]]></title>
    <url>%2F2018%2F12%2F02%2F%E9%9D%A2%E5%AF%B9JavaScript%E5%90%A7%EF%BC%81%EF%BC%9A02%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[前言：最近在学习javascript中数据类型、运算符，以及运算符优先级等相关基础知识，相对简单、基础但也很重要。加上老师的推荐看了阮一峰老师所写的《javascript教程》。从中刷新了过往认知的概念和固有的规则，明白了javascript的出现会打破以往的惯性思维。 在这里1+1不再一定等于2，你常见的算数符号也不是你通常认为的那种作用，一个数字可以是表达式，同时一个表达式也是一个值。。。所以学习这样一种新知识，你要学会先接受，然后敢于去打破自身的思维惯性，之后才能勇于迎接更多挑战。 一、基本语法1、调试打开chrome开发工具：右键——检查——console（esc键调取另一个console） Win F12 Mac Command + Option + I Windows / Linux Ctrl + Shift + I 2、语句（1）语句 VS 表达式A、区别： 语句，主要为了进行某种任务而进行的操作，一般情况下不需要返回值； 表达式，为了得到返回值的计算式，一定会返回一个值。凡是JavaScript语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式 B、例子： 赋值语句：var a = 1 + 3; //先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a 表达式：1 + 3 （2）分号分号前面可以没有任何内容，JavaScript引擎将其视为空语句。;;;A、语句，以分号结尾。一个分号就表示一个语句结束。多个语句可以写在一行内。不需要加分号，换行默认上一行为语句。 123456var a = 1 + 3 ; var b = &apos;abc&apos;; /*或*/var a = 3 var b = 4 var c = a+b B、表达式不需要分号结尾。一旦在表达式后面添加分号，则JavaScript引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。下面两行语句有返回值，但是没有任何意义，因为只是返回一个单纯的值，没有任何其他操作。 121 + 3; //语句，但无任何意义 &apos;abc&apos;; 如图： 3、变量（1）定义最前面的var是变量声明命令。它表示通知解释引擎，要创建一个变量a（相当于申请了1个内存放在变量a这里）。变量是对“值”的引用，使用变量等同于引用一个值。每一个变量都有一个变量名。如：var a = 1; （2）变量提升A、定义：变量提升（hoisting），即JavaScript引擎的工作方式是：先解析代码获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有变量的声明语句，都会被提升到代码的头部，如： 1234567891011//假设 var a = 1/*这里会产生一个变量提升*/var a ;a =1;/* 或*/a = 3var a/* 控制台显示并不会报错，只要有var变量命令的声明，默认情况下就会自动提升到最前面，之后再作赋值*/ 总结： 变量提升只对var命令声明的变量有效，如果一个变量不是用var命令声明的，就不会发生变量提升。 B、说说变量提升的几种场景第1种场景： 1console.log(a); var a = 1; 代码首先使用console.log方法，在控制台显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为有var存在，即也存在变量提升，引擎中真正运行的是下面这段代码： 1var a; console.log(a); a = 1; 最后的结果是显示undefined，表示变量a已声明，且位于最前面，但还未赋值。注： 这种变量提升的技巧很重要，与之后函数作用，复杂函数执行时所出现的一些情况都可解释 第2种场景：console.log(b); b = 1;语句将会报错，提示“ReferenceError:b is not defined”，即变量b未声明，这是因为b不是用var命令声明的，JavaScript引擎不会将其提升，而只是视为对顶层对象的b属性的赋值。 4、标识符（1）定义：标识符（identifier），用来识别具体对象的一个名称。最常见标识符：变量名、函数名。注： JavaScript语言的标识符对大小写敏感，所以a和A是两个不同的标识符。 （2）标识符命名规则A、第一个字符，可以是任意Unicode字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。B、第二个字符及后面的字符，除了Unicode字母、美元符号和下划线，还可以用数字0-9。C、一些命名实例： 下面这些都是合法的标识符。 1234arg0_tmp$elemπ 下面这些则是不合法的标识符。 123451a // 第一个字符不能是数字23 // 同上*** // 标识符不能包含星号a+b // 标识符不能包含加号-d // 标识符不能包含减号或连词线 中文是合法的标识符，可以用作变量名。 1var 临时变量 = 1; JavaScript有一些保留字，不能用作标识符： arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield 三个词具有特别含义，也不应该用作标识符： 123InfinityNaNundefined 5、注释：123456789// 这是单行注释/* 这是 多行 注释*///历史上JavaScript兼容HTML代码的注释，所以&lt;!--和--&gt;也被视为单行注释。x = 1; &lt;!-- x = 2;--&gt; x = 3; 6、区块（1）定义 JavaScript使用大括号，将多个相关的语句组合在一起，称为区块（block）。（2）与大多数编程语言不一样，JavaScript的区块不构成单独的作用域（scope）。即区块中的变量与区块外的变量，属于同一个作用域。如： 1234&#123; var a = 1;&#125;a // 1 二、数据类型1、定义JS语言的每一个值，都属于某一种数据类型。 2、值所属的数据类型分类JavaScript 的数据类型，共有6种： 注： ES6 又新增了第七种 Symbol 类型的值（1）数值（number）：值为整数和小数（比如1和3.14）（2）字符串（string）：值为字符组成的文本（比如&quot;Hello World&quot;）（3）布尔值（boolean）：值判定为true（真）和false（假）两个特定值 注： 用于询问的便可用boolean进行变量命名,如：var isBoy = true （4）undefined：值判定为未处理，未定义或不存在。目前未定义所以此处暂时没有任何值，但之后可以去放东西。注： 一个变量没有赋值，只能是undefined，不会是null （5）null：值为表示经过处理之后的无值，即此处的值就是“无”的状态。 （6）对象（object）：或称“引用类型”，各种值组成的集合。对象=属性+值对象又可以分成三个子类型： 狭义的对象（object） 数组（array） 函数（function） 3、typeof 运算符（用来确定值所属的数据类型）（1）三种运算符用来确定数据类型运算符，用于连接简单表达式，组成一个复杂的表达式（即通过一个关键字，后面加一个变量或值，得出一个结果） JavaScript有三种方法，可以确定一个值到底属于什么类型。 typeof运算符 instanceof运算符 Object.prototype.toString方法 （2）作用用typeof可以判断一个变量或可以返回一个值为哪种数据类型，如：※数值、字符串、布尔值分别返回number、string、boolean。 1234//数值、字符串、布尔值分别返回number、string、boolean。typeof 123// &quot;number&quot;typeof &apos;123&apos;// &quot;string&quot;typeof false// &quot;boolean&quot; ※函数返回function。 12345function f()&#123;&#125;typeof f// &quot;function&quot; ※ undefined返回 undefined 12typeof undefined// &quot;undefined&quot; ※ 利用这一点，typeof用来检查一个没有声明的变量，而不报错。如代码中变量v没有用var命令声明，直接使用就会报错；但放在typeof后面就不报错了，而是返回undefined。 12345v// ReferenceError: v is not defined typeof v// &quot;undefined&quot; ※实际编程中，变量v要用var命令声明，这个特点通常用在判断语句。 12345678910// 错误的写法if (v) &#123; // ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === &quot;undefined&quot;) &#123; // ...&#125; ※除此以外，其他情况都返回object。 12345//除此以外，其他情况都返回objecttypeof window // &quot;object&quot;typeof &#123;&#125; // &quot;object&quot;typeof [] // &quot;object&quot;typeof null // &quot;object&quot; 实际操作中： 如何判断一个变量是否为函数？ 4、布尔值（1）作用布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。（2）下列运算符会返回布尔值A、两元逻辑运算符：&amp;&amp;(And)，||(Or)B、前置逻辑运算符：!(Not)C、相等运算符：===，!==，==，!=D、比较运算符：&gt;，&gt;=，&lt;，&lt;=如：4&gt;3--&gt;true （3）如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六种值被转为false，其他值都视为true。 undefined –&gt;false null –&gt;false false –&gt;false +0，-0，NaN –&gt; false【其他number（数字）为true】 &quot;&quot;或&#39;&#39;（空字符串）–&gt;false【其他string（字符串,包含&quot; &quot;空白字符串）为true】 A、关于&quot;&quot;或&#39;&#39;（空字符串）布尔值往往用于程序流程的控制，如： 12345if (&apos;&apos;) &#123; console.log(true);&#125;/* 没有任何输出*//*上面代码的if命令后面的判断条件，预期应该是一个布尔值，所以JavaScript自动将空字符串，转为布尔值false，导致程序不会进入代码块，所以没有任何输出*/ B、空数组（[]）和空对象（{}）对应的布尔值，都是true。如： 123456789if ([]) &#123; console.log(true);&#125;// trueif (&#123;&#125;) &#123; console.log(true);&#125;// true 三、数据类型转换解密 总结：js的数据类型如何判断，即任何表达式先转字符串再转数字 1、if判断（1）js如何转换判断从面试题说说if的数据类型： 1234567891011121314151617181920212223242526272829303132// 题目1：如下代码输出什么?if (&quot;hello&quot;) &#123; console.log(&quot;hello&quot;)&#125; //true// 题目2：如下代码输出什么?if (&quot;&quot;) &#123; console.log(&apos;empty&apos;)&#125;//空字符串，代表里面什么都没有 //false// 题目3：如下代码输出什么?if (&quot; &quot;) &#123; console.log(&apos;blank&apos;)&#125;//空白字符串，仍然代表一个值，只不过是空值 //true// 题目4：如下代码输出什么?if ([0]) &#123; console.log(&apos;array&apos;)//对象 true&#125;if（[]）&#123; console.log(&apos;hahah&apos;)&#125; //特殊对象 true// 题目5：如下代码输出什么?if(&apos;0.00&apos;)&#123; console.log(&apos;0.00&apos;)&#125; //字符串（除空字符串外）trueif（+0.00）&#123; console.log(&apos;hahah&apos;)&#125; //false （2）判断原理：对于if（）里括号的表达式（如以下），会被强制转换为布尔类型 undefined –&gt; false null –&gt;false false` –&gt;false +0，-0 ，NaN –&gt;false 【其他number（数字）为true】 &quot;&quot;或&#39;&#39;（空字符串）–&gt;false【其他string（字符串,包含” “空白字符串）为true】 2、==判断（1）js处理 ==的表达式 判断 1234567891011121314151617181920212223242526&quot;&quot; == 0 //题目1 &quot;&quot;空字符串===false===0 0==0 //true&quot; &quot; == 0 //题目2 Number(&apos; &apos;)--&gt;0===false 0==0 //true&quot;&quot; == true //题目3 0===1 //false&quot;&quot; == false //题目4 0===0 //true&quot; &quot; == true //题目5 false===0 0==1 //false!&quot; &quot; == true //题目6 &quot; &quot;空白字符串===true !0===false===0 0不等于true //false!&quot; &quot; == false //题目7 false==false //true*&quot;hello&quot; == true //题目8 字母字符串===Nan Nan不等于1 //fasle*&quot;hello&quot; == false //题目9 字母字符串===Nan Nan不等于0 //fasle&quot;0&quot; == true //题目10 &quot;0&quot;（数字字符串）===0不等于1 //false&quot;0&quot; == false //题目11 &quot;0&quot;（数字字符串）===0===0 //true&quot;00&quot; == false //题目12 &quot;00&quot;（数字字符串）===00===0 //true&quot;0.00&quot; == false //题目13 &quot;0.00&quot;（数字字符串）===0===0 //trueundefined == null //题目14 undefined===Nan===null //true&#123;&#125; == true //题目15 &#123;&#125;===object（没有字符串）不等于true //fasle[] == true //题目16 []（空数组）===object（没有字符串）不等于true //faslevar obj = &#123; a: 0, valueOf: function()&#123;return 1&#125; &#125; obj == &quot;[object Object]&quot; //题目17 //falseobj == 1 //题目18 //trueobj == true //题目19 //true （2）判断原理两图对照，就能判断表达式的数据类型： 四、运算符1、作用：运算符，主要用于连接简单表达式，组成一个复杂的表达式如typeof，为运算符。即typeof 100 === &#39;numeber&#39; 是一个值为字符串&#39;numeber&#39;的表达式再如： 3 ： 表达式 3+4：表达式+ :为运算符 （1+2）*5：表达式。+和* : 均为运算符 2、判断参考标准：（1）有些操作符对不同的数据类型有不同的含义，比如+,在两个操作数都是数字的时候，会做加法运算 （2）两个参数都是字符串或在有一个参数是字符串的情况下会把另外一个参数转换为字符串,做字符串拼接 （3）在参数有对象的情况下会调用其valueOf或toString的函数（两者同时使用，注意优先级） （4）在只有一个字符串参数的时候会尝试将其转换为数字 注： 如果字符串无法转换成数字，那么则转换失败，通常结果为：Nan （5）在只有一个数字参数的时候返回其正数值 12345678console.log(2+4); //6 加法运算console.log(&quot;2&quot;+&quot;4&quot;); //&quot;24&quot;为字符串 字符串的拼接console.log(2+&quot;4&quot;); //&quot;24&quot; 一个数字+字符串，会把数字转化成字符串，然后再进行拼接，不是一个连读的数字24，而是2和4的分开读console.log(2+new Date());//&quot;2Mon Jan 20 2014 17:15:01 GMT+0800 (China Standard Time)&quot;/* 一个数字+一个对象，会调用这个对象的valueOf或toString这个方法*/console.log(+&quot;4&quot;);//4 3、常见类型： 算数表达式 比较表达式 逻辑表达式 赋值表达式 单目运算符 关键字作为运算符，如typeof、delete、instanceof等 （1）算数表达式A、加法运算符（Addition）：x + yB、减法运算符（Subtraction）：x - yC、乘法运算符（Multiplication）：x * yD、除法运算符（Division）：x / y加减乘除的运算，这里会尽可能将字符串转化成数字，如果转换不了数字，则会得出Nan这个结果 E、余数运算符（Remainder）：x % y 用于循环语句 F、自增运算符（Increment）：x ++或者++x x++,由简单表达式（x）和运算符（++）组成一个复杂的表达式，一个表达式本身整体，就是一个值，那么x++的值就是x的原始值; x++，作为表达式的结果是是它自己本身，同一作用域中的下一个变量，则是x++内部又自增了1，即x=x+1 注： x++：是自增前x的原始值 ++x：是自增后下一个x变量的值如： 而++ e则是自增后的那个值，图1所示，自增+1的e ===10，那么++e === 11 自减运算符（Decrement）：--x或者 x--同上可得 求负运算符（Negate）：-x 数值运算符（Convert to number）：+x （2）赋值运算符 1234567891011x += y // 等同于 x = x + yx -= y // 等同于 x = x - yx *= y // 等同于 x = x * yx /= y // 等同于 x = x / yx %= y // 等同于 x = x % yx &gt;&gt;= y // 等同于 x = x &gt;&gt; yx &lt;&lt;= y // 等同于 x = x &lt;&lt; yx &gt;&gt;&gt;= y // 等同于 x = x &gt;&gt;&gt; yx &amp;= y // 等同于 x = x &amp; yx |= y // 等同于 x = x | yx ^= y // 等同于 x = x ^ y （3）比较运算符比较运算符比较两个值，然后返回一个布尔值（实际上是ture或false），表示是否满足比较条件。JavaScript提供了8个比较运算符。A、= 赋值= 为赋值运算符，连接两个简单的表达式构成复杂的表达式，如x=y即为表达式，若将其看成一个整体，即会输出一个值，这个值则为最终赋的值，如： B、== 相等这里的相等是，近似相等，后台得到的值则是ture或者false如数字和字符串的比较，后台会将字符串做一个类型转换： C、===严格相等这里的相等则更严格，值和类型的严格相等 题外话： === VS == ===叫做严格运算符 == 叫做相等运算符 关于这两者的区别我在知乎上看到一篇文章：Javascript 中 == 和 === 区别是什么？ a、严格运算符的运算规则如下：(1)不同类型值如果两个值的类型不同，直接返回false。(2)同一类的原始类型值同一类型的原始类型的值(数值、字符串、布尔值)比较时，值相同就返回true，值不同就返回false。(3)同一类的复合类型值两个复合类型(对象、数组、函数)的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。(4)undefined和nullundefined 和 null与自身严格相等。 12null === null //trueundefined === undefined // true b、相等运算符在比较相同类型的数据时，与严格相等运算符完全一样。在比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。类型转换规则如~下:(1)原始类型的值原始类型的数据会转换成数值类型再进行比较。字符串和布尔值都会转换成数值，所以题主的问题中会有第二个string输出。(2)对象与原始类型值比较对象(这里指广义的对象，包括数值和函数)与原始类型的值比较时，对象转化成原始类型的值，再进行比较。(3)undefined和 nullundefined和null与其他类型的值比较时，结果都为false, 它们互相比较时结果为true。(4)相等运算符的缺点相等运算符隐藏的类型转换，会带来- -些违反直觉的结果。 123456789== &apos;0&apos; // false0 == // true0 == // truefalse == &apos;false&apos; // falsefalse == &apos;0&apos; //truefalse == undefined // falsefalse == null // falsenull == undefined // true&apos; \t\r\n &apos; == 0 // true 这就是为什么建议尽量不要使用相等运算符。至于使用相等运算符会不会对后续代码造成意外影响，答案是有可能会。 1234567891011121314151617 var a = undefined;if(!a)&#123; console.log(&quot;1&quot;); &#125;//1 var a = undefined;if(a == null)&#123; console.log(&quot;1&quot;); &#125; //1 var a = undefined;if(a === null)&#123; console.log(&quot;1&quot;); &#125; // 无输出 也就是说当a为undefined时，输出的值会有变化，而在编程中对象变成undefined实在是太常见了。D、 != 不相等E 、!== 严格不相等F、 &lt; 小于G、 &lt;= 小于或等于H、 &gt; 大于I 、 &gt;= 大于或等于 （5）布尔运算符A、! 取反运算符B、&amp;&amp; 且运算符表达式&amp;&amp;表达式 会自动地转化成ture或者false 进行比较。或判断一个东西是否存在，是否满足条件C、|| 或运算符初始化赋值的时候可用 题外话：&amp;&amp; 且 运算符 VS ||或 运算符a、且——&amp;&amp; ：用于判断一个东西是否存在，或是否满足条件（有false就判断）如果第一个为true，第二个也为true，最终值就是第二个值；如：var a = “hello”，那么a&amp;&amp;console.log（a）就能进行判断，第二个值的最终结果为true 如果第一个为true，再看第二个是否为false，那最终的值就是为第一个值； 如果第一个为false，那就不用再判断第二个，就是第一个值总结： 如果是false就不用再看了；如果有true，再看第二个 b、或——||: 用于初始化值如果第一个为true，后面就不用再管；如果第一个为false，再看第二个总结： 如果是true，就不会再管了；如果有false，再看第二个。只要一项为真，那就不用管,如：第二个cc为undefined，转化为Boolean类型为false，||中还会看第二个，0为true，那么结果就为0。将0赋值给第一个cc，那么cc则有了初始值。假如cc=100，再执行cc=cc||0，那么cc仍然等于100，转换为boolean类型为true，那么则不需要在看第二个数如果cc之前没有声明的话，得到的是一个默认值；如果cc之前声明过，值还保持不变。 D、condition? true case : false case三元条件运算符题外话： 三目运算符 Condition？true case：false case这里有一个条件判断，如果条件判断为真的话，那么整个表达式的结果就是true case执行的结果；如果条件判断为假的话，那么整个表达式的结果就是false case执行的结果，当然，false case还是会再做一些执行，如： 123456if (a &gt; 10) &#123; b = a&#125; else &#123; b = a - 2&#125; 答：b = a&gt;10? a : a-2 （5）位运算符必要时看看二进制转换对照表也行：二进制转换对照表 A、或运算（or）：符号为|，表示两个二进制位中有一个为1，则结果为1，否则为0。B、与运算（and）：符号为&amp;，表示两个二进制位都为1，则结果为1，否则为0。C、否运算（not）：符号为～，表示将一个二进制位变成相反值。D、异或运算（xor）：符号为ˆ，表示两个二进制位中有且仅有一个为1时，结果为1，否则为0。E、左移运算（left shift）：符号为&lt;&lt;F、右移运算（right shift）：符号为&gt;&gt;J、带符号位的右移运算（zero filled right shift）：符号为&gt;&gt;&gt; （6）其它运算符（考虑优先级）A、小括号在JavaScript中，圆括号是一种运算符，它有两种用法：如果把表达式放在圆括号之中，作用是求值；如果跟在函数的后面，作用是调用函数。B、voidvoid运算符的作用是执行一个表达式，然后返回undefined。C、逗号运算符逗号运算符用于对两个表达式求值，并返回后一个表达式的值。如： 五、运算符优先级和结合性1、定义结合性是指多个具有同样优先级的运算符表达式中的运算顺序 2、实践——理论：（1）有的运算符是左结合的，即运算从左到右执行，下面两个运算是一样的 12w = x + y + z;w = (x + y) + z; （2）有的运算符是右结合的 1234w = x = y = z;w = (x = (y = z));w = a: b: c ? d : e? f : g;w = a? b : (c? d: (e? f : g)); 如： 最高：typeof 最低：， 3、理论——实践 几个优先级从高到低： typrof （） ++ -- ！ +-*% &amp;&amp; || = （1）typeof的优先级相当的高，比加减乘除都优先，所以虽然是操作符，但在复杂表达式的时候我们还是习惯加括号，如： 123typeof 2*3;//NaNtypeof (2*3);//&quot;number&quot;typeof 2+3;// &quot;number3&quot; 题外话： NanN（即not and number）定义：是一个数字类型，不过它不是一个有效的数，表示为错误数字。通过number函数可以把一个数字的字符创转化成数字，不过无法将一个字母的字符串转化成数字，得出结果为NaN。当NaN===NaN—&gt;false，一个数字与自己不相等，作为一个数字，二者对等与否对方均无从得知，没有突出一个数字的识别性。如： （2）++、--是右结合的操作符（优先级最高的几个都是右结合），而且比加减乘除优先级高。同时自增、自减运算符的运算数得是左值（可以放在赋值符号左边的值），而不能是常数 123454++; //ReferenceError: Invalid left-hand side expression in postfix operationvar a=0,b=0;//, 忽略第一个操作数，返回第二个操作数 L(往左运算）a+++b;//0a;//1，++优先级比+高，所以相当于(a++)+bb;//0 （3）赋值运算符的优先级相当的低a = b == c; //等同于a = (b==c) （4）逻辑非!也在优先级队列的前端，比加减乘除高，但逻辑与、逻辑或优先级很低，不如加减乘除!2*0; //0, 等价于(!2)*0 （5）一个关于逻辑运算符的有意思地方是其“短路”功能，会结合表达式计算值来判断 1231 &amp;&amp; 3;1 &amp;&amp; &quot;foo&quot; || 0;1 || &quot;foo&quot; &amp;&amp; 0 如：]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对JavaScript吧!:01了解JS（包括白屏和fouc）]]></title>
    <url>%2F2018%2F12%2F01%2F%E9%9D%A2%E5%AF%B9JavaScript%E5%90%A7%EF%BC%81%EF%BC%9A01%E4%BA%86%E8%A7%A3JS%EF%BC%88%E5%8C%85%E6%8B%AC%E7%99%BD%E5%B1%8F%E5%92%8Cfouc%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言：面对疾风吧！咳咳…不对是面对JavaScript吧！开始学javascript了，HTML和CSS学完但是感觉自己并没有记住啥，还需要系统的梳理大量的练习！！！学习JavaScript，大家都安利阮一峰的教程，好吧我就从阮一峰老师的新手教程开始学习好了，冲鸭！面对JavaScript吧！ 一、网页的构成 网页 = Html+CSS+JavaScript Html: 网页元素内容 CSS: 控制网页样式 JavaScript：操作网页内容，实现功能或者效果 浏览器端（web应用）、服务端（nodejs）。。。 二、JavaScirpt 发展历史 参考：阮一峰js标准教程 1995年5月，Brendan Eich只用了10天，就设计完成了这种语言的第一版。 1996年8月，微软模仿JavaScript开发了一种相近的语言，取名为JScript（JavaScript是Netscape网景公司的注册商标，微软不能用），首先内置于IE 3.0。 1996年11月，Netscape公司决定将JavaScript提交给国际标准化组织ECMA（European Computer Manufacturers Association），希望JavaScript能够成为国际标准，以此抵抗微软。 1997年7月，ECMA组织发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript。这个版本就是ECMAScript 1.0版。基本上，JavaScript这个名字的原意是“很像Java的脚本语言”。在JavaScript语言中，函数是一种独立的数据类型，以及采用基于原型对象（prototype）的继承链。这是它与Java语法最大的两点区别。JavaScript语法要比Java自由得多。 1999年12月，ECMAScript 3.0版发布，成为JavaScript的通行标准，得到了广泛支持。 2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA开会决定，中止ECMAScript 4.0的开发（即废除了这个版本），将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，会后不久，ECMAScript 3.1就改名为ECMAScript 5。 2009年12月，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6； 2006年，jQuery函数库诞生，作者为John Resig。jQuery为操作网页DOM结构提供了非常强大易用的接口，成为了使用最广泛的函数库，并且让JavaScript语言的应用难度大大降低，推动了这种语言的流行。 2009年，Node.js项目诞生，创始人为Ryan Dahl，它标志着JavaScript可以用于服务器端编程，从此网站的前端和后端可以使用同一种语言开发。并且，Node.js可以承受很大的并发流量，使得开发某些互联网大规模的实时应用变得容易。 2012年，微软发布TypeScript语言。该语言被设计成JavaScript的超集，这意味着所有JavaScipt程序，都可以不经修改地在TypeScript中运行。同时，TypeScript添加了很多新的语法特性，主要目的是为了开发大型程序，然后还可以被编译成JavaScript运行。 2013年5月，Facebook发布UI框架库React，引入了新的JSX语法，使得UI层可以用组件开发。 2015年4月，Angular框架宣布，2.0版将基于微软公司的TypeScript语言开发，这等于为JavaScript语言引入了强类型。 三、JS引入使用12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;标题&lt;/title&gt; /*这里引入css代码*/ &lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;style&gt; body&#123; background: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;/p&gt; /*一般来说，这里引入js代码*/ &lt;script src=&quot;index.js&quot;&gt;/*空*/&lt;/script&gt; 或 &lt;script&gt; alert(1); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 四、浏览器渲染机制你所看到的浏览器网页，浏览器是经历了什么你才能看到？ 解析 HTML 标签, 构建 DOM 树⏬ 解析 CSS 标签, 构建 CSSOM 树⏬ 把 DOM 和 CSSOM 组合成 渲染树 (render tree)⏬ 在渲染树的基础上进行布局, 计算每个节点的几何结构 ⏬ 把每个节点绘制到屏幕上 (painting) 当发一个请求到服务器之后，服务器会把页面上的html发给浏览器，浏览器收到之后则会解析该html标签，解析的过程中遇到了类似需要加载的样式，如link，则会再次发送请求到服务器。这样一来，如此循环，标签属性的请求不断被发出到服务器，资源不断被获取资源获取之后，如何被用户看见？ 首先，先对html标签进行解析。解析成一个dom树（即类似于树状结构，dom，即文档、模型）同时，也对css样式进行解析，同时也解析成cssom树，将css样式（默认+添加）汇聚一起形成css树——dom树元素和css树元素结合起来获得一个对象，该对象所拥有的元素和具体位置都有其相互关系，对应节点和对应数据形成一个渲染树——执行layout（布局）计算它的位置和样式——绘制——排列形成页面 五、浏览器引起的Repaint 和 Reflow问题1、Repaint问题：重新绘制。将css样式改变的话，其他元素并未改变，只需要重新绘制某一处就行。 2、Reflow问题：重新回流，重新计算。即自身位置发生变化，给其他元素带来了影响，要重新进行计算。 从一个外网中截取出来的关于Repaint 和 Reflow分辨片段： Anything that changes input information used to construct the rendering tree can cause a repaint or a reflow, for example:Adding, removing, updating DOM nodesHiding a DOM node with display: none (reflow and repaint) or visibility: hidden(repaint only, because no geometry changes)Moving, animating a DOM node on the pageAdding a stylesheet, tweaking style propertiesUser action such as resizing the window, changing the font size, or (oh, OMG, no!) scrollin Let’s see a few examples: 1234567891011121314var bstyle = document.body.style; // cachebstyle.padding = &quot;20px&quot;; // reflow, repaintbstyle.border = &quot;10px solid red&quot;; // another reflow and a repaintbstyle.color = &quot;blue&quot;; // repaint only, no dimensions changedbstyle.backgroundColor = &quot;#fad&quot;; // repaintbstyle.fontSize = &quot;2em&quot;; // reflow, repaint/* new DOM element - reflow, repaint */document.body.appendChild(document.createTextNode(&apos;dude!&apos;)); 六、白屏和FOUC1、即指影响浏览器页面加载顺序的两种场景 白屏：特指一种场景，打开页面是一片白色，突然页面出现，样式正确。那么一片白色的时间，则称之为白屏。 FOUC (Flash of UnstyledContent)：无样式内容闪烁，网速情况差，打开页面时仍有样式，之后样式时有时无，甚至一开始并无出现样式，突然样式恢复。（常出现在firefox浏览器）此类现象，在不同浏览器进行的资源加载和页面渲染时，所采用的不同的处理方式，并不是bug。 2、写一个server，验证白屏和fouc效果在index.html中 12345678910111213141516171819202122232425262728//index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;fouc &amp; 白屏&lt;/title&gt; &lt;!--在下面模拟一个延时装置--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;b.css?t=10&quot;&gt; //设置这个工具，当请求该文件时，服务器会延迟请求10s再去加载这个资源，以此可以模拟一个网速特别慢的情况 &lt;link rel=&quot;stylesheet&quot; href=&quot;a.css?t=3&quot;&gt; &lt;/head&gt;&lt;body&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;饥人谷&lt;/p&gt;&lt;!-- &lt;script src=&quot;A.js?t=5&quot;&gt;&lt;/script&gt; --&gt; &lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/15/1653c442f35af77c?w=211&amp;h=200&amp;f=png&amp;s=8004&quot; alt=&quot;&quot;&gt;&lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;c.css?t=6&quot;&gt; --&gt; &lt;!-- &lt;script src=&quot;http://a.jrg.com:8080/B.js?t=4&quot; &gt;&lt;/script&gt; &lt;script src=&quot;http://b.jrg.com:8080/A.js?t=8&quot; &gt;&lt;/script&gt; --&gt; &lt;/body&gt;&lt;/html&gt; （1）关于白屏，需要注意的是，浏览器对于样式和js的处理，即CSS和JS放置顺序。推荐：将样式放在 head里面,将JS放在body内部下方。如上面代码所示，html页面里引入了两个css：a.css和b.css。b.css引用了c.ss（@import&quot;./c.css?t=5&quot;;）b.css中加入了一个10s的延时文件（&lt;link rel=&quot;stylesheet&quot; href=&quot;b.css?t=10&quot;&gt;），加载这个10s的css样式文件，浏览器是如何完成加载工作，有两种方式：第1种： html解析完成，此时10s延时的css文件先不管，先展示body里所展示的内容，等css文件全加载后再去计算样式，再去重新渲染一次；第2种： 即使html的dom树已经解析、渲染都完成，对未加载完成的样式都必须等待，即css样式要全部加载、获取，img资源加载完成，此时底部JS立刻执行，才一次性展示出页面。例子中展示这种方法，即为白屏很久的原因。 （2）不同浏览器的不同处理机制所出现的场景不同A、白屏场景（常出现在chrome）：打开一个国外网站，使用国外服务器，嵌在css的字体使用的是谷歌字体，运行特别慢，等了好久突然出现页面样式效果。这是因为页面需要等待css样式加载所有完成，甚至出现404加载失败，最后才展示出页面。那么那段加载时间，等待了几秒左右的白色一片的页面，就是白屏B、Fouc场景（常出现在Firefox）：一开始的时候，先让你看见样式，如字的小号样式，样式加载完后看到所规定字号的大字。对用户来说，同样的样式，突然从小变大，则这个场景就是Fouc（无样式内容闪烁）。总结： 不管是css样式，还是js文件，只要加长延时，都会造成白屏 （3）CSS 和 JS 最佳放置顺序 使用 link 标签将样式表放在顶部 将JS放在底部（3.1）场景：假设JS文件页面顶部： JS脚本会阻塞后面内容的呈现 JS脚本会阻塞其后组件（如图片）的下载 JS加载时间过长，css需等待，则会出现一段时间白屏 场景说明：引入一个JS文件在顶部，设置一个延时时间。 加载顺序：css—js—img—全部获取到展现页面效果此时，img和css加载时会并发加载，即如一个域名下同时加载两个文件（并发是有限度的），加载在顶部的js时，会禁用并发img和css，并阻止其他内容下载和渲染。 js并不影响css加载，但是会影响css样式的一个计算。当js加载时，css已经获取到（不过此时页面还是一片空白），直到js获取立即执行后，图片立刻出现，页面才展示效果。所以js文件放入页面顶部head里，也会导致白屏现象出现 （3.2）JS加载特点总结A、优先加载js文件，加载后js立刻去执行，展示页面（CSS样式则是全部加载完，然后一次性展示出页面）注： css放前面，优先加载； 若放后面，其他资源则会阻碍css加载，那么时机就太晚。 B、由于渲染线程和js脚本线程是互斥的，白屏是渲染进程被阻塞的原因，当碰到script标签的时候，会先执行js脚本，然后再渲染。 （放顶部时）JS加载时机过晚导致一系列问题，脚本会阻塞后面内容的呈现、脚本会阻塞其后组件的下载（主要指img资源下载）、白屏等。 （放底部）则可以先让其他先加载完成，JS立刻执行的特点可以“扫尾”最后的页面效果 C、JS脚本操作页面上的html+css元素，（放顶部时）JS先执行，元素都未加载到（即不存在），未出现在文档流中【加载，这里指资源加载和资源是否出现在文档流中】，所以也不能操作相应JS功能，此时后台将会报错。D、（放顶部时）其他JS若作为一种框架语言，则能提前形成一个初步的框架有效构成页面结构。 七、JS脚本的异步加载1、一个问题？即一个放在head的js文件，如下：&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;原本放在顶部的这个js文件，会提前加载，如何使它在顶部仍然稍后加载呢？ 2、解决方法：async和defer（1）作用：没有 defer 或async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该script标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。也就是说，使用defer或async后能够改变这种加载、执行的时机。常应用在引用了广告和统计的页面中，不会影响、堵塞，更不会影响到到页面其他元素 （2）asyncHTML5里为script标签里新增了async属性，用于异步加载脚本：不保证顺序（独立的个体）&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;或&lt;script type=&quot;text/javascript&quot; src=&quot;alert.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;浏览器解析到HTML里的该行script标签，发现指定为async，会异步下载解析执行脚本（即加载后续文档元素的过程将和script.js的加载并行进行）。 页面的DOM结构里假设&lt;script&gt;在img之前，如果你的浏览器支持async的话，就会异步加载脚本。此时DOM里已经有img了，所以脚本里能顺利取到img的src并弹框。 （3）deferscript标签里可以设置defer，表示延迟加载脚本：脚本先不执行，延迟到文档解析和显示后执行，有顺序&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;或&lt;script type=&quot;text/javascript&quot; src=&quot;alert.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;浏览器解析到HTML里该行script标签，发现指定为defer，会暂缓下载解析执行脚本，等到页面文档解析并加载执行完毕后，才会加载该脚本（更精确地说，是在DOM树构建完成后，在DOMContentLoaded事件触发前，加载`defer`的脚本）。 页面的DOM结构里假设script在img图片之前，如果你的浏览器支持defer的话，就会延迟到页面加载完后才下载脚本。此时DOM里已经有img元素了，所以脚本里能顺利取到img的src并弹框。 总结： JS实质采用一种可以更自由地选择加载时机和任何位置，让处于顶部的js文件能够像在底部时，在页面必要元素加载完成时进行“异步”加载。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记（一）入门篇]]></title>
    <url>%2F2018%2F11%2F19%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[导论什么是 JavaScript 语言？JavaScript 是一门动态类型，面向对象的脚本语言，同时也是一种嵌入式（embedded）语言。主要依靠嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。目前，已经嵌入 JavaScript 的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。JavaScript 的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（就是一系列具有各种功能的对象比如Array、Date、Math等）。除此之外，各种宿主环境提供额外的 API（即只能在该环境使用的接口），以便 JavaScript 调用。以浏览器为例，它提供的额外 API 可以分成三大类。 浏览器控制类：操作浏览器 DOM 类：操作网页的各种元素 Web 类：实现互联网的各种功能 如果宿主环境是服务器，则会提供各种操作系统的 API，比如文件操作 API、网络通信 API等等。这些你都可以在 Node 环境中找到。 为什么学习 JavaScript？ 操控浏览器的能力 广泛的使用领域 易学性 强大的性能 开放性 社区支持和就业机会 JavaScript 与 Java 的关系?它们是两种不一样的语言，但是彼此存在联系。JavaScript 语法要比 Java 自由得多。另外，Java 语言需要编译，而 JavaScript 语言则是运行时由解释器直接执行。 JavaScript 与 ECMAScript 的关系?1996年11月，Netscape 公司决定将 JavaScript 提交给国际标准化组织 ECMA（European Computer Manufacturers Association），希望 JavaScript 能够成为国际标准，以此抵抗微软。 1997年7月，ECMA 组织发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript。 ECMAScript 只用来标准化 JavaScript 这种语言的基本语法结构，与部署环境相关的标准都由其他标准规定，比如 DOM 的标准就是由 W3C组织（World Wide Web Consortium）制定的。 基本语法语句JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。 语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。 1var a = 1 + 3; 这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。 1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。 语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。 1var a = 1 + 3 ; var b = &apos;abc&apos;; 分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。 1;;; 上面的代码就表示3个空语句。 表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。 121 + 3;&apos;abc&apos;; 上面两行语句只是单纯地产生一个值，并没有任何实际的意义。 变量概念变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。 1var a = 1; 上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，称为将数值1“赋值”给变量a。以后，引用变量名a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。 注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。 变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。 12var a;a = 1; 如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个特殊的值，表示“无定义”。 12var a;a // undefined 如果变量赋值的时候，忘了写var命令，这条语句也是有效的。 123var a = 1;// 基本等同a = 1; 但是，不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用var命令声明变量。 如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。 12x// ReferenceError: x is not defined 上面代码直接使用变量x，系统就报错，告诉你变量x没有声明。 可以在同一条var命令中声明多个变量。 1var a, b; JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。 12var a = 1;a = &apos;hello&apos;; 上面代码中，变量a起先被赋值为一个数值，后来又被重新赋值为一个字符串。第二次赋值的时候，因为变量a已经存在，所以不需要使用var命令。 如果使用var重新声明一个已经存在的变量，是无效的。 123var x = 1;var x;x // 1 上面代码中，变量x声明了两次，第二次声明是无效的。 但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。 12345678var x = 1;var x = 2;// 等同于var x = 1;var x;x = 2; 变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。 12console.log(a);var a = 1; 上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。 123var a;console.log(a);a = 1; 最后的结果是显示undefined，表示变量a已声明，但还未赋值。 标识符标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。 标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。 简单说，标识符命名规则如下。 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。 下面这些都是合法的标识符。 1234arg0_tmp$elemπ 下面这些则是不合法的标识符。 123451a // 第一个字符不能是数字23 // 同上*** // 标识符不能包含星号a+b // 标识符不能包含加号-d // 标识符不能包含减号或连词线 中文是合法的标识符，可以用作变量名。 1var 临时变量 = 1; JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 注释源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。Javascript 提供两种注释的写法：一种是单行注释，用//起头；另一种是多行注释，放在/*和*/之间。 1234567// 这是单行注释/* 这是 多行 注释*/ 此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以&lt;!--和--&gt;也被视为合法的单行注释。 12x = 1; &lt;!-- x = 2;--&gt; x = 3; 上面代码中，只有x = 1会执行，其他的部分都被注释掉了。 需要注意的是，--&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。 1234567function countdown(n) &#123; while (n --&gt; 0) console.log(n);&#125;countdown(3)// 2// 1// 0 上面代码中，n --&gt; 0实际上会当作n-- &gt; 0，因此输出2、1、0。 区块JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。 对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。 12345&#123; var a = 1;&#125;a // 1 上面代码在区块内部，使用var命令声明并赋值了变量a，然后在区块外部，变量a依然有效，区块对于var命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 JavaScript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如for、if、while、function等。 条件语句JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。 if 结构if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，true表示真，false表示伪。 12345if (布尔值) 语句;// 或者if (布尔值) 语句; 上面是if结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为true，就执行紧跟在后面的语句；如果结果为false，则跳过紧跟在后面的语句。 12if (m === 3) m = m + 1; 上面代码表示，只有在m等于3时，才会将其值加上1。 这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在if的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。 123if (m === 3) &#123; m += 1;&#125; 建议总是在if语句中使用大括号，因为这样方便插入语句。 注意，if后面的表达式之中，不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。 123456var x = 1;var y = 2;if (x = y) &#123; console.log(x);&#125;// &quot;2&quot; 上面代码的原意是，当x等于y的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将y赋值给变量x，再判断变量x的值（等于2）的布尔值（结果为true）。 这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。 12if (x = 2) &#123; // 不报错if (2 = x) &#123; // 报错 至于为什么优先采用“严格相等运算符”（===），而不是“相等运算符”（==），请参考《运算符》章节。 if…else 结构if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。 12345if (m === 3) &#123; // 满足条件时，执行的语句&#125; else &#123; // 不满足条件时，执行的语句&#125; 上面代码判断变量m是否等于3，如果等于就执行if代码块，否则执行else代码块。 对同一个变量进行多次判断时，多个if...else语句可以连写在一起。 123456789if (m === 0) &#123; // ...&#125; else if (m === 1) &#123; // ...&#125; else if (m === 2) &#123; // ...&#125; else &#123; // ...&#125; else代码块总是与离自己最近的那个if语句配对。 123456var m = 1;var n = 2;if (m !== 1)if (n === 2) console.log(&apos;hello&apos;);else console.log(&apos;world&apos;); 上面代码不会有任何输出，else代码块不会得到执行，因为它跟着的是最近的那个if语句，相当于下面这样。 1234567if (m !== 1) &#123; if (n === 2) &#123; console.log(&apos;hello&apos;); &#125; else &#123; console.log(&apos;world&apos;); &#125;&#125; 如果想让else代码块跟随最上面的那个if语句，就要改变大括号的位置。 12345678if (m !== 1) &#123; if (n === 2) &#123; console.log(&apos;hello&apos;); &#125;&#125; else &#123; console.log(&apos;world&apos;);&#125;// world switch 结构多个if...else连在一起使用的时候，可以转为使用更方便的switch结构。 12345678910switch (fruit) &#123; case &quot;banana&quot;: // ... break; case &quot;apple&quot;: // ... break; default: // ...&#125; 上面代码根据变量fruit的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。 12345678910111213var x = 1;switch (x) &#123; case 1: console.log(&apos;x 等于1&apos;); case 2: console.log(&apos;x 等于2&apos;); default: console.log(&apos;x 等于其他值&apos;);&#125;// x等于1// x等于2// x等于其他值 上面代码中，case代码块之中没有break语句，导致不会跳出switch结构，而会一直执行下去。正确的写法是像下面这样。 12345678910switch (x) &#123; case 1: console.log(&apos;x 等于1&apos;); break; case 2: console.log(&apos;x 等于2&apos;); break; default: console.log(&apos;x 等于其他值&apos;);&#125; switch语句部分和case语句部分，都可以使用表达式。 1234567switch (1 + 3) &#123; case 2 + 2: f(); break; default: neverHappens();&#125; 上面代码的default部分，是永远不会执行到的。 需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。 12345678910var x = 1;switch (x) &#123; case true: console.log(&apos;x 发生类型转换&apos;); break; default: console.log(&apos;x 没有发生类型转换&apos;);&#125;// x 没有发生类型转换 上面代码中，由于变量x没有发生类型转换，所以不会执行case true的情况。这表明，switch语句内部采用的是“严格相等运算符”，详细解释请参考《运算符》一节。 三元运算符 ?:JavaScript 还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断。 1(条件) ? 表达式1 : 表达式2 上面代码中，如果“条件”为true，则返回“表达式1”的值，否则返回“表达式2”的值。 1var even = (n % 2 === 0) ? true : false; 上面代码中，如果n可以被2整除，则even等于true，否则等于false。它等同于下面的形式。 123456var even;if (n % 2 === 0) &#123; even = true;&#125; else &#123; even = false;&#125; 这个三元运算符可以被视为if...else...的简写形式，因此可以用于多种场合。 1234567var myVar;console.log( myVar ? &apos;myVar has a value&apos; : &apos;myVar does not have a value&apos;)// myVar does not have a value 上面代码利用三元运算符，输出相应的提示。 1var msg = &apos;数字&apos; + n + &apos;是&apos; + (n % 2 === 0 ? &apos;偶数&apos; : &apos;奇数&apos;); 上面代码利用三元运算符，在字符串之中插入不同的值。 循环语句循环语句用于重复执行某个操作，它有多种形式。 while 循环While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。 12345while (条件) 语句;// 或者while (条件) 语句; while语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。 123while (条件) &#123; 语句;&#125; 下面是while语句的一个例子。 123456var i = 0;while (i &lt; 100) &#123; console.log(&apos;i 当前为：&apos; + i); i = i + 1;&#125; 上面的代码将循环100次，直到i等于100为止。 下面的例子是一个无限循环，因为循环条件总是为真。 123while (true) &#123; console.log(&apos;Hello, world&apos;);&#125; for 循环for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。 12345678for (初始化表达式; 条件; 递增表达式) 语句// 或者for (初始化表达式; 条件; 递增表达式) &#123; 语句&#125; for语句后面的括号里面，有三个表达式。 初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。 条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。 递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。 下面是一个例子。 1234567var x = 3;for (var i = 0; i &lt; x; i++) &#123; console.log(i);&#125;// 0// 1// 2 上面代码中，初始化表达式是var i = 0，即初始化一个变量i；测试表达式是i &lt; x，即只要i小于x，就会执行循环；递增表达式是i++，即每次循环结束后，i增大1。 所有for循环，都可以改写成while循环。上面的例子改为while循环，代码如下。 1234567var x = 3;var i = 0;while (i &lt; x) &#123; console.log(i); i++;&#125; for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。 123for ( ; ; )&#123; console.log(&apos;Hello World&apos;);&#125; 上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。 do…while 循环do...while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。 12345678do 语句while (条件);// 或者do &#123; 语句&#125; while (条件); 不管条件是否为真，do...while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。 下面是一个例子。 1234567var x = 3;var i = 0;do &#123; console.log(i); i++;&#125; while(i &lt; x); break 语句和 continue 语句break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。 break语句用于跳出代码块或循环。 1234567var i = 0;while(i &lt; 100) &#123; console.log(&apos;i 当前为：&apos; + i); i++; if (i === 10) break;&#125; 上面代码只会执行10次循环，一旦i等于10，就会跳出循环。 for循环也可以使用break语句跳出循环。 123456789for (var i = 0; i &lt; 5; i++) &#123; console.log(i); if (i === 3) break;&#125;// 0// 1// 2// 3 上面代码执行到i等于3，就会跳出循环。 continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 1234567var i = 0;while (i &lt; 100)&#123; i++; if (i % 2 === 0) continue; console.log(&apos;i 当前为：&apos; + i);&#125; 上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。 如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。 标签（label）JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。 12label: 语句 标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。 标签通常与break语句和continue语句配合使用，跳出特定的循环。 1234567891011top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0 上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。 标签也可以用于跳出代码块。 12345678foo: &#123; console.log(1); break foo; console.log(&apos;本行不会输出&apos;);&#125;console.log(2);// 1// 2 上面代码执行到break foo，就会跳出区块。 continue语句也可以与标签配合使用。 1234567891011121314top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) continue top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2 上面代码中，continue命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。 本文截取阮一峰老师JavaScript入门教程，原文请查看JavaScript 教程。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构入门]]></title>
    <url>%2F2018%2F11%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[本文简要介绍各种数据结构，算是入门吧： 哈希表 队列 栈 链表 树 堆排序 1.哈希表（Hash Table） 符合键值对关系都是哈希，数组，对象都是哈希 计数排序中的桶（复杂度 O(n+max)，比快排（复杂度 nlogn）还快，缺点：计数排序无法负数和小数 桶排序 与计数排序的区别， 桶排序是计数排序的改良版 一个桶放一个范围内的数字，范围自定义，第一个桶永远不会与其他的桶内数字进行比较，桶内的数字可以使用快排或者再使用桶排序。。 桶排序相对节约空间，但桶里面的数据需要二次排序，浪费时间 基数排序 与计数排序的区别 计数数组适合10以内的排序，大于10的用基数排序 十进制的基数为10，拿出十个桶，每次从个位数开始入桶，到十位，百位，千位，循环完所有数字，之后每次通过先进先出从桶里拿出来完成排序。 基数排序可以适应特别大的数字，且比桶排序节约桶 排序的原则 要么浪费空间，要么浪费时间，只能选一个进行优化 2.队列（Queue） 先进先出 可以用数组实现， push与shift 举例：排队 3.栈（Stack） 先进后出 可以用数组实现，push与pop 举例：盗梦空间 4.链表（Linked List） 数组无法直接删除中间的一项，链表（多个哈希连起来的）可以改变指向，进行数据的删除 用哈希（JS里面用对象表示哈希）实现链表 链表头称为head、链节称为node 5.树（tree） 由链表构成的树，层级结构、DOM 层数、深度、节点数 二叉树（每次最多分两个叉）第i层有2^i个节点，总共有2^(i+1)-1个节点 满二叉树（每次都是两个分支） 完全二叉树（右边连续的没有长叶子） 数组可以表示完全二叉树和满二叉树，不能表示三叉树，四叉树，。。。其他树可以用哈希（对象）实现 操作：增删改查 堆排序用到了 tree 其他：B树、红黑树、AVL树 6.堆排序：头狼之争（复杂度 nlogn） 堆是一种特殊的树，父节点永远大于子节点 最大堆：最大元素在根节点 最大堆调整：图下的 4 不符合最大堆概念，找他的子节点中最大的替换，再去检查替换后位置的子节点，发现8&gt;4,将4 与 8 替换，由于替换后的4没有子节点，此时这个堆是最大堆 堆排序：将数组表示成完全二叉树，从他的叶子开始最大堆调整，使所有的树苗都是最大堆，只要整个二叉树是一个绝对最大堆，拿到当前堆里面的最大数（顶端head），把这个数放在数组最右边隐藏掉，然后把树最右下方的叶子放在最顶端位置，然后进行调整得到第二个最大堆，拿到最大值放在数组右边隐藏掉，然后把树最右下方的叶子放在最顶端位置，。。。。。直到只剩一个数为止。 堆排序查看 ：排序算法入门（二）堆排序 计数排序，桶排序查看：排序算法入门(三) 计数排序，桶排序]]></content>
      <categories>
        <category>基础知识</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法入门(三) 计数排序，桶排序]]></title>
    <url>%2F2018%2F11%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%A1%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[计数排序：原理：与比较排序注重于元素之间的比较不同，计数排序专注于找准自己的位置，而不关心自己比谁小，比谁大。其核心在于，对于任意一个属于数组array的元素number，统计其在array内出现的次数，将其以键值对的形式保存在hash，如果hash没有number，使hash[nmber] = 1,并且与max做对比是否需要重置max（max是hash的最大键，也可以理解为共有多少的桶。。），否则hash[number]++,形成hash后，将其按顺序push到新数组newArr。 计数排序可视化：https://visualgo.net/zh/sorting 点击COU 流程图：计数排序伪代码：12345678910111213141516171819202122232425262728293031323334353637a &lt;- &#123;&apos;0&apos;:0,&apos;1&apos;:2,&apos;2&apos;:1,&apos;3&apos;:56,&apos;4&apos;:4,&apos;5&apos;:67,&apos;6&apos;:3,&apos;length:7&apos;&#125; //构建数组ahash &lt;- &#123;&#125; //构建哈希index &lt;- 0 //初始值底标while index &lt; a[&apos;length&apos;] //遍历数组anumber &lt;- a[index] //将数组a的每个值记下来if hash[number] == undefined //该值在 hash[number] 中还不存在hash[number] = 1 //将该值记入hash中，并标记出现了1次elsehash[number] &lt;- hash[number] + 1 //每多出现一次加次1endindex &lt;- index + 1 //遍历所有底标endindex2 &lt;- 0 //定义一个新的底标max &lt;- findMax(a) //最大值67newArr &lt;- &#123;&#125; //定义一个新数组while index2 &lt;= max //遍历原数组的所有值 count &lt;- hash[index2] //将hash的每个底标所对应的数提取出来if count != undefined //如果该数（count） 存在countIndex &lt;- 0 //给该值初始一个新底标值0while countIndex &lt; count //遍历该值所对应的个数newArr.push(index2) //将所有该值输入到新数组中countIndex &lt;- countIndex + 1 endendindex2 &lt;- index2 + 1 //对应 while index2 &lt;= max，遍历数组所有底标endprint newArr 1、先将数组a，用”值：值出现的次数“的形式，写入hash表； 遍历数组a，提取键名， 提取键名出现的次数， 2、再将hash表中的值展开放到一个新数组中； 找出hash中的最大值，从零开始，0-max， 依次确认是否出现过和出现的次数，出现几次就依次加入到新数组中几次， 3、打印该数组。 javascript代码： 12345678910111213141516171819202122232425262728293031/* * @i 原数组索引 * @hashIndex hash内键值对的键 * @countIndex hash内键值对的值 */function CountingSort(array) &#123; let hash = &#123;&#125;, max = array[0], newArr = []; for (let i = 0; i &lt; array.length; i++) &#123; let number = array[i]; if (hash[number]) &#123; hash[number]++ &#125; else &#123; hash[number] = 1; if (number &gt; max) &#123; max = number &#125; &#125; &#125; for (let hashIndex = 0; hashIndex &lt; max + 1; hashIndex++) &#123; let count = hash[hashIndex]; if (count) &#123; for (let countIndex = 0; countIndex &lt; count; countIndex++) &#123; newArr.push(hashIndex); &#125; &#125; &#125; return newArr;&#125;console.log(CountingSort([3, 0,4, 1, 5, 6, 8, 1, 5, 4, 9, 5])); 桶排序：原理：将数组按照步长放在不同的桶里，桶的数量根据数组长度和步长确定，数组全部入桶之后，每个桶内进行排序，按顺序将所有桶的数据合并。 难点：桶的数量，左右边缘的计算 桶排序可视化：Bucket Sort Visualization 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * @array 原始数组 * @step 每个桶的步长：比如step = 3;表示一个桶放连续的3个数字，比如 0,1,2 | 3,4,5 |6,7,8 * @bucket 二维数组保存数组 * @bucketCount 桶的数量 * @bucketL 每个桶的长度 * @max 数组最大值 * @min 数组最小值 * @ i 原数组索引 * @ j 桶的索引 * @ z bucket的索引 * @temp 临时保存每一项 * @newArr 新数组 */function BucketSort(array, step) &#123; let temp, bucketL = 0, bucket = [], l = array.length, max = Math.max(...array), min = Math.min(...array), bucketCount = Math.ceil((max - min + 1) / step), newArr = []; // 入桶 for (let i = 0; i &lt; l; i++) &#123; temp = array[i]; for (let j = 0; j &lt; bucketCount; j++) &#123; // 初始化 if (!bucket[j]) &#123; bucket[j] = []; &#125; bucketL = bucket[j].length; if (temp &gt;= min + j * step &amp;&amp; temp &lt;= min + j * step + step - 1) &#123; bucket[j].push(temp); if (bucketL &gt; 0) &#123; // 桶内排序 插入排序 for (let k = bucketL - 1; k &gt;= 0; k--) &#123; if (temp &lt; bucket[j][k]) &#123; bucket[j].splice(k, 0, temp); bucket[j].splice(k + 2, 1) &#125; &#125; &#125; &#125; &#125; &#125; // 出桶 for(let z = 0 ; z&lt;bucket.length;z++)&#123; if(bucket[z])&#123; newArr.push(...bucket[z]) &#125; &#125; return newArr;&#125;console.log(BucketSort([ 12, 26, 20, 17, 2,0,2, 7], 4)); 参考：常见排序算法 - 桶排序 (Bucket Sort)]]></content>
      <categories>
        <category>基础知识</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法入门（二）堆排序]]></title>
    <url>%2F2018%2F11%2F16%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[原理：将数组表示成完全二叉树，从他的叶子开始最大堆调整，使所有的树苗都是最大堆，只要整个二叉树是一个绝对最大堆，拿到当前堆里面的最大数（顶端head），把这个数放在数组最右边隐藏掉，然后把树最右下方的叶子放在最顶端位置，然后进行调整得到第二个最大堆，拿到最大值放在数组右边隐藏掉，然后把树最右下方的叶子放在最顶端位置，。。。。。直到只剩一个数为止。堆排序可视化：https://www.cs.usfca.edu/~galles/visualization/HeapSort.html：务必打开。array = [804,264,825,175,282,910,914,920,928,179,339,347,161,999,993] ;将数组表示为完全二叉树： 第一轮 ：从二叉树倒数第一层和第二层构成的小堆开始进行最大堆调整，就是图中框里的堆 maxHeapify 最大堆调整函数： 将堆的末端子节点作调整，使得子节点永远小于父节点 array 为 需要排序的原始数组 index ：第一轮里面传入的index ，第一次调整时 最后一个框的 347的索引6就是传入的index， heapsize：当前数组长度，第一轮就是原始数组array的长度，之后依次减一 iMax : 保存当前堆内最大值索引，初始化为 index， 左边节点索引iLeft小于heapsize，意思就是计算出来的索引务必在数组的长度范围内，如果左节点值（993）大于当前节点值（347），说明这不是一个最大堆，将最大值索引重置为index 如果计算出来的右节点索引在长度范围内，且值（999）大于当前堆内最大值（347）就替换，框1不替换 如果计算出来的最大值索引不是index，替换iMax与index的值，重置iMax为index，向下递归 反之，退出循环，如框1中 993与347替换后index重置为13，但是13下面没有节点,iMax == index,退出。 12345678910111213141516171819202122232425262728293031323334353637/ ** * 从 index 开始检查并保持最大堆性质 * * @array * * @index 检查的起始下标 * * @heapSize 堆大小 * **/function maxHeapify(array, index, heapSize) &#123; var iMax, iLeft, iRight; while (true) &#123; iMax = index; //index下 左边节点 iLeft = 2 * index + 1; //index下 右边节点 iRight = 2 * (index + 1); //左节点存在且大于父节点 if (iLeft &lt; heapSize &amp;&amp; array[index] &lt; array[iLeft]) &#123; iMax = iLeft; &#125; //右节点存在且大于当前最大值 if (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123; iMax = iRight; &#125; if (iMax != index) &#123; //如果最大值不是自己，那么将自己与最大值替换 [array[iMax],array[index]] = [array[index],array[iMax]] //重置当前节点为最大值的索引，递归向下调整，使父节点永远大于子节点 index = iMax; &#125; else &#123; //如果最大值是自己，说明已经是最大堆或者该节点下没有子节点 break; &#125; &#125;&#125; 上面仅叙述了堆1的最大堆调整，接着还需要依次向左，再向上，如图 从堆1&gt;2&gt;3&gt;4&gt;5&gt;6&gt;7 一个一个调整 buildMaxHeap函数用来创建整个二叉树的最大堆， iParent就是需要传入maxHeapify的index，用来与两个子节点比较，依次是 6 5 4 3 2 1 0 i 从 6 递减到 0 的过程中，就是堆1 到 堆7的最大堆调整 1234567function buildMaxHeap(array) &#123; var i, iParent = Math.floor(array.length / 2) - 1; for (i = iParent; i &gt;= 0; i--) &#123; maxHeapify(array, i, array.length); &#125; &#125; 注意，堆6，堆5的二级又分别包含三级节点，这里就用到maxHeapify的递归，向下继续调整，直到子节点永远小于父节点，如下，堆6的调整过程，不仅179与347替换，替换后的179影响的堆1原来的秩序，所以还要调整第二轮到最后一轮：第一轮调整到堆7时，二叉树顶端产生最大值，需要将其与最后一个值替换，然后取出， 将剩余的堆继续调整为最大堆， 再次将堆顶的最大数替换取出，这个过程持续到剩余数只有一个时结束 sort函数 ：移除根节点的最大值，并做最大堆调整的递归运算 每次从最后一个堆开始调整，形成最大堆后，移除最大值，循环数组长度减一 12345678function sort(array) &#123; buildMaxHeap(array); for (var i = array.length - 1; i &gt; 0; i--) &#123; swap(array, 0, i); maxHeapify(array, 0, i); &#125; return array; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152完整javascript： function heapSort(array) &#123; function maxHeapify(array, index, heapSize) &#123; var iMax, iLeft, iRight; while (true) &#123; iMax = index; //index下 左边节点, 这规律真是千奇百怪！！！才疏学浅见识少啊。。 iLeft = 2 * index + 1; //index下 右边节点 iRight = 2 * (index + 1); // 左节点存在且大于父节点 if (iLeft &lt; heapSize &amp;&amp; array[index] &lt; array[iLeft]) &#123; iMax = iLeft; &#125; // 右节点存在且大于当前最大值 if (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123; iMax = iRight; &#125; if (iMax != index) &#123; // 如果最大值不是自己，那么将自己与最大值替换 [array[iMax], array[index]] = [array[index], array[iMax]] // 重置当前节点为最大值的索引，递归向下调整，使父节点永远大于子节点 index = iMax; &#125; else &#123; // 如果最大值是自己，说明已经是最大堆或者该节点下没有子节点 break; &#125; &#125; &#125; function buildMaxHeap(array) &#123; var i, iParent = Math.floor(array.length / 2) - 1; for (i = iParent; i &gt;= 0; i--) &#123; maxHeapify(array, i, array.length); &#125; &#125; function sort(array) &#123; buildMaxHeap(array); //第一轮 for (var i = array.length - 1; i &gt; 0; i--) &#123; [array[0], array[i]] = [array[i], array[0]] maxHeapify(array, 0, i); &#125; return array; &#125; return sort(array); &#125; console.log(heapSort([804,264,825,175,282,910,914,920,928,179,339,347,161,999,993] )); 难点： 查找左右节点的索引规律 函数递归思想保证每次子节点小于父节点 创建最大堆函数 buildMaxHeap函数的设计，for循环里iParent的循环递减 sort函数取出最大值，重置heapSize的思路 全是难点！。。。。。。 参考：http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort]]></content>
      <categories>
        <category>基础知识</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法入门（一） 冒泡排序，选择排序，插入排序]]></title>
    <url>%2F2018%2F11%2F15%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%8C%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[本文简要记录常用排序算法的原理及如何用javascript实现排序功能，具体排序动画效果查看Sorting (Bubble, Selection, Insertion, Merge, Quick, Counting, Radix)，看完后思路会非常清晰（请问还有什么比算法动态演变更让人理解？？）。计算机计算是非常机械的，不同于人脑快速找出最值快速排序，必须放慢思路，理清逻辑，关于实现算法的代码，建议反复分析，不同的for循环有不同的结果，每位程序员都有不同的思路，但基本原理都是一致的 冒泡排序 选择排序 插入排序 冒泡排序（Bubble sort） 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 冒泡排序流程图 伪代码12345678910111213141516171819202122232425a &lt;- &#123;&apos;0&apos;:4,&apos;1&apos;:6,&apos;2&apos;:3,&apos;3&apos;:2,&apos;4&apos;:1,&apos;length&apos;: 5&#125;轮数 = 1左手指向的下标 while(轮数 &lt; a[&apos;length&apos;]) 左标 = 0 while(左标 &lt;= a[&apos;length&apos;] - 1 - 轮数) if a[左下标] &lt; a[左下标+1] else t &lt;- a[左标] a[左标] &lt;- a[左标+1] a[左标+1] &lt;- t end 左标 &lt;- 左标+1 end 轮数 &lt;- 轮数 + 1endprint a javascript实现 1234567891011function BubbleSort(arr)&#123; for(let i = 0 ;i&lt; arr.length;i++)&#123; //轮数 for(let j = 0 ;j &lt; arr.length - i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; [arr[j],arr[j+1]] = [arr[j+1],arr[j]] //es6语法交换元素 &#125; &#125; &#125; return arr;&#125;console.log(BubbleSort([21,5,10])) 选择排序（Selection sort）工作原理: 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 选择排序流程图 伪代码1234567891011121314151617181920212223242526 a&lt;-&#123; &apos;0&apos;=4, &apos;1&apos;=6, &apos;2&apos;=3, &apos;3&apos;=2, &apos;4&apos;=1, &apos;length&apos;=5&#125;轮数=1 while(轮数&lt;a[&apos;length&apos;]) min左标&lt;-轮数-1;左标&lt;-min左标+1 while(左标&lt;a[&apos;length&apos;]) if a[左标]&lt;a[min左标] a[min左标]&lt;-a[左标] else 什么也不做 end 左标&lt;-左标+1 end t&lt;-a[轮数-1] a[轮数-1]&lt;-a[min左标] a[min左标]&lt;-t 轮数&lt;-轮数+1 end print a javascript实现12345678910111213function SelectionSort(arr) &#123; let minIndex; for (let i = 0; i &lt; arr.length; i++) &#123; //轮数 minIndex = i; for (let j = i+1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]]; &#125; return arr;&#125; 插入排序（Insection Sort）原理：将第一个元素标记为已排序，遍历每个没有排序过的元素，提出当前第一个位置的元素X，将X与排序过的元素从length-1 到 0 进行遍历，如果某个元素大于X，将排序过的元素向右移一格，否则插入这个元素后面。 选择排序流程图 javascript实现123456789101112function InsectionSort(arr) &#123; for (let i = 1; i &lt; arr.length; i++) &#123; //轮数 let num = arr[i] for (let j = i - 1; j &gt;= 0; j--) &#123; if(num &lt; arr[j])&#123; arr.splice(j,0,num); arr.splice(j+2,1) &#125; &#125; &#125; return arr;&#125;]]></content>
      <categories>
        <category>基础知识</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（九）：伪类和伪元素]]></title>
    <url>%2F2018%2F11%2F14%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[文档阅读：总结伪类与伪元素 | AlloyTeamwww.alloyteam.com! 前文回顾： 一、伪类：1、定义伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化 2、类型 3、应用场景用伪类元素进行效果展示（1）link visited hover active 顺序 123456789/* 未访问的链接 */ a:link&#123; color: blue; &#125; a:visited&#123; color: green; &#125; /* 点击后鼠标脱离，获得焦点的链接 */ a:focus&#123; color: grey; &#125; /*鼠标悬停时，内容颜色获得红色 */ a:hover&#123; color: red; &#125; /*选择活动链接*/ a:active&#123; color: pink; &#125; （2）first-child VS first-of-type h1:first-child :选择是h1并且它是长子的元素 h1:first-of-type:选择是h1并且它是它父亲里h1类型中的长子的元素 关于first-childVSfirst-of-type的使用在之前的css系列博客文章中有详细解释：#00你认真学了css？ 二、伪元素1、定义伪元素用于创建一些不在文档树中的元素，并为其添加样式 2、类型如： 3、:before 和 :after（也可以写::before和 ::after）1234567891011&lt;div class=&quot;box&quot;&gt; &lt;p&gt;这是第一段&lt;/p&gt; &lt;/div&gt; &lt;style&gt; .box:before&#123; content: &apos;start&apos; &#125; .box:after&#123; content: &apos;end&apos; &#125; &lt;/style&gt; 使用伪元素before和after的好处： 可以在后台发现，p的前后分别出现::before和::after。html的dom树中原本没有::before和::after，现通过css样式添加，使其在dom树中添加这两个元素。 用添加::before和::after的目的是为了省标签。::before生成的效果，所在的位置位于父元素（如box）的第一个子元素，::after则位于父元素（如box）的最后一个子元素，即在html的dom树上多了两个子元素，这两个子元素无需在html中体现，只需在css中表示即可。 ::before和::after所展示的效果相当于一个行内元素（注意行内元素的一些特性） 其中content是必不可少 4、伪类选择器的应用场景（1）伪类选择器应用于清除浮动 12345.clearfix:after &#123; content:&apos;&apos;; display:block; clear:both;&#125; 详细解释请回看之前我写得关于浮动的副作用和解决办法：#03你认真学了css？（基本样式3：浮动+定位） （2）伪类选择器可作为替代标签用代码替代图片，如使用css3实现一个带边框的三角符。思路：边框+三角符号的组合，先确认边框样式： 12345678910111213.bubble&#123; position: relative; padding: 10px; border-radius: 3px; /*可填可不填*/ background: #fff; border: 1px solid #000; display: inline-block; &#125;&lt;body&gt; &lt;div class=&quot;bubble&quot;&gt; hello world &lt;/div&gt;&lt;/body&gt; 再确认三角样式： 1234567891011121314151617.bubble:before&#123; content:&apos;&apos;; width: 10px; height: 10px; border-left: 1px solid #000; border-top: 1px solid #000; background: #fff; display: inline-block; position: absolute; transform: rotateZ(45deg); top: -6px; &#125;&lt;body&gt; &lt;div class=&quot;bubble&quot;&gt; hello world &lt;/div&gt;&lt;/body&gt; 这里基础的三角样式我们在之前已经有涉及过怎么使用：请戳🔽#01你认真学了css？（基本样式1） 使用伪元素怎么实现三角符号(css3)：基础代码：（关于三角形的位置参数可以使用页面后台进行调试） 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .bubble&#123; position: relative; padding: 10px; border-radius: 3px; /*可填可不填*/ background: #fff; border: 1px solid #000; display: inline-block; &#125; .bubble:before&#123; content:&apos;&apos;; width: 10px; height: 10px; border-left: 1px solid #000; border-top: 1px solid #000; background: #fff; display: inline-block; transform: rotateZ(45deg); position: absolute; top: -6px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;bubble&quot;&gt; hello world &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结果：运用以上知识举一反三，实现以下效果： 代码请戳：我的代码 （3）伪类选择器应用于element：checked;（勾选住的一个状态）即input元素的自定义重要属性checkbox或者radio，实现一个自定义的样式。如：笑脸切换 12345678910111213141516171819202122/*今天的心情:*/ &lt;input type=&quot;checkbox&quot;&gt;&lt;style&gt;input[type=checkbox]&#123; -webkit-appearance: none; /*去掉未勾选的方框默认样式*/ appearance: none; background: url(http://7xpvnv.com2.z0.glb.qiniucdn.com/b6dcd011-23cc-4d95-9e51-9f10100103bd.png) 0 0 no-repeat; display: inline-block; width: 20px; height: 20px; background-size: contain; /*背景图片的大小*/ vertical-align: middle; outline: none; &#125; /*勾选之后的状态*/ input[type=checkbox]:checked&#123; -webkit-appearance: none; appearance: none; background: url(http://7xpvnv.com2.z0.glb.qiniucdn.com/538f26f0-6f3e-48d5-91e6-5b5bb730dd19.png) 0 0 no-repeat; display: inline-block; width: 20px; height: 20px; background-size: contain; vertical-align: middle; &#125; &lt;/style&gt; 好处： 没有加js 使用该属性样式，对于input来说已经实现勾选状态，自定义加一些自己的图片，自动加载信息 （4）伪类选择器应用于字体图标A、为什么针对字体库而来的字体，我们可以调整它的字体大小和颜色？B、完整代码如下： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//at.alicdn.com/t/font_nyta5x5h650cnmi.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;span class=&quot;iconfont icon-jirengulogojichu2&quot;&gt;&lt;/span&gt; &lt;style&gt; .iconfont&#123; font-size: 100px; color: red; &#125; &lt;/style&gt;&lt;/body&gt;&lt;/html&gt; 在css中添加这个: 12/* \e605为字体库中的特有的一种编码形式：unicode码 */.icon-jirengulogojichu2：before&#123;content:&apos;\e605&apos;;&#125; 即：]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（八）：布局套路]]></title>
    <url>%2F2018%2F11%2F13%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%B8%83%E5%B1%80%E5%A5%97%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[一、两种布局使用分析 float布局（定宽布局） flex布局（弹性布局） 二、原则 不到万不得已，不要写死width 和 height 尽量用高级语法，如 calc、flex 如果是 IE，就全部写死 三、布局套路口诀（上） 👉PC端布局1、导航条布局——float布局（适用于ie5） a.儿子全加 float: left （right）;b.老子加 .clearfix 代码如下：Float布局 12345678910111213141516171819202122232425262728293031&lt;style&gt; .parent&#123; border:1px solid green;&#125; .child&#123; /* border:1px solid red; */&#125;.child:nth-child(1)&#123; width:30%; background-color:red;&#125;.child:nth-child(2)&#123; width:69%; background-color:yellow;&#125;.clearfix::after&#123; content:&apos;&apos;; display:block; clear:both; &#125;.content&#123; border:1px solid black; margin-right:10px;&#125;&lt;/style&gt;&lt;div class=&quot;parent clearfix&quot; &gt; &lt;div class=&quot;child&quot; style=&quot;float:left;&quot;&gt;儿子1&lt;/div&gt; &lt;div class=&quot;child&quot; style=&quot;float:left;&quot;&gt;儿子2&lt;/div&gt; &lt;/div&gt; 如图：该页面展示上其实是弹性布局定死宽度，水平居中则在老子这边动手，添加以下代码： 123456789101112131415 .parent&#123; border:1px solid green; width:1000px margin-left:auto margin-right:auto&#125;.child:nth-child(1)&#123; width:30%; background-color:red;&#125;.child:nth-child(2)&#123; width:69%; background-color:yellow;&#125; 如图：定宽之后，页面宽度仍有剩余优化之后的导航条，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;style&gt; .parent&#123; margin-left:auto; margin-right:auto; background: #ddd; /*定死宽度则不会影响页面 */ min-width:600px; &#125; .child&#123; &#125; .child:nth-child(1)&#123; width:100px; background-color:#333; color: white; text-align:center; line-height:36px; height:36px; &#125; .child:nth-child(2)&#123; &#125; /* 清除浮动 */ .clearfix::after&#123; content:&apos;&apos;; display:block; clear:both; &#125; .clearfix&#123; zoom: 1; &#125;/*IE6*/ .content&#123; border:1px solid black; margin-right:10px; &#125; .nav&#123; line-height:24px; padding:6px 0; &#125; .navItem&#123; margin-left:20px; &#125; &lt;/style&gt; &lt;div class=&quot;parent clearfix&quot; &gt; &lt;div class=&quot;child&quot; style=&quot;float:left;&quot;&gt;logo&lt;/div&gt; &lt;div class=&quot;child&quot; style=&quot;float:right;&quot;&gt; &lt;div class=&quot;nav clearfix&quot;&gt; &lt;div style=&quot;float:left&quot; class=&quot;navItem&quot;&gt;导航1&lt;/div&gt; &lt;div style=&quot;float:left&quot; class=&quot;navItem&quot;&gt;导航2&lt;/div&gt; &lt;div style=&quot;float:left&quot; class=&quot;navItem&quot;&gt;导航3&lt;/div&gt; &lt;div style=&quot;float:left&quot; class=&quot;navItem&quot;&gt;导航4&lt;/div&gt; &lt;div style=&quot;float:left&quot; class=&quot;navItem&quot;&gt;导航5&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 2、图片位布局——flex布局 a.给老子加 display: flexb.给老子加justify-content: space-between; 先看看第1种场景：实现方式：先不用flex布局，用浮动元素+margin+clearfix清除浮动 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;style&gt;/* 图片主要部分 */.banner&#123; width:800px; height:300px; background:#888; margin-left:auto; margin-right:auto; margin-top:10px; &#125;.pictures&#123; width:800px; margin:0 auto;/*不能删1：居中*//* background: black;最底层的颜色 */&#125;.picture&#123; width:194px; height:194px; background:#ddd; margin:4px; float:left;&#125;.pictures &gt;.xxx&#123; /*为什么不能只用两层div*//* background: rgba(255,0,0,0.8);倒数第二层颜色 */ margin-left:-4px; margin-right:-4px;/*不能删2：扩大范围*/&#125;/* .picture:nth-child(1)&#123; margin-left: 0;&#125;.picture:nth-child(4)&#123; margin-right: 0;&#125; */&lt;style&gt; &lt;div class=&quot;banner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pictures&quot;&gt; &lt;div class=&quot;xxx clearfix&quot;&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 如图：这种方式可以兼容IE6，且即使减少一个板块也不会影响其它板块，如图： 再看第2种场景：实现方式：flex布局 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt;.banner&#123; width:800px; height:300px; background:#888; margin-left:auto; margin-right:auto; margin-top:10px;&#125;.pictures&#123; width: 800px; /* 定宽不够弹性 */ margin: 0 auto; display: flex; /* 弹性布局 */ flex-wrap: wrap; /* 换行*/ justify-content: space-between;/* 多余空间放在空间或水平居中 */ /* align-items: center; 垂直居中 */&#125;.picture&#123; width: 194px; height: 194px; background: #ddd; margin-top: 4px; margin-bottom: 4px;&#125;&lt;/style&gt; &lt;div class=&quot;banner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pictures&quot;&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;/div&gt; 不过如果不是等份的图片板块，就会出现下方bug： 如何解决?代码如下：flex布局至bug修复 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style&gt;*&#123;box-sizing: border-box;&#125;.banner&#123; width:800px; height:300px; background:#888; margin-left:auto; margin-right:auto; margin-top:10px;&#125;.pictures&#123; width: 800px; /* 定宽不够弹性 */ margin: 0 auto; &#125;.pictures &gt; .xxx&#123; display: flex; /* 弹性布局 */ flex-wrap: wrap; /* 换行 */ margin: 0 -4px;&#125;.picture&#123; width: 194px; height: 194px;/* 或者 width: calc(25% - 8px); height: 194px; */ background: #ddd; /* 边框可去掉border: 1px solid red; */ margin: 4px;&#125;&lt;/style&gt; &lt;div class=&quot;banner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pictures&quot;&gt; &lt;div class=&quot;xxx&quot;&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 如图： 3、广告位布局——浮动+margin+clearfix清除浮动代码如下： 1234567891011121314151617181920212223242526272829&lt;style&gt;.art&#123; background: #ddd; width:800px; margin:0 auto;&#125;.art &gt; .sider&#123; float:left; border: 1px solid black; width:33.333333%; height:300px&#125;.art &gt; .main&#123; float:left; border: 1px solid black; width:66.333333%; height:300px&#125;&lt;/style&gt; &lt;div class=&quot;art clearfix&quot;&gt; &lt;div class=&quot;sider&quot;&gt; &lt;div&gt;广告1&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;div&gt;广告2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 如图： 广告位之间的间距如何处理：方法1： 采用内嵌一个div，定宽，float+margin-right进行间隙（这种方法似乎要兼容啊，做了很久弄不出，不弄了）方法2： calc计算法+margin 1234567891011121314151617181920212223242526272829&lt;style&gt;.art&#123; background: #ddd; width:800px; margin:0 auto;&#125;.art &gt; .sider&#123; float:left; width:calc( 33.333333% - 20px);/* calc计算法，此时右侧多出20px */ border: 1px solid black; height: 300px; margin-right: 20px; /* 用多出的20px，弥补上那块间隙 */&#125;.art &gt; .main&#123; float:left; border: 1px solid black; width:66.666666%; height:300px&#125;&lt;/style&gt; &lt;div class=&quot;art clearfix&quot;&gt; &lt;div class=&quot;sider&quot;&gt; &lt;div&gt;广告1&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;div&gt;广告2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 如图： 方法3： flex布局（IE不支持） a.父元素：display:flex+justify-content:space-betweenb.父元素+子元素：display:flex+margin-right:auto 123456789101112131415161718192021&lt;style&gt;.art&#123; background: #ddd; width:800px; margin:0 auto; display: flex; /* flex直接左右布局 */ justify-content: space-between;/* 第2种方法：将空隙放中间 */&#125;.art &gt; .sider&#123; width:calc( 33.333333% - 20px); /* calc计算法，此时右侧多出20px */ border: 1px solid black; height: 300px; /* margin-right:auto; 第1种方法 */&#125;.art &gt; .main&#123; border: 1px solid black; width:66.666666%; height:300px&#125;&lt;/style&gt; 如图也是： 三、布局套路口诀（下） 👉移动端布局 添加：meta:vp (tab键): 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; 收起pc端导航：删除定宽+{margin:0; padding:0;} 导航 PC和手机适配的问题 123456789101112/* 导航PC和手机适配的问题 */.parent .nav2&#123; display:none;&#125;@media (max-width:420px)&#123; .parent .nav2&#123; display:block; &#125; .parent .nav&#123; display:none; &#125;&#125; banner适配移动端 123456789101112/*banner适配移动端*/.banner&#123; width:800px; /*万恶的定宽 PC端必备*/ height:300px; background: #888; margin-left: auto; margin-right: auto; margin-top: 10px; &#125;@media (max-width:420px)&#123; .banner&#123;width:auto;&#125;&#125; 图片板块适配移动端 12345678910111213141516171819202122232425262728/*图片板块适配移动端*/.pictures&#123; width: 800px; /* 万恶的定宽PC端必备;定宽布局不够弹性 */ margin: 0 auto; /*不能删1：居中*/ overflow:hidden; /* 避免溢出 */ &#125;@media (max-width:420px)&#123; .pictures&#123;width:auto;&#125; &#125;.pictures &gt; .xxx&#123; display: flex; /* 弹性布局 */ flex-wrap: wrap; /* 换行*/ margin: 0 -4px;&#125;/*图片板块适配移动端2*/.picture&#123; width: calc(25% - 8px); height: 194px; background: #ddd; margin: 4px;&#125;@media (max-width:420px)&#123; .picture&#123; width: calc(50% - 8px); &#125;&#125; 广告位适配移动端 123456789101112131415161718192021222324252627282930313233343536373839/*广告位适配移动端*/.art&#123; background: #ddd; width:800px; /*万恶的定宽 PC端必备*/ margin:0 auto; display: flex; /* flex直接左右布局 */ justify-content: space-between;/* 第2种方法：将空隙放中间 */&#125;@media (max-width:420px)&#123; .art&#123; width: auto; flex-direction:column; &#125;&#125;.art &gt; .sider&#123; width:calc( 33.333333% - 20px); /* calc计算法，此时右侧多出20px */ border: 1px solid black; height: 300px; /* margin-right:auto; 第1种方法 */&#125;@media (max-width:420px)&#123; .art &gt; .sider&#123; width: auto; height: auto; &#125;&#125;.art &gt; .main&#123; border: 1px solid black; width:66.666666%; height:300px&#125;@media (max-width:420px)&#123; .art &gt; .main&#123; width: auto; height: auto; &#125;&#125; 关于图片添加：（注：变形问题减少使用img） 12background:transparent url(https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=292576901,2272109431&amp;fm=27&amp;gp=0.jpg) no-repeat center; background-size: cover; /*尽量全地显示图片*/ 注： 代码总链接：布局套路固定比例div：图片1：1显示或者2：1显示CSS渐变方法：解决背景样式渐变问题]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（七）：布局基础]]></title>
    <url>%2F2018%2F11%2F12%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、什么是布局1、现有的布局满足不了人们的需求文档流、浮动、定位 2、用户中所需要的： 导航栏+内容 导航栏+内容+广告栏 从上到下、从左到右、定宽、自适应… 二、几种布局介绍1、单列布局 一栏布局 一栏布局（通栏） 实现方式： 定宽 + 水平居中 123width: 1000px; /*或 max-width: 1000px;*/margin-left: auto;margin-right: auto; 范例：单列布局——一栏布局关键代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style&gt; .layout&#123; /* width: 960px; */ max-width: 960px; margin: 0 auto; &#125; //给 body 设置min-width 去掉滚动背景色 bug body&#123; min-width: 960px; &#125; #header&#123; height: 60px; background: red; &#125; #content&#123; height: 400px; background: blue; &#125; #footer&#123; height: 50px; background: yellow; &#125;&lt;/style&gt;/* 如图1：此时的定宽是width:560px */&lt;div class=&quot;layout&quot;&gt; &lt;div id=&quot;header&quot;&gt;头部&lt;/div&gt; &lt;div id=&quot;content&quot;&gt;内容&lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;尾部&lt;/div&gt;&lt;/div&gt;/* 或通栏的单列布局,此时```.layout&#123;border:1px solid&#125;``` */ &lt;div id=&quot;header&quot;&gt; &lt;div class=&quot;layout&quot;&gt;头部&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;context&quot; class=&quot;layout&quot;&gt;内容&lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; &lt;div class=&quot;layout&quot;&gt;尾部&lt;/div&gt; &lt;/div&gt;//或省标签，便于控制局部 如图2：&lt;div id=&quot;header&quot; class=&quot;layout&quot;&gt;头部&lt;/div&gt;&lt;div id=&quot;content&quot; class=&quot;layout&quot;&gt;内容&lt;/div&gt;&lt;div id=&quot;footer&quot; class=&quot;layout&quot;&gt;尾部&lt;/div&gt; 如图： 2、双列布局一列固定宽度，另一列自适应宽度实现方式：浮动元素 + 普通元素margin+老子清除浮动注： 布局时，考虑到渲染顺序，浮动元素代码优先写在其他元素前面，优先渲染第1种场景：两列布局范例：双列布局 12345678910111213141516171819202122232425262728&lt;style&gt; #content:after&#123; //第3步：添加一个伪元素清除浮动 content: &apos;&apos;; display: block; clear: both; &#125; .aside&#123; width: 200px; height: 500px; background: yellow; float: left; //第1步：浮动元素 &#125; .main&#123; margin-left: 210px; //第2步：margin-left（right） height: 400px; background: red; &#125; #footer&#123; background: #ccc; &#125; &lt;/style&gt; &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;aside&quot;&gt;aside&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt; 如图： 第2种场景：两列布局侧边栏aside在右侧：范例：双栏布局——侧边栏（aside）在右侧 1234567891011121314151617181920212223242526272829&lt;style&gt; #content:after&#123; //第3步：清除浮动 content: &apos;&apos;; display: block; clear: both; &#125; .aside&#123; width: 200px; height: 500px; background: yellow; float: right; //第1步：浮动 &#125; .main&#123; margin-right: 210px; //第2步：margin height: 400px; background: red; &#125; #footer&#123; background: #ccc; &#125; &lt;/style&gt; &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;aside&quot;&gt;aside&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt; 如图： 3、三列布局两侧两列固定宽度，中间列自适应宽度实现方式：浮动元素+margin+伪类元素清除浮动 1234567891011121314151617181920212223242526272829303132333435#content:after&#123; ////第3步：伪类元素 content: &apos;&apos;; display: block; clear: both; &#125; .menu&#123; width: 100px; height: 500px; background: pink; float: left; //第1步：浮动 &#125; .aside&#123; width: 200px; height: 500px; background: yellow; float: right; //第1步：浮动 &#125; .main&#123; margin-left: 110px; /*为什么要加margin-left*/ //第2步：margin margin-right: 210px; //第2步：margin height: 400px; background: red; &#125; #footer&#123; background: #ccc; &#125; &lt;div id=&quot;content&quot;&gt; &lt;!-- 为什么不是main在前面： 渲染顺序--&gt; &lt;div class=&quot;menu&quot;&gt;menu左&lt;/div&gt; &lt;div class=&quot;aside&quot;&gt;aside右&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;content中&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt; 如图： 4、水平等距布局实现方式：处理老子（居中、防溢出）+浮动+ margin 1234567891011121314151617181920212223242526272829303132333435363738&lt;style&gt;ul,li&#123; margin: 0; padding: 0; list-style: none; //取消列表的实心小黑点&#125;.ct&#123; overflow:hidden; //溢出隐藏 width: 640px; border:dashed 1px orange; margin: 0 auto; //相对于页面的居中&#125;.ct .item&#123; float:left; //第1步：浮动 margin-left: 20px; //第0步：提前设置 margin-top: 20px; //第0步：提前设置 width:200px; height:200px; background: red;&#125;.ct&gt;ul&#123; margin-left: -20px; //第2步：补充不够的20px&#125;&lt;/style&gt;&lt;div class=&quot;ct&quot;&gt; &lt;ul&gt; &lt;li class=&quot;item&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;3&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;4&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;5&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;6&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;7&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;8&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 如图： 三、其他布局 圣杯布局 双飞翼布局 流式布局 Grid布局 Flex布局 移动端布局（meta、媒体查询、动态rem）]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（六）：元素居中]]></title>
    <url>%2F2018%2F11%2F11%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[一、元素水平居中1、text-align实现水平居中text-align:center; 行内元素（图片或文字）居中在父元素上设置text-align: center 使文字/图片在整个页面上水平居中 123 .container&#123; text-align:center;&#125; 如一小选项按钮居中，可以使用： 1234 .container&#123; display:inline-block; text-align:center;&#125; 2、margin实现水平居中margin: 0 auto; 用于块级元素的居中 123456.container &#123; width: 80%; /*块级元素充满页面 定宽必备 */ margin-left: auto; margin-right: auto; /*或者 margin：0 auto;*/&#125; 如：块级元素居中代码如下： 1234567891011121314 &lt;style&gt; .wrap&#123; max-width:600px; background: #ccc; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;p&gt;world&lt;/p&gt; &lt;/div&gt; 二、元素垂直居中1、居中 VS 不居中注： 高度由里面的内容撑开，一般不设置高度代码如下： 123456789101112 &lt;style&gt;.ct&#123; padding: 40px 0; text-align: center; background: #eee;&#125; &lt;/style&gt;&lt;div class=&quot;ct&quot;&gt; &lt;p&gt;你好世界&lt;/p&gt; &lt;p&gt;helloworld&lt;/p&gt; &lt;/div&gt; 2、vertical-align实现垂直居中vertical-align: middle; 让行内元素或表格元素相对于基线对齐并居中案例：如图片进行水平、垂直居中代码如下：图片在容器内水平、垂直居中 12345678910111213141516171819202122232425&lt;style&gt;.box&#123; width: 300px; height: 200px; border: 1px solid ; text-align: center;&#125;/*注：子元素和父元素分别设置 vertical-align:middle; ，均无法实现垂直居中*//*使用一个伪元素，设置一个虚拟的基准线*/.box:before&#123; content: &apos;&apos;; display: inline-block; height: 100%; vertical-align: middle; ✔️&#125;.box img&#123; vertical-align: middle; ✔️ background: blue;&#125;&lt;/style&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;http://cdn.jirengu.com/public/logo-tiny.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; 如图： 3、table-cell 实现垂直居中display: table-cell;水平垂直居中代码如下： 1234567891011121314&lt;style&gt;.box&#123; width: 300px; /*由于是行内元素，宽度必备*/ height: 200px; border: 1px solid ; display: table-cell; ✔️ vertical-align: middle; ✔️ text-align: center;&#125;&lt;/style&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;http://cdn.jirengu.com/public/logo-tiny.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; 4、绝对定位实现居中案例：如弹出框 弹出框水平垂直居中情况1： 固定宽高块在浏览器窗口水平垂直居中，代码如下： 123456789101112131415161718192021222324252627282930&lt;style&gt;html,body &#123; height: 100%;&#125;.dialog &#123; position: absolute; /*绝对定位*/ left: 50%; top: 50%; margin-left: -200px; margin-top: -150px; width: 400px; height: 300px; box-shadow: 0px 0px 3px #000;&#125;.dialog .header&#123; padding: 10px; background: #000; color: #fff;&#125;.dialog .content&#123; padding: 10px;&#125;&lt;/style&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;div class=&quot;header&quot;&gt;我是标题&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;我是内容&lt;/div&gt; &lt;/div&gt; 情况2： 去掉宽高的块在浏览器窗口水平垂直居中，代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;style&gt;html,body &#123; height: 100%;&#125;.dialog &#123; position: absolute; left: 50%; top: 50%; /* margin-left: -200px; margin-top: -150px; */ /*CSS3属性 相对于自己的偏移*/ transform:translate(-50%,-50%); box-shadow: 0px 0px 3px #000;&#125;.dialog .header&#123; padding: 10px; background: #000; color: #fff;&#125;.dialog .content&#123; padding: 10px;&#125;&lt;/style&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;div class=&quot;header&quot;&gt;我是标题&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;我是内容&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;我是内容&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;我是内容&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;我是内容&lt;/div&gt; &lt;/div&gt; 5、table自带功能实现垂直居中参考demo：table自带功能实现垂直居中 6、100% 高度的 afrer before 加上 inline block实现垂直居中参考demo：100% 高度的 afrer before 加上 inline block实现垂直居中 7、margin-top: -50%实现垂直居中参考demo：margin-top: -50%实现垂直居中 8、flex布局实现垂直居中参考demo：flex布局实现垂直居中]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（五）：BFC和边距合并]]></title>
    <url>%2F2018%2F11%2F10%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9ABFC%E5%92%8C%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[一、BFC1、定义：先给一个官方的定义：（说的什么东西反正我没看懂） Formatting context(格式化上下文)是W3CCSS2.1规范中的一个概念。每个渲染区域用formattingContext表示，它是页面中的一块渲染区域，并且有一套渲染规则。它决定了其子元素将如何定位，以及和其他元素的关系和相互作用 再看下面这个定义：（有一点点懂） BFC（Block FormattingContext），块级格式化上下文。相当于制定一种如BFC这样的规则，在普通流中按照该规则进行布局。 在正常流中的盒子要么属于块级格式化上下文（BFC），要么属于内联格式化上下文，即块级元素在页面渲染的时候遵循怎么样的规则，它们之间有怎么样的作用。 再看这个：（还是一点点懂） 具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性。通俗一点来讲，可以把 BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 总结：BFC没有定义，只有功能或特性 2、BFC会在哪里产生（官方的）只要元素满足下面任一条件即可触发 BFC 特性（1）body根元素html里的根元素产生相应的“块级格式化上下文”这类的规则，如某些规则：块级容器可以充满父容器，父容器可以被子元素撑开，外边距产生合并，渲染顺序是从上到下（同一个块级格式化上下文中相邻块级盒之间的竖直margin会合并）（2）浮动元素：float除了none以外的值；如float:left;该元素属性本身也产生了相应的块级格式化上下文。该元素产生的BFC与所在的根元素的BFC互不影响，此元素的作用域，则为该元素服务，与根元素产生一个隐形的边界（3）绝对定位元素：position为absolute或fixed；（4）display为inline-block（非块盒的块容器）, flex, 或inline-flex；（5）overflow除了visible以外的值（hidden、auto、scroll） 3、应用这里的例子截取自该文章：10 分钟理解 BFC 原理（1）功能1让两个相邻的元素界限分明（同一个 BFC 下外边距会发生重叠或合并）代码如下： 1234567891011&lt;head&gt;div&#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125;&lt;/head&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; 从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div的下边距和第二个div的上边距发生了重叠，所以两个盒子之间距离只有100px，而不是 200px。如图：首先这不是 CSS 的bug，我们可以理解为一种规范。如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 123456789101112131415161718 &lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;style&gt;.container &#123; overflow: hidden; ✔️&#125;p &#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125;&lt;/style&gt; 这时候，两个盒子边距就变成了 200px ，如图： （2）功能2子元素被父元素包裹起来（BFC可以包含浮动的元素）（可代替clearfix来清除浮动） display:flow-root; 让当前元素触发BFC（正交，考虑浏览器兼容） 1overflow:hidden; 将溢出隐藏浮动的元素会脱离普通文档流， 来看下下面一个例子，代码如下： 123456789101112131415&lt;style&gt; .father&#123; border: 1px solid #000; &#125; .son&#123; width: 100px; height: 100px; background: #eee; float: left; &#125;&lt;/style&gt; &lt;div class=father&gt; &lt;div class=son&gt;&lt;/div&gt; &lt;/div&gt; 由于父元素（father）内子元素（son）进行浮动，脱离了“父亲”的文档流，所以容器只剩下 2px 的边距高度。此时可以触发容器的 BFC，那么“father”就可以包裹住“son”出去的浮动元素。 12345678910111213141516&lt;style&gt; .father&#123; border: 1px solid #000; overflow:hidden; ✔️ &#125; .son&#123; width: 100px; height: 100px; background: #eee; float: left; ✔️ &#125;&lt;/style&gt; &lt;div class=father&gt; &lt;div class=son&gt;&lt;/div&gt; &lt;/div&gt; （3）功能3BFC 可以阻止元素被浮动元素覆盖。先来看一个文字环绕效果，代码如下： 12345678910111213141516&lt;style&gt;.box1&#123; height: 100px; width: 100px; float: left; background: lightblue;&#125;.box2&#123; width: 200px; height: 200px; background: #eee;&#125;&lt;/style&gt;&lt;div class=box1&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div class=box2&gt;我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt; 此时，浮动元素浮在第二个元素上，第二个元素有部分区域被浮动元素所覆盖(但文本信息不会被浮动元素所覆盖) 。如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入overflow:hidden；或者display:flow-root; 1234567891011121314151617181920212223&lt;style&gt;.box1&#123; height: 100px; width: 100px; float: left; ✔️ background: lightblue;&#125;.box2&#123; width: 200px; height: 200px; background: #eee; overflow:hidden; ✔️ /*或 display: flow-root; */ ✔️&#125;&lt;/style&gt;&lt;div class=box1&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div class=box2&gt;我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt; 就会变成：BFC 浮动处理用来实现两列自适应布局：即左边宽度固定，如果想右边的内容自适应宽度，可以去掉上面右边内容的宽度（如果右边定宽，窄页面时，则会自动换到下一行排列） 二、边距合并1、讲例子案例1：当实际中希望#header和h1之间产生一点缝隙（或间距），即使将h1设置 margin:50px;，作为块级元素的h1，margin左右生效，而上下则是#header+h1整体向下移动50px这便是，外边距合并 案例2：看案例似乎是&lt;h1&gt;和&lt;p&gt;标签所设置的外边距各30px，两者之间的间距理论来讲应该是60px，但事实上这是两个相邻元素的外边距产生合并，下边距&lt;margiin-bottom&gt;和上边距&lt;margin-top&gt;合并之后取较大值，这里为30px这也是，外边距合并 2、合并场景（1）相邻元素合并同案例2（2）父子合并h1和header，或者再嵌套元素或者与其的祖先元素嵌套，均能产生外边距合并，这些都能称之为“父子合并” ,如图：（3）自己合并如图，块级元素合并，无默认样式即靠在一起；含有p标签（含内容）的块级元素，则有默认上下margin，所以detail和footer则会产生缝隙（或间距） .footer元素为空内容，设置 margin:30px; ，即说明上边距和下边距合并后的外边距总值是60px，不过.footer元素为空内容，所以页面效果仍然呈现30px，说明css元素中外边距合并的另一种情况： 自己和自己合并： 如图： 三、取消合并（如何去解决外边距合并？）1、边框、padding 存在于父子合并 为何#header和h1能够产生合并？即#header没有border和padding（即一个可与外界隔离的边界线），导致h1自带的一个margin，冲出该边界，与#header合并 尝试在#header里添加边框（图1）或者加padding（内边距）（图2），让#header和h1的margin-top，内外分开，即能做到不让外边距合并，如图： 2、BFC如何让一个元素生成bfc？bfc可认为是拥有一片独立的空间，和其他的空间（或其他的文档流）区别开。注：添加bfc元素属性，可以取消合并有可能产生副作用（1）父子元素不产生合并A、添加：overflow:hidden；B、添加 ：float:left;C、添加： display:inline-block;D、添加： position:absolute; （2）相邻元素不产生合并A、添加：浮动元素B、添加：overflow:hidden；生成BFC，相当于生成了一个边界，即边框作为一个边界，有了边界之后，#header+h1父子元素便不能冲破该边界，自然与#detail元素的不产生合并. 【重点】： 而相邻元素之间的margin，可以认为不是该父子元素边界内，同样会产生合并。通常处理相邻元素之间的间距合并问题（除浮动外，浮动时不会被合并），即不考虑合并问题，直接设置为：margin-top:___px;]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（四）：浮动和定位]]></title>
    <url>%2F2018%2F11%2F09%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%B5%AE%E5%8A%A8%E5%92%8C%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[自我总结： 浮动是实现布局的一种常见方式 浮动脱离普通文档流，即页面渲染时，盒模型按标准会将父元素所设置的属性将页面撑开；加入浮动后，父元素不会发现浮动元素，父元素则不会被浮动元素撑开页面）。 块级元素默认样式可以撑满父容器，加入浮动后，块级元素浮动则会收缩到内容本身的宽度。 加入浮动后，在父元素中看不见浮动元素，在行内元素看得见浮动，如文本或其他行内元素都会环绕浮动元素。 加入浮动后，浮动盒会向左或向右移动，直到其外边挨到包含块边沿或者另一个浮动盒的外边。 当同一个方向的浮动元素：当一个浮动元素在浮动过程中碰到同一个方向的浮动元素时，它会紧跟在它们后面； 当反方向的浮动元素：互不影响，位于同一条水平线上，当空间不够时会被挤下。 当浮动盒的宽度不一样时，紧跟后面的另一浮动盒则会出现卡住的现象。 加入浮动后，块级元素内容宽度会缩短，呈现inline-block的特性，放不下会换行；行内元素则以块级元素特性呈现，可以设置width、height、margin。 一、浮动：1、从实践尝试到理论定义（1）例子1：放不下会换行一个浮动盒会向左或向右移动，直到其外边（outerEdge）挨到包含块边沿或者另一个浮动盒的外边。如果没有足够的水平空间来浮动，它会向下移动，直到空间合适或者不会再出现其它浮动了（2）例子2：被卡住高度不一样，即出现一个卡住的问题（3）例子3：文本被缩短下移注： 未设置样式的块级元素，即有默认样式，margin-top(or bottom);因为浮动（盒）不在普通流内，在浮动盒之前或者之后创建的未定位的块盒会竖直排列，就像浮动不存在一样。接着，浮动（盒）创建的当前及后续行盒会进行必要的缩短，为了给浮动（盒）的 margin box 让出空间。 例子：如一个普通元素（如p）遇到浮动元素之后，普通元素（如p）看不见这个浮动元素，但这个普通元素里的行盒（文字生成的行盒特性）能看到该浮动元素。当浮动盒宽度变化，文字行盒也会相应地被挤下去换行。 2、从理论到实现效果（1）浮动元素脱离普通流？A、普通流是什么？页面渲染时，遵循“块级元素占据一行，行内元素一行水平排列占据它自身宽度，再来块级元素素依次向下排列”规律，并且这些元素从上到下，从左到右会将父元素所展示的页面撑开。B、脱离普通流：父元素计算宽高的时候，发现不了浮动元素。一旦有浮动元素，块级元素不会按照“从上到下，从左到右”的顺序去展示页面，块级元素会收缩内容宽度（呈现inline-block的特性），那么，父容器不会被里面的浮动元素撑开；行内元素则会能看见浮动元素，如文本或其他行内元素则会环绕浮动元素。例子：脱离普通流？！ （2）小结： 块级元素浮动，宽度会收缩（width:100%;的用武之地）； 行内元素浮动，以块级特性呈现（不用再写display: inline-block;）块级元素浮动宽度收缩，行内元素浮动以块级特性呈现 注： 块级元素默认样式可以撑满父容器，块级元素浮动则会收缩到内容的本身的宽度。如： 1234.box&#123; float: left; background: red; &#125; 注： 行内元素能发现浮动元素，如设置float或者position元素属性，便有了块级元素的特性，可以设置宽高。 1234567span&#123; float: left; background: blue; width: 100px; height: 50px; margin: 10px; &#125;; （3）注： 脱离普通流？！VS abosolute 3、浮动的使用场景（1）两栏布局特指一侧是固定宽度，另一侧是自适应（用margin间隔来表示自适应的作用，是因为普通的块级元素会充满整个页面）左侧固定宽度，右侧自适应 （反之，也可以） （2）三栏布局指两侧宽度固定，中间内容区块自适应简单的三栏布局注： 注意html结构顺序，即按照class为menu——aside——main的div元素顺序写法当一个浮动盒按照设置实现左浮动时，另一个浮动元素设置为右浮，此时这个右浮，即相对于同级元素的高度进行右浮（除非页面放不下被挤下移除外）。 （3）导航条list-style:none; float：left(or right); margin-left:XXpx; 左浮导航 右浮导航 4、清除浮动（1）为什么要清除浮动？虽然浮动是一种实现布局的方式，但是浮动在父元素中看不见。一旦在元素标签内加入了浮动，浮动脱离了普通流，在页面渲染时并不会按照html结构的计算规则，浮动元素会导致父元素所设置的页面无法撑开，浮动甚至会让浮动的效果叠放在页面某些元素效果上。所以必要时，需要清除浮动，这也是浮动实现布局的重要一环。从浮动具有副作用说起：问题A：对后续元素位置产生影响问题B：父容器告诉计算出现问题（2）clear:left;?例子：clear:left? clear:left;：要求该盒的topborder边位于源文档中在此之前的元素形成的所有左浮动盒的bottom外边下方 clear: right;:要求该盒的topborder边位于源文档中在此之前的元素形成的所有右浮动盒的bottom外边下方 即：box2设置clear:right有效吗?有 （3）清除浮动的两大副作用对应问题B：父容器告诉计算出现问题 【重点】由于浮动在父容器中不能被发现，但要解决父容器（或页面）撑开的问题，我们必须在浮动和父容器（或者浮动元素）共存时寻找到一种解决方法。即在带有浮动属性的父元素标签中添加class为clearfix，关于伪元素属性::after （或::before）的固定代码样式，伪元素清除浮动法（IE8以上使用）： 123456789.clearfix::after &#123; content:&apos;&apos;; display: block; clear: both;&#125;/*或触发ie6的属性*/.clearfix &#123; *zoom:1;&#125; 设置一个普通元素内不具有浮动的属性参数，即float：none;和clear: left; 即可将完成clear:left;的效果【注意：应注重css元素的权重，以免报错】或【解决方法：】 方法1：父容器与浮动共存问题的解决 方法2：#1采用伪元素（一个替代标签）解决行内浮动问题#2采用伪元素（一个替代标签）解决块级浮动问题 （4）总结实现一个水平布局 方法1：设置display：inline-block;，注意缝隙和上对其的问题 方法2：加入浮动，用clearfix的固定代码包裹解决父元素撑开页面的问题 二、定位1、什么是定位？（1）先了解正常/文档流（Normal Flow）是什么Normal Flow即浏览器默认的文档布局方式。一旦添加了浮动和定位，脱离文档流之后，页面布局的规则发生变化。 （2）定位通过设置position属性来覆盖默认的布局样式。即元素添加position和对应的属性值，它则会脱离了文档流。position，让一个元素的位置在以前的基础上产生变动。（考虑：相对于谁和属性值） 2、定位的类型（1）静态定位 ：position: static;:默认值 默认的布局方式。（2）相对定位：相对于自身的位置position: relative;:相对默认的布局位置进行定位。注： left和top只对position:absolution/relative/fixed;生效所谓的相对定位，是针对移动的元素自身，相对于它本身原先位置做了对应位置的偏移。但它所占用的文档流位置大小是没有变的。 （3）绝对定位：相对于父元素位置position: absolute; 绝对定位元素脱离正常文档流，相对其定位上下文（Positioning Context）进行定位。 即页面上的正常元素看不见该绝对定位元素。但页面上绝对定位常覆盖其他元素。多个绝对定位元素存在页面，它们之间的绝对定位也相互看不见，产生重叠现象。 寻找页面中一个元素绝对位置，可以先设置该元素绝对定位：position: absolute; 然后先从它的父元素中进行相对定位：position: relative; 中确定该元素的绝对定位；如果没有此绝对定位，再从它的父元素的父元素（如body）里的位置找；如果没有，则根据html的根节点作为参考。 总结： 使用绝对定位时，设置好参考点，一般，绝对定位的参考点为元素父容器如一个元素设置了position：absolute；，那么它的父容器则设置position：relative； 注： 元素中使用了position：absolute;，就像浮动一样有了一些特性： A、加入绝对定位后，宽度收缩B、加入绝对定位后，行内元素呈现快接的特性，可以添加宽高（4）z-index由于使用绝对定位之后，产生元素覆盖的问题，z-index可以解决元素之间覆盖顺序的问题,，设置它的层叠顺序。如：（5）固定定位position: fixed; 相对浏览器窗口进行定位。如“回到顶部”、“内容变固定窗口不变”等效果。因此当滚动产生时，固定定位元素依然处于窗口的某个固定位置。 12345.feedback &#123; right: 30px; bottom: 30px; position: fixed;&#125; （6）粘性定位（兼容性差）position: sticky;是相对定位和固定定位的结合。默认情况下表现为相对定位，当浏览器窗口顶端与元素的距离等于 top 属性的值时，转变为固定定位。如： 三、浮动和定位——解决的一些问题1、BFC和浮动2、浮动和负边距两个浮动元素，如果因放不下导致其中一个下移，对下移的元素设置负 margin值大于自身的宽度可将其上移如： 3、用inline-block;还是浮动（1）inline-block; 优势: 不需要清除浮动，简单，在设置居中时更方便,适合子内容不多的元素水平排列 劣势: 需要注意缝隙，注意对齐，ie8以下不能用 （2）float 优势: 兼容性好，没缝隙问题 劣势: 需要清除浮动，适合稍大的布局 4、用定位还是浮动？大布局、自适应用浮动；小元素、固定宽高用定位。具体要结合实际情况是关键。如：]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（三）:基本样式（下）]]></title>
    <url>%2F2018%2F11%2F08%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、背景 属性 描述 background 简写属性，将背景属性设置在一个生命中 background-attachment 背景图像是否固定或者随着页面的其余部分滚动 background-color 可设置元素的背景颜色 background-image 可把图像设置为背景 background-position 设置背景图像的起始位置（常用于图标在页面上的设置） background-repeat 设置背景图像是否重复，以及如何重复 background-size 设置背景的大小（兼容性）（css3） 1、background-position ：默认图片主要从左上角方向偏移 x y x% y% [top | center | bottom] [left | center | right] 2、background-repeat：背景图像是否重复或如何重复 no-repeat：背景图片在规定位置 repeat-x：图片横向重复 repeat-y：图片纵向重复 repeat：全部重复 3、background-size：背景图片大小的设置，用来拉伸、缩放 100px 100px contain cover 4、关于background相关元素的属性，代码如下：12345/*背景色和背景图片使用场景 */场景1：两元素适用于页面大、背景图片小场景2：背景图为.png格式的图片*/background-color: #f00; background-image: url(background.gif); background-repeat: no-repeat; background-attachment: fixed; background-position: 0 0;/*背景位置与页面窗口的宽、高成正相关*/ 可缩写为一句：background: #f00 url(background.gif) no-repeat fixed 0 0;如图： 注：使用background-color和background-image，需要注意：（1）将该页面撑开（2）注意background-size使用 二、CSS Sprite1、俗称“雪碧图”或“精灵图”指将不同的图片、图标合并在一张图上。2、作用：使用CSS Sprite 可以减少网络请求（如每一张小icon图片都会产生加载时间），提高网页加载性能。3、使用：利用background-position，对图标进行位置偏移三、隐藏or透明 opacity: 0; ：透明度为0，整体（透明度0-1，0.5为半透明） visibility: hidden; : 即元素看不见，但存在。 和opacity：0；类似 display：none； : 消失，不占位置（页面上渲染的其他元素都察觉不到） background-color ：rgba（0，0，0，0.2） 只是背景色透明 四、inline-block1、定义：既呈现inline特性（不占据一整行，宽度由内容宽度决定），又呈现block特性（可设置宽高，内外边距）注： display:block;的布局下，块级元素的宽度是一个可忽视的问题 2、缝隙问题：如图： 3、行内元素对齐问题：如图：在inline-block的布局下，可以看成文字对齐。默认情况下，行内元素对齐是以里面内容的底部为基线对齐（至少两个元素进行对比），其他则设置vertical-align：top(bottom、middle)等）进行基线对齐（在表格中使用尤为明显） 五、line-height1、定义：用于设置单行文本的行高。 2、几个问题：（1）了解line-height和margin、padding在使用上的一个区别 line-height: 2，所占据的行高是本身文字高度的2倍。 margin是外边距， padding则是内边距 （2）line-height的用法，数字和百分比的区别 12&gt; line-height：2`VS `line-height： 100%&gt; line-height具有继承性。 line-height:2，所占据的行高是本身文字高度的2倍。想要页面每个元素都拥有几倍的行高，则设置为数字。 line-height: 200% ，是其父元素文字高度的2倍。（注：百分比有一定的相对性，如本身无设置和设置百分比，便可看出差别） 3、height=line-heihgt设置垂直居中单行文本，如图： 六、盒模型1、IE 盒模型IE 盒模型的width包括：content尺寸+padding+border（如IE678怪异模式，不添加doctype，使用ie盒模型，宽度=边框+padding+内容宽度），如图： 2、W3C标准下的盒模型W3C标准下的盒模型padding、border所占的空间不在width、height范围内，content宽度即是width（如chrome，ie9+,ie678，添加doctype，使用标准盒模型，宽度=内容宽度），如图： 3、box-sizing（css3新样式）为了使用方便，可以用IE盒模型计算宽度的方法，将width=border+padding+内容宽度A、W3C标准的盒模型：box-sizing： content-boxB、IE盒模型：box-sizing：border-box 12&lt;div style=&quot;height:200px; width:200px; border:solid 10px #333; padding:100px&gt;&lt;/div&gt; 七、字体图标的实现1、字体图标的原理：当你写完带有字体的html文件时，在浏览器打开页面时，浏览器会读取 HTML 文件进行解析渲染。当读到「饥饿」两个字时会转换成对应的 unicode码（一种识别字体的特定编号）。再根据HTML里设置的font-family（如果没设置则使用浏览器默认设置）去查找电脑里（如果有自定义字体@font-face ，则加载对应字体文件）对应字体的字体文件。找到文件后根据 unicode 码去查找绘制外形，找到后绘制到页面上。 所以对于第二个范例， 「&amp;#9965」是「饥」的unicede码，所以用户最终也能看到serf字体样式的「饥」字。 2、实现步骤：第一步：进入Iconfont-阿里巴巴矢量图标库——选一个喜欢的图标——添加至购物车——添加至项目——复制Unicode码第二步：进入代码——并未展示图标（说明系统中没有能体现字体图标的该Unicode码，浏览器也未能识别Unicode码）——复制该图标自动生成的css代码（用@font-face来定义一个字体，该字体名可以随便取，这里为：XXX）——定义该字体图标，并设置它css样式如font-family：XXX；等样式 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; @font-face &#123; font-family: &apos;iconfont&apos;; /* project id 645342 */ src: url(&apos;//at.alicdn.com/t/font_645342_wae7ml0d77am7vi.eot&apos;); src: url(&apos;//at.alicdn.com/t/font_645342_wae7ml0d77am7vi.eot?#iefix&apos;) format(&apos;embedded- opentype&apos;), url(&apos;//at.alicdn.com/t/font_645342_wae7ml0d77am7vi.woff&apos;) format(&apos;woff&apos;), url(&apos;//at.alicdn.com/t/font_645342_wae7ml0d77am7vi.ttf&apos;) format(&apos;truetype&apos;), url(&apos;//at.alicdn.com/t/font_645342_wae7ml0d77am7vi.svg#iconfont&apos;) format(&apos;svg&apos;); &#125; p&#123; font-family: iconfont; font-size: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;&amp;#xe618;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 让一个元素”看不见”有几种方式？有什么区别? 1、display: none;给元素设置display:none;后，元素会从页面中彻底消失，它原本占据的空间会被其他元素占有，会造成浏览器的回流与重绘。 2、visibility: hidden;给元素设置visibility:hidden;后，元素会从页面中消失，它原本占据的空间会被保留，会造成浏览器的重绘，适用于希望元素隐藏又不影响页面布局的场景。 3、opacity: 0;给元素设置opacity:0;后，元素变成透明的我们肉眼就看不到了，所以原本占据的空间还在。 4、设置盒模型属性为0将height、width、padding、border、margin等盒模型属性的值全设为0，如果元素內还有子元素或内容，还应overflow: hidden;来隐藏子元素。 123456789.box1&#123; width: 0; height: 0; padding: 0; border: 0; margin: 0; overflow: hidden;&#125; 5、设置元素绝对定位与top、right、bottom、left等将元素移出屏幕如： 123456789.box1&#123; position: absolute; left: 100%;&#125;/*或*/.box1&#123; position: absolute; top: 100px;&#125; 6、设置元素的绝对定位与z-index，将z-index设置成尽量小的负数。但z-index是相对而言的，用z-index就要设置其他元素的z-index值，且如果元素本身占据空间很大就不一定会被z-index值比它大的元素完全覆盖，所以不推荐这种方法。 如： 12345678.box1 &#123; position: absolute; z-index: -100;&#125;.box2&#123; position: absolute; z-index: 1;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shadowsocks入坑不完全指南]]></title>
    <url>%2F2018%2F11%2F07%2Fshadowsocks%E5%85%A5%E5%9D%91%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[​ 国内的网络环境我不说相信大家都懂。虽然墙内的世界很丰富，但是墙外的世界还有着更加精彩的内容。以前上大学时候搜过免费fq教程，体验 Google 搜索、体验 Youtube、查阅学习资料，还有玩的部分游戏，然而大多数免费的不说麻烦而且不稳定，在别人的介绍下跳入了 Shadowsocks 的坑。已经用了快一年，最近又续了1年，访问速度也很快，强烈推荐给大家使用！！！ 购买服务 点击进入 Shadowsocks，进入首页后选择 订购服务。 之后选择你想要购买的服务，点击现在订购。我选择的是 Shadowsocks.com 入门版。需要注意的是，虽然显示的价格是美元，但是在后面支付的时候会自动转化为人民币。 界面上选择你想要购买的类型，然后点击订购。 在结账页面，你需要填写各种信息，需要认真填写，这也是在创建账号。 Shadowsocks 支持 Alipay 支付宝国际版。之后付款就可以了，前两天续费的时候是99.25人民币，平均8块多一个月，还是可以接受的（每个月少喝两瓶肥宅快乐水少抽包烟就是了）。 之后进入 客户中心，用第4步创建的账号登陆。 点击产品服务，可以看到你刚刚购买的服务，状态为有效。 点击刚刚购买的服务，会看到产品详情。下面有配置文件下载，选择 Windows 版下载。下载下来是 gui-config.json。 ​ 客户端安装使用支持的客户端：OS X， Windows， Linux， iOS， Android， OpenWRT 路由器等。详情请参考：客户端 - Shadowsocks，客户端都在 Github 上。 Windows 客户端 直接去 Github - Shadowsocks Windows 上下载吧，我的版本有点旧了也没更新。 解压后有一个 Shadowsocks.exe 文件。最好把这个文件放到一个目录下，比如新建一个 Shadowsocks 文件夹。 把刚刚下载的 gui-config.json 文件放到与 Shadowsocks.exe 相同的目录下。 双击 Shadowsocks.exe，会出现一个 GUI 界面，自动读取了 gui-config.json 文件中的内容。 在右下角托盘图标上会有一个好像纸飞机的 Shadowsocks 图标，右键-&gt;启动系统代理，就可以越过墙壁，浏览更多丰富多彩的内容啦~ 另外建议设置成 右键-&gt;开机启动，这样不用每次开机手动启动了。还可以在 右键-&gt;服务器 中选择不同的服务器。 Linux 客户端 首先你需要下载 Chrome 浏览器 【不需要翻墙】，已经有的小伙伴就不用重新下载了。 使用如下命令安装你下载下来的 Chrome 安装包： 1sudo dpkg -i xxx-chrome-xxx.deb 通过 PPA 源安装 Shadowsocks-qt5，仅支持 Ubuntu 14.04 或更高版本。 123sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5 之后就可以在应用列表里搜索到 Shadowsocks-qt5 了 打开图形化界面，点击 文件 -&gt; 从 gui-config.json 导入链接，接着就会像下图一样。 上图的 jp01 和 us01 都是后来配置好的，导入 gui-config.json 后还是有些需要自己配置。双击某一条连接，像我如下这样配置【默认有的配置就不要改了】： 配置完成后点击 OK，再点击界面上面的 连接，测试下延迟，看看是否能连接上。可以多配置几个，方便切换~ 接下来就是配置 Chrome，让 Chrome 可以使用代理。我们需要安装SwitchyOmega插件。请参考 Chrome 配置 SwitchyOmega快乐上网教程。有需要补充的小伙伴也可以交 ♂ 流下~ IOS 客户端没有苹果设备。。。老哥们自己研究吧！去 客户端 - Shadowsocks 可以找到相关的客户端。 注意 要是偶尔发现网络不稳定，切换线路试一下。 不要同时在多台设备上使用，也不要把配置文件分享给其他人，可能会遭到封号行为。不过手机和 PC 同时使用时没事的。 参考资料 中文文档 - Shadowsocks-qt5]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（二）:基本样式（上）]]></title>
    <url>%2F2018%2F11%2F07%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、块级元素、行内元素 块级（block-level）；行内（内联inline-level） 块级可以包含块级和行内；行内只能包含文本和行内 块级占据一整行空间；行内占据自身宽度空间， 宽高设置、内外边距的差异 1、block-level123div h1 h2 h3 h4 h5 h6 p hr（线）form ul dl ol pre tableli dd dt tr td th 2、inline-level123em strong span a br imgbutton input label select textareacode script 如图： 二、宽高-width、height只对块级元素设置生效，对行内元素设置无效 三、边框-border1、涉及边框的几个元素粗细、颜色、类型（实线、虚线、点线）border-width、border-color、border-style 1234/*简写：*/p,span&#123;border:2px blue solid;&#125; 如图：第一个：第二个：第三个：第四个：第五个： 2、如何使用边框做三角形？第一个：第二个：第三个： 四、边距1、盒模型 2、padding-内边距代表内边距，有四个方向的值，可以合写，值可以是数值、百分比（相对于父容器，不是自身） padding-top padding-right padding-bottom padding-left 3、margin-外边距代表外边距，有四个方向的值，可以合写，值可以是数值、百分比（相对于父容器，不是自身），还可以是负值 外边距合并问题在行内元素中，使用margin和padding左右生效，上下不生效，如图： 12&gt; margin-top`、`margin-right`、`margin-bottom`、`margin-left&gt; 3.1 margin:0 auto 块级元素居中12345.box&#123;/* margin: 0 auto; 实际上是下面两个起了作用 */margin-left:auto;margin-right:auto;&#125; 对于块级元素设置margin:0 auto（即：margin:0 auto 0 auto;）可以达到居中目的 4、* 去除元素默认样式的margin 和padding1234*&#123;margin:0;padding:0;&#125; 由于页面元素在浏览器会有自身的默认样式：如图:用于清除浏览器的固定样式，重新设置宽高,如图可加：注： 默认样式1em=16px 五、display1、块级和行内的display： 块级：block,list-item,table 行内：inline，inline-table，inline-block注： 一个元素在默认情况下是一个display：inline display Value: inline block list-item inline-block table inline-t able table-row table-cell none inherit Initial: inline Applies to: all elements Inherited: no 注：display：inline-block的布局，有相关资料可以了解一下：CSS之使用display:inline-block来布局 2、CSS继承和不继承继承： 每一个元素都是文档树的一部分，每个元素都有其对应的父级元素，每一个父级元素的CSS属性值都可以被应用到它的子元素中。可继承属性一般为：font-size、font-family、color 。反之，CSS不继承通常为页面的细节元素，如border、padding、margin、background-color 、width、height等 六、font font-size：字体大小如：12px（较小）、14px（正常）、16px（浏览器默认）、20px（标题大小）、22、28、60px（大标题大小） font-family：字体，有宋体、微软雅黑、Arial等 font-weight：文字粗度，常用的就是默认值regular和粗体bold line-height：行高，即文字大小，可以用百分比、倍数或者固定尺寸。 font-size*line-height: 垂直高度（行+文字占据的垂直空间）注： 以上属性为可继承给子元素 1、如何使用：12345678910body&#123;font: 12px/1.5 tahoma,arial,&apos;Hiragino Sans GB&apos;,&apos;\5b8b\4f53&apos;,sans-serif;&#125;/*或者*/p &#123;line-height: 1.5;font-size: 14px;font-family: &apos;Helvetica Neue&apos;,Helvetica,Arial,sans-serif;font-weight: bold;&#125; 2、font-family（1）字体原理 使用浏览器打开页面时，浏览器会读取HTML文件进行解析渲染。当读到文字时会转换成对应的unicode码（可以认为是世界上任意一种文字的特定编号）。再根据HTML 里设置的font-family（如果没设置则使用浏览器默认设置）去查找电脑里（如果有自定义字体@font-face，则加载对应字体文件）对应字体的字体文件。找到文件后根据unicode码去查找绘制外形，找到后绘制到页面上。 （2）了解这里有一篇老师写的关于字体方面的实现原理，以前学过一点设计看了，以后如何配合设计师进行字体需求上还是蛮受用的，可以看看：若愚：「每日一题」聊一聊字体图标的实现原理 （3）font-family写法 在 CSS 中设置字体时，直接写字体中文或英文名称浏览器都能识别，直接写中文的情况下编码（GB2312、UTF-8等）不匹配时会产生乱码。保险的方式是将字体名称用Unicode来表示 宋体 SimSun \5B8B\4F53 （Unicode码） 黑体 SimHei \9ED1\4F53 微软雅黑 Microsoft YaHei \5FAE\8F6F\96C5\9ED1 可打开控制台 escape(&#39;微软雅黑&#39;)，将 %u替换成\ 3、chrome最小字体chrome 默认字体大小16px, 最小字体 12px若需要小于12px的字体，可参考以下解决方案：islittle/Web-Developer 七、文本1、类型 text-align：文本对其方式。left、center、right、justify（≈两端对齐） text-indent：文案第一行缩进距离 text-decoration：none（去掉下划线）、underline、line-through（删除线）、overline（顶部线） color：文字颜色 text-transform：改变文字大小写。none（不改写）、uppercase（小写展示大写）、lowercase（大写展示小写）、capitalize（单词的首字母变大写展示） word-spacing：可以改变字（单词）之间的标准间隔（对于中文，每字就是一单词） letter-spacing：字母间隔修改的是字符或字母之间的间隔演示如图所示： 2、几种情况：（1）行内元素居中，如： 123456789&lt;style&gt;.box&#123;text-align: center;&#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;img src=&quot;http://7xpvnv.com2.z0.glb.qiniucdn.com/6673909a-098c-4202-8b80-f4aad64e0262.png&quot;&gt;&lt;/div&gt; （2）display：inline-block元素居中，如： 123&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;margin: 0 auto&quot; src=&quot;XXX.png&quot;&gt;&lt;/div&gt; （3）单行文本溢出，关键代码如： 12345.card &gt; h3&#123;white-space: nowrap;overflow: hidden;text-overflow: ellipsis;&#125; 如图： 八、颜色1、单词：1red`、`blue`、`pink`、`yellow`、`white`、`black 2、十六进制： #ff0000 红色 #0000ff蓝色 #008000 绿色 #000000（黑色）= #000 #ffffff（白色）= #fff #eeeeee（淡灰色）=#eee #cccccc（灰色）=#ccc #666666（深灰色）=#666 #333333（深黑色）=#333 #f00（红色） #0f0（绿色） #00f（蓝色） rgb: rgb(255,255,255)，rgb(0,255,0) rgba: rgba(0,0,0,0.5)（css3中涉及） 九、单位1、px：固定单位2、em：相对长度单位，相对于当前元素的字体大小。如图： 3、rem：相对单位，相对于根元素（html）字体大小，即1rem = html设置的font-size，移动端较常用。关于rem的好处我查了资料这个我比较理解，分享出来：css3的字体大小单位[rem]到底好在哪？ 4、vw vh：相对单位，1vw为屏幕宽度的1% 兼容性较差 5、百分比：（涉及宽高？文字大小？line-height、position）十、其他1、a链接设置颜色注： 当鼠标放置a链接，本身就会出现“手”指针的形状效果 1a 有默认颜色和样式，会覆盖继承的样式 1234a&#123;color：red；text-decoration: none;&#125; 2、列表去掉点123456789/* 设定列表样式为：无 ,即没有顺序数字、圆点出现*/ul&#123;list-style: none;&#125;/*也可这样*/li&#123;list-style: none;&#125; 如图：]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome 配置 SwitchyOmega快乐上网教程]]></title>
    <url>%2F2018%2F11%2F07%2FChrome%20%E9%85%8D%E7%BD%AE%20SwitchyOmega%E5%BF%AB%E4%B9%90%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[此文章是以 Shadowsocks 代理为例，若想使用 Shadowsocks 请先安装对应系统的客户端并启动。详情请参考我的另一篇文章shadowsocks入坑不完全指南。 Chrome 浏览器无论是用户体验、强大的功能还是丰富的扩展程序都完爆国内的各种浏览器好不好。目前已经可以在不翻墙的情况下去 下载 Chrome（桌面版）了，账号数据同步方面也不需要翻墙了。 SwitchyOmegaGoogle Chrome 浏览器上的一个代理扩展程序，可以轻松快捷地管理和切换多个代理设置。比如我们接下来要介绍的 自动切换模式。 下载安装直接打开Chrome应用商店搜索SwitchyOmega然后安装插件就可以了。 配置 Shadowsocks 情景模式 打开 Chrome， 点击右上角的 图标，再点击 选项。 点击左侧的 新建情景模式 输入情景模式名称 ss【自己任意设置名称】，类型选择第一个代理服务器。创建完成后做如下配置： 配置自动切换模式配置好 Shadowsocks 情景模式后虽然可以使用 Chrome 浏览器科学上网了，但是这样的话无论你访问什么网站都会走代理，有时候访问国内的一些网站反而会很慢，这时候自动切换模式就解决了这个问题。下面介绍一下如何配置自动切换模式。 点击左侧的 自动切换，或者自己新建情景模式，类型选择第二个 自动切换模式。然后做如下配置： 切换规则 是在访问 条件设置 的域名时候使用后面设置的 情景模式。比如图中我设置 *.google.com 和 *.twitter.com 使用 ss 情景模式【刚刚创建的那个情景模式】。我们可以点击 添加条件 来添加自己的规则。 将图中 1规则列表规则 前面的框打√，再将后面的 1情景模式 设置为 1ss ，意思是规则列表中的内容，我们使用 1ss 情景模式。然后 1规则列表设置 中： 规则列表格式： AutoProxy； 规则列表网址： https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt ps:如果需要更新直接更新就可以了 这样设置完成 规则列表规则 后就不需要在切换规则中一个一个添加条件了。 切换规则 最后一行的 默认情景模式 代表不在规则列表中网址我们使用 直接连接 情景模式，也就是说不走代理。 参考资料 Github-SwitchyOmega]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（一）:初识CSS]]></title>
    <url>%2F2018%2F11%2F06%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%88%9D%E8%AF%86CSS%2F</url>
    <content type="text"><![CDATA[前言刚接触css的时候，总觉得一个元素对应着它相应的属性，并且与对应的html文件结合，大概就能出现你想要的漂亮页面把。但在CSS身上，“事与愿违”简直就是新手对它的代名词。 在css的世界里，不管是前端老司机，还是资质尚浅的前端小白，都一定会犯“只知其一不知其二”这样的错误。因此，CSS也常被戏称为“不是科学，是艺术”。要知道，“只知其一不知其二”这种错误真的是致命的，因为你永远不知道你明明检查了几万遍的正确的元素属性，到底是哪里出错了。所以在学习CSS之前，请先看一下方方大佬的这篇文章，你就会对接下来学习CSS语法有更多的心理准备。 CSS那么难学竟然是因为它“不正交”：为什么 CSS 这么难学？ 这里先搞清楚几个基本概念：标签、元素、属性，有很多人会搞不清出哪个是指着哪个，一图释所有： 一、CSS介绍1、什么是css？CSS（英文全称：Cascading Style sheets）层叠样式表，是用来为网页添加样式的代码 2、盒模型：（1）内边距（padding）：围绕着内容的空间，比如围绕段落的空间（2）边框（border）：紧接着内边距的实体线段（3）外边距（margin）：围绕元素外部的空间（4）宽度（width）：这个涉及了IE盒模型和标准盒模型（5）高度（height） 二、应用1、简单示例：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;css&lt;/title&gt;&lt;style&gt;h1&#123;padding:10px;background-color: orange;border:1px solid black;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello css!&lt;/h1&gt;&lt;p&gt;小白学css&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2、CSS的工作原理三阶段： 浏览器输入url ——浏览器向服务器发送请求 —— 服务器将相关数据处理返返至浏览器 —— 浏览器拿到并加载页面 —— 解析html的字符串，词法分析解析成树状结构 —— create Dom tree解析html时，加载css，文件被下载——解析css文件对其分析—— attach style to Dom nodes，加入 create Dom tree两树状结构对应起 来—— 新的dom树（节点相关的元素、参数）—— 渲染、绘制页面 3、css应用方式（1）外部样式表（推荐）A、链接方式：通过&lt;link&gt;引入css，如： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;css&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello css!&lt;/h1&gt;&lt;p&gt;小白学css&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; B、导入方式：通过@import引入样式，放入css中，不要忘记分号可选择以下几种方式：如 12345@import &apos;style2.css&apos;;@import &quot;style2.css&quot;;@import url(&quot;style2.css&quot;);@import url(&apos;style2.css&apos;);@import url(style2.css); 12/*加入条件限制，如媒体查询属性 */@import url(&apos;landscape.css&apos;) screen and (orientation:landscape); （2）内部样式（内嵌方式）即将CSS放在页面的&lt;style&gt;元素中，如： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;css&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;style&gt;@import &quot;style2.css&quot;;p&#123;font-size: 50px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello css!&lt;/h1&gt;&lt;p&gt;你好&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 题外话： 注意文件路径 右键——检查——查看源代码——点击显示错误链接： 1failed to load resource：net：ERR_FILE_NOT_FOUND 即提示有可能是以下错误可能： 文件不存在 文件路径写错了 （3）内联样式（行内方式）（不推荐）即直接在html的标记中使用style属性，将css元素属性的代码直接写在其中，如： 1&lt;p style=&quot;background:orange; font-size:24pax;&quot;&gt;css很棒&lt;/p&gt; （4）属性样式（废弃）如：&lt;img src=&quot;a.png&quot; width=100 height=200&gt; 三、css选择器1、选择器类型A、基础选择器（1）*：通用元素选择器，匹配页面任何元素（比较少用）（2）#id：id选择器，匹配特定id的元素（3）.class：类选择器，匹配class包含（不是等于）特定类的元素（4）element：标签选择器 B、组合选择器（1）E,F多元选择器，相当于并列选择器。用, 分隔，同时匹配元素E或者元素F（2）E F后代选择器。用空格分隔，匹配E元素所有的后代（不只是子元素，子元素向下递归），元素F（3）E&gt;F子元素选择器。用 &gt; 分隔，匹配E元素的所有直接子元素（再嵌套的子元素就没有用）（4）E+F直接相邻选择器。匹配E元素之后的相邻的同级元素F（5）E~F普通相邻选择器（弟弟选择器），匹配E元素之后的同级元素F （无论直接相邻与否）（6）.class1.class2 （既、又）id和class选择器和选择器连写的时候中间没有分隔符，.和#本身充当分隔符的元素（7）element#idid和class选择器和选择器连写的时候中间没有分隔符，.和#本身充当分隔符的元素C、属性选择器D、伪类选择器E、伪元素选择器 2、基础选择器（1）* ：通用元素选择器，匹配页面任何元素（比较少用）（2）#id：id选择器，匹配特定id的元素（3）.class：类选择器，匹配class包含（不是等于）特定类的元素（4）element：标签选择器 演示图： 3、组合选择器（1）E,F多元选择器，相当于并列选择器。用,分隔，同时匹配元素E或者元素F（2）E F后代选择器。选择它所有的后代子元素。用空格分隔，匹配E元素所有的后代（不只是子元素，子元素向下递归），元素F（3）E&gt;F子元素选择器。（普遍）选择它第一子元素，对再嵌套的子元素没用。用&gt;分隔，匹配E元素的所有直接子元素（4）E+F直接相邻选择器。匹配E元素之后的相邻同级所有元素F（5）E~F普通相邻选择器（弟弟选择器），匹配E元素之后的同级元素F （无论直接相邻与否）（6）.class1.class2 既、又，直接靠在一起，同时拥有这两个类选择器特性的一个元素。id和class选择器和选择器连写的时候中间没有分隔符，.和#本身充当分隔符的元素（7）element#idid和class选择器和选择器连写的时候中间没有分隔符，.和 #本身充当分隔符的元素 4、属性选择器（1）E[attr]匹配所有具有属性attr的元素，如div[id] 就能取到所有有id属性的div（2）E[attr=value] 匹配属性attr值为value的元素，如div[id=test]，匹配id=test的div 5、伪类选择器（1）定义：代表一个元素的另一种状态（2）类型：A、第一类： E: first-child匹配元素E的第一个子元素 E：link 匹配所有未被点击的链接 E: visited匹配所有已被点击的链接 E：active匹配鼠标已经其上按下，还没被释放的E元素 E：hover 匹配鼠标悬停器上的E元素 E：focus匹配获得当前焦点的E元素 E：lang(c)匹配lang属性等于c的E元素 E：enabled 匹配表单中可用的元素 E：disabled 匹配表单中禁用的元素 E：checke 匹配表单中被选中的radio或checkbox元素 E：selection 匹配用户当前选中的元素 例子1：如设置E：hover时，鼠标悬停元素时字体颜色就会变成蓝色。选择器权重会使得a:hover{color:blue;}大于a{color：red;}的权重，所以样式产生了覆盖，如图： 例子2:a链接上常用的css属性选择器： E：link 匹配所有未被点击的链接 E: visited匹配所有已被点击的链接 E：hover 匹配鼠标悬停器上的E元素 E：active 匹配鼠标已经其上按下，还没被释放的E元素由于css元素按顺序填写，依次展现元素属性，这里涉及到：a这个元素下的伪类选择器权重，从而造成样式覆盖，如图演示： 例子3：(1) E：enabled 匹配表单中可用的元素(2) E：disabled 匹配表单中禁用的元素如输入框被禁用，如何设置css里的元素属性，如图： B、第二类：(1) E：root匹配文档的根元素，对于html文档，实际上就是html元素(2) E：nth-child（n） 匹配其父元素的第n个子元素，第一个编号为1注： E:nth-of-type(n)与:nth-child()作用类似，但仅匹配使用同种标签的元素如图当n=1时如图当n=？（1除外的任意数）n的取值 1231，2，3，4，52n+1，2n，4n-1odd，even： 如何运用： 做一个表格上，分别可以做两色相间的表格效果，那么就可以运用odd，even 12345/* nth-child(odd) 与 :nth-child(even) 分别匹配序号为奇数与偶数的元素 */.h-table tr:nth-child(even)&#123;background-color: #f1f1f1;&#125; 例子： 6、伪元素选择器（1）E::first-line 匹配E元素内容的第一行（2）E::first-letter 匹配E元素内容的第一个字母（3）E::before 在E元素之前插入生成的内容（4）E::after 在E元素之后插入生成的内容 举例如图： 7、选择器的优先级（1）定义如果多条规则作用于同一个元素上，且定义的相同属性的不同值。 （2）代码如下： 12345&lt;style&gt;#test&#123;color:#666;&#125;p &#123;color:#333;&#125;&lt;/style&gt;&lt;p id=&quot;text&quot;&gt;Text&lt;/p&gt; （3）CSS优先级从高到低分别是：A、在属性后面使用 ：！important 即会覆盖页面内任何位置定义的元素样式B、作为style属性写在元素标签上的内联样式C、id选择器D、类选择器E、伪类选择器F、属性选择器G、标签选择器H、通配符选择器I、浏览器自定义 （4）复杂场景(按顺序） a、行内样式&lt;div style=&quot;XXX&quot;&gt;&lt;div&gt;b、ID选择器c、类、属性选择器、伪类选择器d、标签选择器、伪元素 注： 选择器的优先级是如何计算的？ A、按顺序来计算的：假设： a等级：行内样式&lt;div style=&quot;XXX&quot;&gt;&lt;div&gt;b等级：ID选择器c等级：类、属性选择器、伪类选择器d等级：标签选择器、伪元素 即a-d等级权值依次为5、4、3、2，按照a-d等级的属性顺序依次得分，若取到相应等级的权值，最高的则为最优先级别。 B、参考：当不同类别的多个选择器混合使用个怎么计算优先级？有一个简单的算法，设 a.内联样式表的权值为1000b.ID选择器的权值为100c.class类选择器的权值为10d.HTML标签选择器的权值为1 （5）样式覆盖后面的样式会覆盖到前面的样式 （6）选择器使用经验 遵守css书写规范 使用合适的命名空间 合理地复用class- 四、习题练习1、CSS 加载方式有几种？答：（1）外部样式表（链接+导入）（推荐） 通过&lt;link&gt;引入css 通过@import导入样式，放入css中，不要忘记分号。在html或者css文件中都可以导入@import（2）内部样式（内嵌方式），即将CSS放在页面的&lt;style&gt;元素中（3）内联样式（行内方式）（不推荐），即直接在html的标记中使用style属性，将css元素属性的代码直接写在其中（4）属性样式（废弃） 2、@charset有什么作用？在外部样式表文件内使用，指定该样式表使用的字符编码。该规则后面的分号是必需的，如果省略了此分号，会生成错误信息。如在外部css文件中写： 123@charset &quot;utf-8&quot;;* &#123;sRules&#125;.class&#123;sRules&#125; 3、@import有什么作用？如何使用？答：作用：通过@import引入样式或者css文件，可以减少文件的容量，加快文件加载速度。用法： 12345@import &apos;style2.css&apos;;@import &quot;style2.css&quot;;@import url(&quot;style2.css&quot;);@import url(&apos;style2.css&apos;);@import url(style2.css); 4、id 选择器和 class 选择器的使用场景分别是什么？答：（1）id选择器，用于匹配特定id的元素，具有独一无二不可代替性（2）class选择器，用于匹配class包含（不是等于）特定类的元素，描述一组元素的样式，你可以多次使用class赋值，来命名元素名 5、CSS选择器常见的有几种？答：基础选择器、组合选择器、属性选择器、伪类选择器、伪元素选择器 6、伪类选择器有哪些？伪元素有哪些？答：（1）伪类选择器： E: first-child匹配元素E的第一个子元素 E：link 匹配所有未被点击的链接 E: visited 匹配所有已被点击的链接 E：active 匹配鼠标已经其上按下，还没被释放的E元素 E：hover 匹配鼠标悬停器上的E元素 E：focus匹配获得当前焦点的E元素 E：lang(c) 匹配lang属性等于c的E元素 E：enabled 匹配表单中可用的元素 E：disabled 匹配表单中禁用的元素 E：checked 匹配表单中被选中的radio或checkbox元素 E：selection 匹配用户当前选中的元素 E：root 匹配文档的根元素，对于html文档，实际上就是html元素 E：nth-child（n） 匹配其父元素的第n个子元素，第一个编号为1 E:nth-of-type(n)与：nth-child()作用类似，但仅匹配使用同种标签的元素 （2）伪元素： E::first-line 匹配E元素内容的第一行 E::first-letter 匹配E元素内容的第一个字母 E::before 在E元素之前插入生成的内容 E::after 在E元素之后插入生成的内容 7、以下选择器分别是什么意思?（1） 12#header&#123;&#125; 答：id选择器，匹配id为header的元素 （2） 12.header&#123;&#125; 答：类选择器，匹配class为header元素 （3） 12.header .logo&#123;&#125; 答：后代选择器，匹配class为header的元素logo （4） 12.header.mobile&#123;&#125; 答：即又关系的并列元素，同时匹配这两个类选择器特性的一个元素 （5） 12.header p, .header h3&#123;&#125; 答：多元选择器，同时匹配.header p 和 .header h3两个元素 （6） 12#header a:hover&#123;&#125; 答：在id为header元素下匹配a元素鼠标悬停属性 （7） 12#header .logo~p&#123;&#125; 答：在id为header元素下匹配logo元素之后的同级所有元素p （无论直接相邻与否） （8） 12#header .logo+p&#123;&#125; 答：在class为header元素下匹配logo元素之后的相邻同级元素p （9） 12#header .logo p&#123;&#125; 答：在id为header元素下匹配class为logo的后代元素p （10） 12#header .logo&gt;p&#123;&#125; 答：在id为header元素下匹配class为logo元素的所有直接子元素，即第一子元素p （11） 12#header p.logo&#123;&#125; 答：在id为header元素下同时匹配p元素和class为logo元素这类既又关系（并列）的元素的特性 （12） 12#header .logo.p&#123;&#125; 答：在id为header元素下同时匹配class为logo和p的元素 （13） 12#header input[checked]&#123;&#125; 答：在id为header元素下匹配checked值的input的元素 8、运行如下代码，并对结果做出解释 123456789101112131415161718192021222324&lt;style&gt;.box:first-child &#123;color: red;&#125;.box:first-of-type &#123;background: blue;&#125;.box :first-child &#123;font-size: 30px;&#125;.box :first-of-type &#123;font-weight: bold;&#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt;&lt;div class=&quot;box&quot;&gt;div.box&lt;/div&gt;&lt;p class=&quot;box&quot;&gt;p.box&lt;/p&gt;&lt;div class=&quot;box&quot;&gt;div.box&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;item&quot;&gt;div.item&lt;/div&gt;&lt;p class=&quot;item&quot;&gt;p.item&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;box&quot;&gt;&lt;/p&gt;&lt;/div&gt; （1）效果图展示：（2）对其结果作出解释：运行1： 123.box:first-child &#123;color: red;&#125; 选择同级第一个元素,并且这个元素class是 box,显示该标签元素的内容颜色为红色 运行2： 123.box:first-of-type &#123;background: blue;&#125; 选择同级第一个标签元素,并且这个元素是这个同级中的第一个标签，显示背景色为蓝色 运行3：（.box : :.box和:之间要有空格） 123.box :first-child &#123;font-size: 30px;&#125; 表示.box 里面（父元素）的第一个元素，显示字体大小为30px的结果 运行4： 123.box :first-of-type &#123;font-weight: bold;&#125; 选择 .box里（父元素）第一个同类型的元素，字体粗细为粗体 五、在线小游戏​ CSS Diner一个可以练习CSS选择器的小游戏。123456789101112131415161718192021222324252627282930313233参考答案（不唯一）01. plate02. bento 03. #fancy 04. plate apple 05. #fancy pickle 06. apple.small 07. orange.small 08. bento orange.small 09. plate , bento 10. * 11. plate * 12. plate + apple 13. bento ~ pickle 14. plate &gt; apple 15. plate orange:first-child 16. plate *:only-child 17. #fancy *:last-child , plate + pickle 18. plate:nth-child(3) 19. bento:nth-last-child(3) 20. apple:first-of-type 21. plate:nth-of-type(2n) 22. plate:nth-of-type(2n+3) 23. plate apple.small:only-of-type 24. orange:last-of-type , apple:last-of-type 25. bento:empty 26. apple:not(.small) 27.［for]28.plate[for]29.[for=&quot;Vitaly&quot;]30.[for^=&quot;Sam&quot;],[for^=&quot;Sarah&quot;]31.[for$=&quot;Hayato&quot;],[for$=&quot;Minato&quot;]32.[for*=&quot;Robbie&quot;],[for*=&quot;Bobby&quot;]]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS入门]]></title>
    <url>%2F2018%2F11%2F05%2FCSS%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1.CSS的全称是什么?CSS 指层叠样式表（Cascading Style Sheets）。通过CSS和HTML的结合可以实现表现与结构分离。从而提升工作效率，降低维护难度。 2.CSS有几种引入方式? link 和@import 有什么区别?css有四种引入方式： 1.内联方式 内联方式指的是直接在 HTML 标签中的 style 属性中添加 CSS。 这通常是个很糟糕的书写方式，它只能改变当前标签的样式，如果想要多个 拥有相同的样式，你不得不重复地为每个 添加相同的样式，如果想要修改一种样式，又不得不修改所有的 style 中的代码。很显然，内联方式引入 CSS 代码会导致 HTML 代码变得冗长，且使得网页难以维护。 2.嵌入方式 嵌入方式指的是在 HTML 头部中的 标签下书写 CSS 代码。 .content { background: red; } 嵌入方式的 CSS 只对当前的网页有效。因为 CSS 代码是在 HTML 文件中，所以会使得代码比较集中，当我们写模板网页时这通常比较有利。因为查看模板代码的人可以一目了然地查看 HTML 结构和 CSS 样式。因为嵌入的 CSS 只对当前页面有效，所以当多个页面需要引入相同的 CSS 代码时，这样写会导致代码冗余，也不利于维护。 3.链接方式 链接方式指的是使用 HTML 头部的 标签引入外部的 CSS 文件。 这是最常见的也是最推荐的引入 CSS 的方式。使用这种方式，所有的 CSS 代码只存在于单独的 CSS 文件中，所以具有良好的可维护性。并且所有的 CSS 代码只存在于 CSS 文件中，CSS 文件会在第一次加载时引入，以后切换页面时只需加载 HTML 文件即可。 4.导入方式 导入方式指的是使用 CSS 规则引入外部 CSS 文件。 @import url(style.css); link和@import两者都是外部引用CSS的方式，但是存在一定的区别： 区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。 区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载 区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 区别4：ink支持使用Javascript控制DOM去改变样式；而@import不支持。 3.以下这几种文件路径分别用在什么地方，代表什么意思? 4.如果我想在js.jirengu.com上展示一个图片，需要怎么操作?可以直接将图片上传到服务器，在页面使用这张图片；或者将图片存在本地服务器，然后打开本地服务，然后在网站上上引用图片 如果这个图片本来就存在网络上其他的服务器上，可以直接使用图片的网络路径链接的方式在页面上添加url引用这张图片，说白了就是把图片的引用地址改成网络路径就行了。 5.列出5条以上html和 css 的书写规范1.统一使用小写 2.不使用内联的style属性定义样式 3.id和class语义化，分隔符建议使用- 4.有可能就用缩写 5.属性值是0，省略单位，比如不要写成0px，直接是0 6.块内容缩进 7.禁止 img的 src取值为空。延迟加载的图片也要增加默认的 src 6.介绍 Chrome 开发者工具的功能区 1是元素区，在这可以看到整个网页的结构 2和12 都是控制台，录开发者开发过程中的日志信息，且可以作为与JS进行交互的命令行Shell 3 是资源，这里可以看到各种你引入的js，主要就是用于调试js 4 从发起网页页面请求Request后分析HTTP请求后得到的各个请求资源信息（包括状态、资源类型、大小、所用时间等），可以根据这个进行网络性能优化 5.时间线记录并分析在网站的生命周期内所发生的各类事件，以此可以提高网页的运行时间的性能。 6.记录JS CPU执行时间细节、显示JS对象和相关的DOM节点的内存消耗、记录内存的分配细节。 7.记录网站加载的所有资源信息，包括存储数据（Local Storage、Session Storage、IndexedDB、Web SQL、Cookies）、缓存数据、字体、图片、脚本、样式表 8.安全：判断当前网页是否安全 9.对当前网页进行网络利用情况、网页性能方面的诊断，并给出一些优化建议。比如列出所有没有用到的CSS文件等 10.样式区域，可以直观的看到css 11.适配区域，可以适配各种屏幕大小，一般用于调试页面自适应。]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈HTML（三）：表单元素]]></title>
    <url>%2F2018%2F11%2F04%2F%E6%B5%85%E8%B0%88HTML%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[一、实践1、贴上完整的代码图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/a123&quot; method=&quot;get&quot;&gt;&lt;div class=&quot;username&quot;&gt;&lt;label for=&quot;username&quot;&gt;姓名&lt;/label&gt;&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username1&quot; placeholder=&quot;用户名&quot;&gt;&lt;/div&gt;&lt;div class=&quot;password&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;input id=&quot;password&quot; type=&quot;password&quot; name=&quot;password1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;sex&quot;&gt;&lt;label for=&quot;sex&quot;&gt;性别&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女&lt;/div&gt;&lt;div class=&quot;hobby&quot;&gt;&lt;label&gt;爱好&lt;/label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;wangzhe&quot;&gt;王者荣耀&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;travl&quot;&gt;旅游&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;pet&quot;&gt;宠物&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;music&quot;&gt;音乐&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;running&quot;&gt;跑步&lt;/div&gt;&lt;div class=&quot;textarea&quot;&gt;&lt;label for=&quot;textarea&quot;&gt;评论&lt;/label&gt;&lt;textarea name=&quot;article&quot;&gt;哈哈哈哈&lt;/textarea&gt;&lt;input type=&quot;hidden&quot; name=&quot;abcd&quot; value=&quot;12345&quot;&gt;&lt;/div&gt;&lt;div class=&quot;file&quot;&gt;&lt;input type=&quot;file&quot; name=&quot;myfile&quot; accept=&quot;image/png&quot;&gt;&lt;/div&gt;&lt;div class=&quot;choose&quot;&gt;&lt;label for=&quot;pet&quot;&gt;我的宠物&lt;/label&gt;&lt;select name=&quot;city&quot;&gt;&lt;option value=&quot;cat&quot;&gt;猫&lt;/option&gt;&lt;option value=&quot;dog&quot; selected&gt;狗&lt;/option&gt;&lt;option value=&quot;fish&quot;&gt;鱼&lt;/option&gt;&lt;/select&gt;&lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、效果图： 二、具体标签：1、form代码结构如： 1&lt;form action=&quot;/a123&quot; method=&quot;get&quot;&gt; form标签是表单的外壳，有4个主要属性： （1）action：表单提交的地址 （2）method：提交表单的方法 （3）target：在何处打开action （4）enctype： application／x-www-form-urlencoded：在发送前编码所有字符（默认） text／plain：空格转换为“+”加号，但不对特殊字符编码 multipart／form-data：使用包含文件上传控件的表单是，必须使用该值 2、type代码结构如： 1&lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt; （1）type=&quot;text&quot;普通的文本输入框，单行输入（不行回车换行）。可输入文字展示 （2）type=&quot;password&quot;输入密码是以圆点展示，不被人知道 （3）type=&quot;checkbox&quot; 呈现带有阴影的勾选方框代码如下： 123456&lt;div class=&quot;hobby&quot;&gt;&lt;label for=&quot;hobby&quot;&gt;爱好&lt;/label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;read&quot;&gt;读书&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;music&quot;&gt;听歌&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;swim&quot;&gt;游泳&lt;/div&gt; 如图： 注： A、如果是分组，name写成不同，表示多选，如针对hobby这个关键字的搜索，value值需要设置，否则后台提交的用户信息将显示为on（无信息展示）。 B、value的作用：让后台来识别该字段的信息 （4）type=&quot;radio&quot; 呈现带有阴影的点选圆框代码结构如下： 12345&lt;div class=&quot;hobby&quot;&gt;&lt;label for=&quot;sex&quot;&gt;性别&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女&lt;/div&gt; 图： 注：radio 如何分组？举例说明，只需要在&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;中的name值设置另一个意义值，就可以分组显示，如： 第1组： 12&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女 第2组： 12&lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;女&quot;&gt;女 即： 1234567&lt;div class=&quot;hobby&quot;&gt;&lt;label for=&quot;sex&quot;&gt;性别&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;女&quot;&gt;女&lt;/div&gt; 如图： （5）type=&quot;file&quot; 用于文件上传，呈现“选择文件”按钮，点击即可上传文件 1&lt;input type=&quot;file&quot; name=&quot;myfile&quot; accept=&quot;image/png，image/jp&gt; 注： accept该参数使用，即用于接收所限制的文件格式 （6）type=&quot;hidden&quot;作用： 暂存信息。 如在type=&quot;hidden&quot;埋下一个值，后台定位获取相应的值，可安全存值，用户什么都看不见，只能在后台看到； 保障安全。 当打开一个页面，实际上该页面是后端写的模板并在里面填充数据，填充好数据后，安全策略时使用 1type=&quot;hidden&quot; ，即： 1&lt;input type=&quot;hidden&quot; name=&quot;abc&quot; value=&quot;123456&quot;&gt; 当用户提交用户信息至后台，同时该安全点type=&quot;hidden&quot;的值也会提交后台，后台进行校验——确认过安全，相当于埋在后台与用户信息相匹配的一个安全校验值，即该用户为一个合法用户。 （7）type=&quot;button&quot;，不能点击提交 （8）type=&quot;submit&quot;，可以点击提交 （9）type=&quot;reset&quot;，用于清空所有用户信息 注： A、以下input有何作用？ 1&lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;提交按钮&quot;&gt; B、type=&quot;submit&quot; ， 提示input作用为“提交”按钮 C、value=&quot;提交&quot;， 显示提交作用，意义在于“点击提交”的交互作用 D、input里name 作用？ 即用于传递数据给后台都形成有意义的识别值，如用value和name赋值，如果不写的话，该输入标签将不会有任何意义，就等于无实际操作表单的意义。 3、type=hidden隐藏域作用type=hidden隐藏域，作为校验该用户信息的一个隐藏值（判断标准）。当用户打开页面后是看不见type=hidden相应的值，填写用户信息之后点击提交时，用户信息的数据（包括type=hidden值）随即提交后台，打开后台则会展示代码type=hidden所写的相应元素属性值。后台校验type=hidden相应值如果是正确，即用户提交为安全。 埋点（保护的参数）——浏览器提交后台有该参数作为校验标准参考——若显示错值或无值，服务器也将不承认所提交的数据；若为正确值，则说明该用户获取权限，即为合法用户，可防止CSRF攻击 4、label输入框前的文字标注代码如下： 1234&lt;div class=&quot;username&quot;&gt;&lt;label for=&quot;username&quot;&gt;姓名&lt;/label&gt;&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username1&quot;&gt;&lt;/div&gt; 注：for，用于点击文字或输入框时，是文字显示一种focus状态，可直接输入对应信息 5、select下拉菜单代码结构如下： 12345678&lt;div class=&quot;choose&quot;&gt;&lt;select name=&quot;city&quot;&gt;&lt;label for=&quot;pet&quot;&gt;我的宠物&lt;/label&gt;&lt;option value=&quot;cat&quot;&gt;猫&lt;/option&gt;&lt;option value=&quot;dog&quot;&gt;狗&lt;/option&gt;&lt;option value=&quot;fish&quot;&gt;鱼&lt;/option&gt;&lt;/select&gt;&lt;/div&gt; option中，设置默认选择的初始值，即 &lt;option value=&quot;cat&quot; selected&gt;猫&lt;/option&gt; 6、extarea实现多行文本，展示较大的输入框。即常见的评论框。代码结构如下： 123456&lt;div class=&quot;textarea&quot;&gt;&lt;label for=&quot;textarea&quot;&gt;评论&lt;/label&gt;&lt;textarea name=&quot;article&quot;&gt;123&lt;/textarea&gt;&lt;/div&gt; 注：若在&lt;textarea&gt;...&lt;/textarea&gt;中输入任意值，即相当于value赋值的意义，也就是说在&lt;textarea&gt;...&lt;/textarea&gt;输入的值都能显示其输出的意义。 7、placeholder用于输入什么用户信息的提示代码结构如下： 1234&lt;div class=&quot;username&quot;&gt;&lt;label for=&quot;username&quot;&gt;姓名&lt;/label&gt;&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username1&quot; placeholder=&quot;用户名&quot;&gt;&lt;/div&gt; 图：]]></content>
      <categories>
        <category>前端</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈HTML（二）：表单提交原理]]></title>
    <url>%2F2018%2F11%2F03%2F%E6%B5%85%E8%B0%88HTML%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、html表单1、什么是表单能够去输入用户信息的一个单子。和我们平时填写的纸质表单一样，在HTML页面上，也有表单是用于搜集不同类型的用户信息输入。 2、作用用于收集已收集的信息，提交你网站的后台（或者服务器）。HTML表单是一个包含表单元素的区域，表单元素是允许用户在表单中（表单元素包含如：文本域、下拉列表、单选框、复选框等）输入信息的元素。 二、写表单1、表单提交原理一般表单有登录名、密码，form、input，表单所有信息用form元素包裹。用包裹所有input元素输入框，当点击提交后，将会把form所包裹得所有input输入框的信息提交给后台的一个地址上。 2、写表单（1）表单内的主要标签属性：A、&lt;form&gt;...&lt;/form&gt;B、&lt;form action=&quot;/a123&quot; method=&quot;get&quot;&gt; action : 把数据提交到后台的地址，如action=&quot;/a123&quot;，即提交到当前域名下的/a123 method：提交数据的方式 （2）demo： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;login&quot;&gt;&lt;form action=&quot;/a123&quot; method=&quot;get&quot;&gt;&lt;div class=&quot;sex&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;sex1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;username&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;password&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;submit&quot;&gt;&lt;button&gt;提交&lt;/button&gt;&lt;/div&gt;&lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; （3）html文件用浏览器打开页面当写出登录名、密码、提交代码后（之后加上性别），以get形式点击提交，页面url显示input输入的相应的内容： 注：点击提交代表向服务器发送了一个请求，这个文件是通过get方式进行表单收集 假如，将以下代码放置在&lt;form&gt;&lt;/form&gt;标签之外， 12345678&lt;div&gt;&lt;div class=&quot;sex&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;sex1&quot;&gt;&lt;/div&gt;&lt;form&gt;.....&lt;/form&gt;&lt;/div&gt; 以get形式提交的页面url也不会显示相应的内容： 3、终端上操作即本地终端开启服务器，以服务端的方式打开页面（1）命令行开启静态服务器，并打开页面：因为之前我已经安装nodejs，用npm安装了http-server这个服务器，所以可以执行以下代码直接打开这个静态服务器： 1$ http-server 代码执行之后，输入相应的url出现的页面，两步骤之后的示意图：注：以下情况给没有安装nodejs 的人看的（安装了就可以不看） 假如有人之前没安装nodejs，就不能用npm命令去开启一个静态服务器，所以可以先看看我这篇：浅谈命令行（二）：安装静态服务器（涉及nodejs和npm的使用）​看完之后可以下载nodejs，在终端执行以下代码：​​$ sudo npm install -g http-server$ http-server这样之后就开启了一个静态服务器，就可以用里面的url打开相应的html文件​（2）输入相应信息之后，出现：​（3）页面右键——检查，重新输入表单信息，点击提交出现页面相对应的html文件——demo.html的请求，先贴上我操作后出现的页面：​ 请求的地址：http://127.0.0.1:8080/a123?username1=neil&amp;password1=123456 请求的类型：Request Method: GET 请求的参数：username1: neilpassword1: 123456​（4）两种请求类型：get和postA、get请求即当demo.html中method=&quot;get&quot;时，页面上点击“提交”时，就会将demo.html展现的信息进行组装，以view的形式去组合成这个url地址：http://127.0.0.1:8080/a123?username1=neil&amp;password1=123456，向这个地址发送请求。​get请求，本质上就是url的拼接，把你的参数拼接在一起组成一个新的url:标签中的name属性​B、post请求关于post类型发送请求：由于我的服务器http-server，是个静态文件服务器，不支持post请求。可以看老司机的演示： post的请求类型得到的url地址更干净，更安全。​​ 三、post和get的区别1、method提供两种提交方式：一种是get方式向后台发送请求，提交数据；另一种是post方式向后台发送请求，提交数据 2、区别（1）从安全性上，二者表象不同，get把提交的数据url可以看到，会展现在浏览器历史记录中，安全性不好；但是post看不到，安全性好。​（2）从提交数据量上，get最多提交1k数据，浏览器上的url地址框有字符长度限制；post理论上无限制，受服务器限制。​（3）从原理上，get 是拼接 url，post是放入http 请求体中。 3、应用场景（怎么合理两种方式传递数据？）注： 在实际应用上，get 重在 “得到”, post 重在”传递”​​即假如向后台查询一篇论文，请求数据，请求为“得到”，用get方式请求数据；向后台“传递”数据，写了文章之后传递至后台，通常是“传递完成”的状态进行提示，用post方式请求数据。​​ 四、表单元素普通用户点上面一个，能FQ的点第二个，轻戳：HTML 表单元素HTML 表单指南]]></content>
      <categories>
        <category>前端</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈HTML（一）：部分标签]]></title>
    <url>%2F2018%2F11%2F03%2F%E6%B5%85%E8%B0%88HTML%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%83%A8%E5%88%86%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[本文主要讲述以下内容： &lt;iframe&gt; &lt;a&gt;及伪协议 &lt;form&gt; &lt;input&gt; &lt;table&gt; 及 &lt;colgroup&gt; 可替换元素 空元素 其他 一.iframe iframe 标签 用于嵌套页面,新开一个窗口（沙箱隔离，引用第三方内容）1src指定：&lt;iframe src=&quot;[https://www.baidu.com](http://link.zhihu.com/?target=https%3A//www.baidu.com/)&quot; name=&quot;xxx&quot;&gt;&lt;/iframe&gt; 链接打开： QQ baidu iframe可用于所见即所得的网页编辑器。 二. a (anchor) , 伪协议 &lt;a&gt;用于http get 请求 属性download 下载链接指定文件 查看使用&lt;a&gt;来创建可点击图片，如何创建email链接，电话链接 &lt;a&gt;的示范: &lt;a href=&quot;qq.com&quot;&gt;qq&lt;/a&gt;错误示范，表示qq.com文件 &lt;a href=&quot;//qq.com&quot;&gt;qq&lt;/a&gt; 浏览器会根据当前协议，补全无协议链接的协议 如果用 file:// 协议浏览页面，就会访问到 file://http://qq.com，这是一个不存在的路径 应该尽量不使用 file:// 协议预览网页，以免无协议链接出错 link 浏览器发起 GET /?name=li HTTP/1.1 请求 anchor 页面内跳转， &lt;a href=”javascript:alert(“a”) &gt; 伪协议, 阻止页面跳转 伪协议： 可以在用户点击 a 时执行一段 javascript 代码 在地址栏输入 javascript:alert(1) 可以在当前页面执行一段代码 伪协议可以实现「点击之后没有任何动作的 a 标签」，满足一些奇葩需求 滚回顶部 刷新页面 link 浏览器发起 GET / HTTP/1.1 的请求 target属性 _self : 当前页面加载，即当前的响应到同一HTML 4 frame _blank : 新窗口打开，即到一个新的未命名的HTML4窗口或HTML5浏览器上下文 _parent : 加载响应到当前框架的HTML4父框架或当前的HTML5浏览上下文的父浏览上下文。如果没有parent框架或者浏览上下文，此选项的行为方式相同_self。 _top : HTML4中：加载的响应成完整的，原来的窗口，取消所有其它frame。 HTML5中：加载响应进入顶层浏览上下文（即，浏览上下文，它是当前的一个的祖先，并且没有parent）。如果没有parent框架或者浏览上下文，此选项的行为方式相同_self 三. form 必须有提交按钮，一般作为post请求 get 默认会把参数放在查询参数里面 post默认会把参数放在请求header的第四部分里面 form 具有target属性： 如果一个里面只有一个btn ,他会自动升级为提交按钮只有一个或者 依然只是普通按钮只有一个可以提交，是唯一能确定form是否可以提交 四.input如果 input 不加 name，那么在表单提交时，input 的值就不会出现在请求里,checkbox, radio 的 name表示一组。 &lt;label&gt;把input包起来，可以关联，input 属性： require表示该表单必填 ，：输入（表单输入）元素 type部分类型：12345678- submit / reset- range- search- data / datatime /datetime-local- image- file- email- hidden 五.&lt;table&gt; 及&lt;colgroup&gt;123&lt;table&gt;： thead tbody tfoot caption tr td/th&lt;colgroup&gt; : 定义表格内的一组列。 示例: 1234567&lt;table border=1&gt;&lt;colgroup&gt;&lt;col width=100&gt;控制列宽&lt;col width=100&gt;...... 六.可替换元素CSS 里，可替换元素（replaced element）的展现不是由CSS来控制的。这些元素是一类 外观渲染独立于CSS的 外部对象。 典型的可替换元素有&lt;img&gt;、 &lt;object&gt;、 &lt;video&gt; 和 表单元素，如&lt;textarea&gt;、 &lt;input&gt; 。 某些元素只在一些特殊情况下表现为可替换元素，例如 &lt;audio&gt;和 &lt;canvas&gt;。 通过 CSS content 属性来插入的对象 被称作 匿名可替换元素（anonymous replaced elements）。 七.空元素空元素就是不用加闭合标签的标签，也可以叫闭元素。如：1234567891011121314151617&lt;area&gt;&lt;base&gt;&lt;br&gt;&lt;col&gt;&lt;colgroup&gt;&lt;command&gt;&lt;embed&gt;&lt;hr&gt;&lt;img&gt;&lt;input&gt;&lt;keygen&gt;&lt;link&gt;&lt;meta&gt;&lt;param&gt;&lt;source&gt;&lt;track&gt;&lt;wbr&gt; 八.其他123456789101112131415&lt;select&gt; 下拉列表，指定name！ multiple 多选&lt;textarea&gt; resize：none 禁止拖动&lt;aside&gt; 跟文章不相关的内容,旁边经常作为侧边栏或标注框出现全局属性contenteditable 内容可编辑除了div 和 span 其他标签都有默认样式&lt;b&gt; 与 &lt;strong&gt;的区别：&lt;strong&gt;元素表示更重要的内容，而&lt;b&gt;元素用于提醒，dl &gt; dt +dd&lt;meta charset=&quot;utf-8&quot;&gt; 等价于 &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; :http-equiv:http 的等价物]]></content>
      <categories>
        <category>前端</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈命令行（三）：好玩的命令行操作]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%A5%BD%E7%8E%A9%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%EF%BC%88%E6%9C%89%E5%A5%BD%E7%8E%A9%E5%86%8D%E8%A1%A5%E5%85%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[置顶资料：用来练习命令行，一天一个命令行：一天一个命令行 一、可以开启一个翻译工具第一步：打开终端或者 gitbash，输入： 1$ npm install -g fanyi 或有些人的电脑有管理员权限的，需要前面加上sudo 1$ sudo npm install -g fanyi 这里还需要输入你的开机密码 第二步：然后在终端下输入 1$ fanyi 你好 即可进行及时翻译附上我电脑的终端命令行操作图：]]></content>
      <categories>
        <category>基础知识</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈命令行（二）：安装静态服务器（涉及nodejs和npm的使用）]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E6%B6%89%E5%8F%8Anodejs%E5%92%8Cnpm%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[掌握了终端的一些基本命令，可以做点什么呢？用命令行，可以安装一个静态服务器哦~关键词： Nodejs、npm、全局安装、http-server 一、安装Nodejs1、什么是NodejsNode.js 是一个让 JavaScript 运行在服务端的开发平台。（不懂就算了，不用太在意，反正应该是帮助js更友好地去开发的一个开发平台。。。啊吧） 2、下载链接： nodejs注： nodejs下载完后，你将不会看到它像其他软件那样出现在桌面，需要用命令行去调用它。 3、验证是否安装成功此时，可以开启终端，用命令行验证： 1$ node --version 如图： 二、使用npm安装一个静态服务器1$ npm install -g http-server 1、npm是什么npm是一个node包管理和分发工具，已经成为了非官方的发布node模块（包）的标准。有了npm，可以很快的找到特定服务要使用的包，进行下载、安装以及管理已经安装的包。新版的nodejs已经集成了npm，所以之前npm也一并安装好了。 2、npm的作用npm是随同Nodejs一起安装的包管理工具，能解决Nodejs代码部署上的很多问题。 3、再次打开终端操作以下步骤：（1）开启npm 1$ npm （2）用npm安装http-sever 1$ npm install -g http-server 结论： http-server被安装成功，可以开启一个静态服务器注： 1-g 为全局安装模式，去掉-g之后就是本地模式，如果出错就可以试一下本地模式 题外话： 关于本地模式和全局模式的问题，这里就不展开讲了，比较菜不耽误别人。需要的可以看一下这两篇文章： nodejs本地模式和全局模式 node.js 本地模式与全局模式的区别 划重点： 有些人的电脑如果提示错误（我的就是这样?），不要抓狂，试一下是否需要管理员权限： 1$ sudo npm install -g http-server windows不需要管这个 （3）开启http-server（这个是一个服务器哦） 1$ http-server （4）尝试启动http-server在浏览器打开你的本地文件在命令行假设在桌面（desktop）操作一个名为code文件夹中的from.html文件 123$ ls$ cd code$ http-server 此时，将会出现服务器的url，复制下来在浏览器中打开，在code目录下启动这个静态服务器，用新的url来展示code文件夹下所相对应的html文件夹。结论：这种方式，就不是我们用本地的方式打开html文件 （5）退出http-server在终端上Ctrl+c，便会退出http-server]]></content>
      <categories>
        <category>基础知识</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈命令行（一）：命令行基本操作（包括vim在终端的基本操作）]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E5%8C%85%E6%8B%ACvim%E5%9C%A8%E7%BB%88%E7%AB%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、命令行1、了解一些关键名词： 图形界面 命令行：在终端窗口下输入一些命令就可以满足一些操作需求 终端：mac下打开终端（terminal），win下打开gitbash shell：执行当前脚本的一个载体，统称shell。如输入命令ls，即展示当前文件下的所有文件（ls本质上是字符串），通过shell底层地接受字符串的操作输入，在底层做一些文件检索，最终展示出ls发出的请求的文件 bash：本质上是一个软件。 2、安装使用 win安装git，打开gitbash linux：打开终端 mac：打开终端、iterm 二、基本命令1、查看当前完整的路径：pwd1~ $ pwd 结论： 就是看看此时我在哪个文件夹下 2、查看当前目录下文件：ls 不包括隐藏文件 1$ ls 查看当前目录下所有文件（包括隐藏文件） 1$ ls -a 查看当前目录下所有文件（包括隐藏文件）的详细信息 1$ ls -al 注：书籍推荐《鸟叔的linux教程》 3、切换目录：cd1$ cd 文件夹名 如： 1234$ cd /c/project$ cd code$ cd ../css$ cd ~/desktop 两点和一点的区别： 返回上一级文件夹: ..（即返回 ~ 家目录） 1$ cd .. 当前文件夹: . （即desktop这个文件夹） 1$ cd ./code 结论： 即切换到当前目录下的code文件夹 1$ cd code 4、文件路径（1）根路径：/ （即整个系统最根本的路径） 1$ cd code 根目录&gt;家目录如错误示范： 1$ cd /code 注： 如果要操作根路径里的其他文件夹，需要管理员权限 根路径不是C盘，根路径就是根路径 （2）家目录：~ 1~ 家目录，即当前的用户下的路径 ：如 1/Users /wxq393 如果是: 1~ /desktop $ 即是 1/Users/wxq393/desktop $ （3）当前目录：. 12$ cd code$ cd ./code （4）上级目录：.. 12$ cd ..$ cd ../code 5、创建文件 : touch1$ touch readme.md 6、删除文件 : rm1$ rm readme.md 强制删除文件夹，不提示 1$ rm -rf helloworld 或者 1$ rm -r helloworld 7、重命名文件 : mv1$ mv readme.md README.md 8、创建文件夹 : mkdir1$ mkdir projects 三、终端中的编辑器vim的使用终端命令行中先创建 1$ touch a.html 第一步： 1$ vim a.html 初始进入编辑器命令模式 第二步：键盘上：i进入编辑模式INSERT 第三步：键盘左上角：escINSERT消失，进入命令模式 第四步： 1：wq 保存退出 或者 1：!q 不保存强制退出 第五步： 1$ cat a.html 查看文件结果]]></content>
      <categories>
        <category>基础知识</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github博客教程：03添加分类，标签]]></title>
    <url>%2F2018%2F11%2F01%2FHexo-Github%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%9A03%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%EF%BC%8C%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[1、创建“分类”选项1.1 生成“分类”页并添加tpye属性打开命令行，进入博客所在文件夹。执行命令 1$ hexo new page categories 成功后会提示： 1INFO Created: ~/Documents/blog/source/categories/index.md 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的： 1234---title: 文章分类date: 2018-10-31 13:47:40--- 添加type: &quot;categories&quot;到内容中，添加后是这样的： 12345---title: 文章分类date: 2018-10-31 13:47:40type: &quot;categories&quot;--- 保存并关闭文件。 1.2 给文章添加“categories”属性打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。 123456---title: Hexo博客+Github博客教程：03添加分类，标签date: 2018-11-01 14:17:46categories: - hexo--- 至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。 2、创建“标签”选项2.1 生成“标签”页并添加tpye属性打开命令行，进入博客所在文件夹。执行命令 1$ hexo new page tags 成功后会提示： 1INFO Created: ~/Documents/blog/source/tags/index.md 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的： 1234---title: 标签date: 2018-10-31 13:47:40--- 添加type: &quot;tags&quot;到内容中，添加后是这样的： 12345---title: 文章分类date: 2018-10-31 13:47:40type: &quot;tags&quot;--- 保存并关闭文件。 2.2 给文章添加“tags”属性打开需要添加标签的文章，为其添加tags属性。下方的tags:下方的- jQuery - 表格- 表单验证就是这篇文章的标签了 1234567891011---title: Hexo博客+Github博客教程：03添加分类，标签date: 2018-11-01 14:17:46categories: - 基础知识- hexotags:- hexo- github- 博客--- 至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了tags: xxx的文章才会被收录到首页的“标签”中。 细心的朋友可能已经发现，这两个的设置几乎一模一样！是的，没错，思路都是一样的。所以我们可以打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，之后执行hexo new 文章名命令生成的文件，页面里就有categories:项了。 scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。 教程结束，赶紧去设置吧！]]></content>
      <categories>
        <category>基础知识</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github博客教程：02主题优化]]></title>
    <url>%2F2018%2F11%2F01%2FHexo-Github%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%9A02%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[这一篇教程将主要介绍个性化博客的配置，并将不定期更新。 在你存放的Hexo文件夹中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。 添加分类模块1、新建一个分类页面 1$ hexo new page categories 2、你会发现你的source文件夹下有了categorcies/index.md，打开index.md文件将title设置为title: 分类 3、打开 主题配置文件 找到menu，将categorcies取消注释 4、把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中 举个栗子： 12title: 分类测试文章标题categories: 分类名 添加多个分类如果你想要把一篇文章设置为两个分类，一个为主分类，第二个为子分类，并且文章在子分类，可以这样写： 1categories: [一级分类名,二级分类名] 也可以这样写： 123categories:- 一级分类名- 二级分类名 这样这篇文章的主分类为“一级分类名”，子分类为“二级分类名”，并且文章显示在“二级分类名下”类别下。 添加标签模块1、新建一个标签页面 1$ hexo new page tags 2、你会发现你的source文件夹下有了tags/index.md，打开index.md文件将title设置为title: 标签 3、打开 主题配置文件 找到menu，将tags取消注释 4、把文章添加标签只需在文章的顶部标题下方添加tags字段，即可自动创建标签名并归入对应的标签中 举个栗子： 12345title: 标签测试文章标题tags: - 标签1 - 标签2 ... 添加关于模块1、新建一个关于页面 1$ hexo new page about 2、你会发现你的source文件夹下有了about/index.md，打开index.md文件即可编辑关于你的信息，可以随便编辑。3、打开 主题配置文件 找到menu，将about取消注释 插入摘要有时文章比较长，或者想首页更简洁一些，希望在首页只显示摘要而不是全文。Hexo是支持摘要的功能的，只要在文章中插入代码： 1&lt;!--more--&gt; 这样在其上的文字即为摘要，在首页中就会出现“阅读更多”的图标，点击则显示全文。 插入图片使用markdown写文章，插入图片的格式为 1![图片名称](链接地址) 对于hexo，链接地址的写法包括以下几种： 使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。 使用微博图床，地址http://weibotuchuang.sinaapp.com/，将图片拖入区域中，会生成图片的URL，这就是链接地址。 七牛云存储，地址http://www.qiniu.com/，同样是将图片拖入区域中，会生成图片的URL，或填入其链接地址。 插入图片的同时，建议开启Fancybox，以next主题为例，打开_config.yml，将fancybox的配置false改成true即可。 12# Fancyboxfancybox: true 居中对齐Markdown语法本身没有居中的，但Markdown中支持基本的HTML语法，可以使用HTML语法。 123&lt;center&gt;居中对齐&lt;/center&gt;&lt;h1 style=&quot;text-align:center&quot;&gt;居中对齐 &lt;h1&gt;&lt;h1 style=&quot;text-align:right&quot;&gt;居右对齐 &lt;h1&gt; 发布照片文章修改\scaffolds\photo.md 1234567layout: &#123; &#123; layout &#125; &#125;title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:photos:- &lt;photo url&gt;--- 要发布照片文章： 1$ hexo new photo &quot;photoPostName&quot; hexo默认会处理全部 markdown 和 html 文件，如果不想让 hexo 解析，可以在文件头中加入 layout: false。 安装RSS在终端执行 1npm install hexo-generator-feed --save 然后在_config.yml中添加 123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 然后打开next主题文件夹里面的_config.yml,在里面配置为如下样子：(就是在rss:的后面加上/atom.xml,注意在冒号后面要加一个空格) 1234# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 配置完之后运行： 1$ hexo g 重新生成一次，你会在./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中。 添加动态背景 注意：如果next主题在5.1.1以上的话就不用我这样设置，直接在主题配置文件中找到canvas_nest: false，把它改为canvas_nest: true就行了（注意分号后面要加一个空格） 修改_layout.swig打开 next/layout/_layout.swig在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面) 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 修改配置文件打开 /next/_config.yml,在里面添加如下代码：(可以放在最后面) 123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 到此就结束了，运行 hexo clean，然后运行 hexo g,然后运行 hexo s，最后打开浏览器在浏览器的地址栏输入 localhost:4000 就能看到效果了\（￣︶￣）/ 如果你感觉默认的线条太多的话可以这么设置====&gt;在上一步修改 _layout.swig中，把刚才的这些代码： 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 改为 1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 配置项说明 color ：线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 添加网站图标网站图标即浏览网页时显示在标签页或将网页保存在书签时所显示的图标，图标可以视为网站的Logo，是网站个性化的一部分。 具体方法实现 在EasyIcon中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件： 12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico 404页面直接在根目录下创建自己的404.html。要注意的是，自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也不起作用。 添加百度站点地图 1$ npm install hexo-generator-baidu-sitemap@0.1.1 --save 在_config.yml中添加 12baidusitemap:path: baidusitemap.xml 更改主题下载自己喜欢的主题文件，可以到这里找。放到Hexo目录下的themes文件夹下，然后在_config.yml文件中找到： 1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: landscape //themes文件夹中对应文件夹的名称 将landscape改为所需要的主题文件的名字，如本博客即使用next，然后执行hexo clean(可省略)，再重新hexo g，hexo d，就能看到新主题的效果。 导航栏的定制打开主题的_config.yml文件，在开头找到如下代码： 123456789menu: home: / || home //首页 archives: /archives/ || archive //归档 categories: /categories/ || th //分类 tags: /tags/ || tags //标签 about: /about/ || user //关于 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404 看看你需要哪个菜单就把哪个取消注释打开就行了； 关于后面的格式，以archives: /archives/ || archive为例： || 之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改 ||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自Font Awesome。 添加搜索功能1、安装 hexo-generator-searchdb 插件 1$ npm install hexo-generator-searchdb --save 2、打开 站点配置文件 找到Extensions在下面添加 123456# 搜索search: path: search.xml field: post format: html limit: 10000 3、打开 主题配置文件 找到Local search，将enable设置为true 网站计数站点访问计数有名的就是不蒜子，使用起来非常方便。 1、安装脚本 打开 themes/next/layout/_partial/footer.swig，将下面这段代码添加到里面 12345678910&lt;div&gt;&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot; style=&apos;display:none&apos;&gt; 本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次 &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot; style=&apos;display:none&apos;&gt; 有&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人看过我的博客啦&lt;/span&gt;&lt;/div&gt; 添加的位置如下图，可自行根据个人喜好更换位置 2、以上只是显示站点的访问次数，如果想显示每篇文章的访问次数，打开 themes/next/layout/_macro/post.swig ，在第一行增加 1is_pv 字段 1&#123;% macro render(post, is_index, is_pv, post_extra_class) %&#125; 然后将这段代码插入到里面 1234&#123;% if is_pv %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次阅读&#123;% endif %&#125; 插入的位置 然后再打开 themes/next/layout/post.swig ，这个文件是文章的模板，给render方法传入参数（对应刚才添加的 1is_pv 字段） 最后再打开 themes/next/layout/index.swig ，这个文件是首页的模板，给render方法传入参数（对应刚才添加的is_pv字段） OK！设置完毕。 在右上角或者左上角实现fork me on github实现效果图 具体实现方法 点击这里或者这里挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码：然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址 实现点击出现桃心效果实现效果图 具体实现方法 在网址输入如下 1http://7u2ss1.com1.z0.glb.clouddn.com/love.js 然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout\_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： undefinedundefined 修改文章内链接文本样式实现效果图 具体实现方法 修改文件 themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式，： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 修改文章底部的那个带#号的标签实现效果图 具体实现方法 修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 在每篇文章末尾统一添加“本文结束”标记实现效果图 具体实现方法 在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）： 代码如下： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件（_config.yml),在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。 侧边栏社交小图标设置实现效果图 具体实现方法 打开主题配置文件（_config.yml），搜索social_icons:,在图标库找自己喜欢的小图标，并将名字复制在如下位置，保存即可 侧边栏推荐阅读今天有位网友问推荐阅读是怎么弄，其实挺简单的，打开主题配置文件修改成这样就行了(links里面写你想要的链接): 123456789# Blogrollslinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: 阮一峰: http://www.ruanyifeng.com/ 张鑫旭: http://www.zhangxinxu.com/ 百度前端技术学院: http://ife.baidu.com/ google前端开发基础: http://wf.uisdc.com/cn/ 添加评论系统 目前国内比较有名的多说、网易云跟帖评论系统都已停止服务了，国外的Disqus评论系统还得需要翻墙，所以不推荐使用，剩下的还有搜狐畅言、友言、来必力等。 本来想使用畅言的，结果注册完之后还得要求备案，我只想说F开头的那个单词，果断放弃。 后来选择了友言 1、进入友言官网注册、登录步骤我就不介绍了 2、登录完成之后，点击获取代码，你会发现出来了一段代码，里面有你的uid=1234567 3、打开 主题配置文件 找到youyan_uid将值设置为上面的uid就可以了 主页文章添加阴影效果实现效果图 具体实现方法 打开\themes\next\source\css\_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 网站底部字数统计实现效果图 具体方法实现切换到根目录下，然后运行如下代码 1$ npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上： 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 实现统计功能实现效果图 具体实现方法 在根目录下安装 hexo-wordcount,运行： 1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下： 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 在文章底部增加版权信息实现效果图 在目录 next/layout/_macro/下添加 my-copyright.swig： 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:mm&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:mm&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;wechat-subscriber.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 如下： 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import &quot;my-post-copyright&quot; 保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 小技巧：如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加：这样每次hexo new &quot;你的内容&quot;之后，生成的md文件会自动把copyright:加到里面去(注意：如果解析出来之后，你的原始链接有问题：如：http://yoursite.com/前端小项目：使用canvas绘画哆啦A梦.html,那么在根目录下_config.yml中写成类似这样：）就行了。 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。位置如图： 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如 title: 解决Charles乱码问题 date: 2017-05-22 22:45:48 tags: 技巧 categories: 技巧 copyright: true top: 100 SEO（搜索引擎优化）GoogleWebmasters：站长工具，让博客被Google更好的收录，比如手动让Googlebot抓取、提交Robots、更新Sitemap等。另有百度站长工具。经过测试，发现在Google提交网址并验证网站所有权和手动抓取后，很快就可以直接在Google上搜索到自己的播客网站，而百度则目前仍未能被其搜索引擎所抓取。可以看出Google对个人站长更为友好。 更多1、还有其他更多的主题配置，请查看主题配置 2、还有其他更多的插件，请查看Hexo插件 插件改的越多出错的bug风险就越大，毕竟对于小白来说可能一不小心两个插件冲突了自己不知道怎么办，不要逐本求末把太多精力放在这上面，所以先从基础的开始，网上相似的教程也有很多，大家最好找几篇对比着看，了解原理之后进行二次开发。 本文对网络文章和所使用工具的官方文档多有参考，一并谢过，不一一列举了。]]></content>
      <categories>
        <category>基础知识</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github博客教程：01基本操作]]></title>
    <url>%2F2018%2F11%2F01%2FHexo-Github%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%9A01%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[搭建步骤 GitHub创建个人仓库 安装Git 安装Node.js 安装Hexo 部署Github为我们的博客提供了托管平台。 首先注册一个GitHub帐号，然后建立与你用户名对应的仓库，仓库名必须为 1username.github.io 同时在Pages中开启Github Pages服务。进入刚才创建的仓库,点击右边菜单中的Settings按钮，在跳转到的页面 Update your site 对应处点击“Automatic page generator”按钮，这样就有了一个github自动生成的页面用来测试的时候使用。之后点击继续。选择主题,点击’Publish page’发布。 再次回到仓库,点击Settings按钮，点击链接就可以看到测试地址页面。 在站点配置文件_config.yml中，找到并修改： 1url: http://username.github.io/ 以及 1234deploy: type: git repository: https://github.com/username/username.github.io.git branch: master 每次将写好的文章部署到Github时，会被要求输入Github用户名和密码。 添加SSH Keys什么是SSH Keys简单说，SSH是一种网络协议，用于计算机之间的加密登录。 如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。 检查SSH Keys如果不清楚是否已经添加SSH，先检查： 1ls-al~/.ssh 如果有id_dsa.pub，id_ecdsa.pub，id_ed25519.pub等，说明有SSH keys。 如果未配置，则返回 1bash: ls-al~/.ssh: No such file or directory 如果没有的话,就生成一个SSH keys： 1$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 然后会出现: 12Generating public/private rsa key pair.Enter file in which to save the key (/Users/you/.ssh/id_rsa): 就是让你输入SSH keys要保存在哪里,一般不用改,就直接回车就好了。 然后会出现: 12Enter passphrase (empty for no passphrase): [Type a passphrase]# Enter same passphrase again: [Type passphrase again] 这是要求输入一个密码，记住这个密码。 保存SSH keys 创建成功后,他会提示你SSH keys保存在哪里: 1234Your identification has been saved in /Users/you/.ssh/id_rsa.# Your public key has been saved in /Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 找到SSH keys根据上一步里告诉你的路径,找到保存SSH keys的地方，其中id_rsa.pub 就是SSH keys。如果为了防止以后找不到，可以把他们自己另存到其它地方。 为github仓库添加SSH keysSSH keys创建好了，我们还要把它添加到仓库里去创建的仓库。 点击右侧的Settings，然后在左侧的Deploy keys中选择Add deploy key，点击Add deploy key。 然后把创建的id_rsa.pub里的内容复制到Key里去,Title部分随便填，点击Add key。添加的过程中，还要再输入一次github的密码。 测试连接回到git bash执行: 1$ ssh -T git@github.com 它可能会出现一些乱七八糟的提示，最后是问你yes/no,就输入yes。 如果要求输入密码，那这个密码就是之前设置的那个密码（已用黑体并加粗）。如果之前没有设置密码，没忽略此步骤。 1Enter passphrase for key &apos;/c/Users/2000104591/.ssh/id_rsa&apos;: 最后它提示你: 1Hi, 用户名/用户名.github.io! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 安装Git什么是Git ?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。如果想要了解Git的细节，参看廖雪峰老师的Git教程：Git教程 从Git官网下载：Git - Downloading Package 现在的机子基本都是64位的，选择64位的安装包，下载后安装，在命令行里输入git测试是否安装成功，若安装失败，参看其他详细的Git安装教程。安装成功后，将你的Git与GitHub帐号绑定，鼠标右击打开Git Bash或者在菜单里搜索Git Bash，设置user.name和user.email配置信息： 12git config --global user.name "你的用户名"git config --global user.email "你的邮箱" 安装Node.jsHexo基于Node.js，Node.js下载地址：Download | Node.js 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v : 12$ node -vv8.5.0 检测npm是否安装成功，在命令行中输入npm -v : 12$ npm -v5.3.0 到这了，安装Hexo的环境已经全部搭建完成。 安装 Hexo什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本博客就是借由Hexo搭建而成。 在上述所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 操作方法是：在一个文件夹中（最好放在一个安全的独立的目录下，尽量不要起中文名作为存放博客的文件夹，我是直接放在桌面的）右键，选择Git Bash Here，即可打开命令窗口。也可以执行如下命令。 123cd ~/Desktop: #进入桌面mkdir hexo #创建文件夹hexo，为了存放你的博客各种内容及设置cd hexo #进入hexo文件夹 在该文件夹中执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件，操作方法同上。 12$ hexo init #初始化$ npm i #安装依赖包 然后安装hexo-deployer-git插件 1npm install hexo-deployer-git --save 本地网页预览执行下列命令，生成本地网页并启动预览。 12hexo g #生成本地网页文件hexo s #启动预览服务 其中，npm i == npm installhexo g == hexo generatehexo s == hexo server 1http-server -c-1 #另一种启动本地预览服务的方法，推荐 当看到INFO Hexo is running at localhost:4000. Press Ctrl+C to stop.时就说明我们已经搭建起本地的Hexo博客，这时到浏览器输入localhost:4000可以看到结果（或者打开http://127.0.0.1:4000/ ），然后按Ctrl+C可以停止预览；如果用后一种办法的在浏览器输入的是： http://127.0.0.1:8080。到此，Hexo的初步使用就告一段落了。]]></content>
      <categories>
        <category>基础知识</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些软件的安装]]></title>
    <url>%2F2018%2F11%2F01%2F%E4%B8%80%E4%BA%9B%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Git Bash 的安装与配置 Node.js 的安装与配置 Git 的安装与配置 VSCode 的安装与配置 Git Bash 的安装与配置安装 从官网下载（算了，太慢了） 百度网盘：链接: https://pan.baidu.com/s/1nu99KWp 密码: jfdf 双击安装，注意每一步的选项要参考下面的图（如果没有对应的图，就直接下一步） 下面的路径可以随便填： 好了，安装完成。 配置安装成功之后，需要设置一下外观： 关闭重启 Git Bash 即可。 使用第一种使用方式找一个目录，在目录上右键点击，然后选中「Git Bash Here」，即可用 Git Bash 打开这个目录。 试试输入 touch 1.txt，回车后看看目录里是不是多了一个文件。 第二种使用方式直接打开 Git Bash，输入 cd ~/Desktop 即可来到桌面所在的目录。 试试输入 touch 1.txt，回车后看看桌面上是不是多了一个文件。 更多命令下节课我们会专门学习命令行，你可以试试下面几个简单的命令： 创建目录：mkdir my-dir 删除目录：rm -r my-dir 创建文件：echo &quot;hello&quot; &gt; newFile.txt 删除文件：rm newFile.txt 链接解决git bash无法复制和黏贴 Node.js 的安装与配置 从官网下载安装包 百度网盘下载：链接: https://pan.baidu.com/s/1cMxJcU 密码: xfyj 安装了之后 千万别 点击 Node.js 的图标 千万别 点击 Node.js 的图标 千万别 点击 Node.js 的图标 别问为什么，别点就是了。 配置打开 Git Bash，依次输入以下命令，按回车： 123npm config set registry https://registry.npm.taobao.org/npm config set loglevel httpnpm config set progress false npm 的配置被存储在 ~/.npmrc，你可以随时改。 使用npm 安装命令行小工具装了 Node.js 之后我们就可以在 Git Bash 里面使用 node 和 npm 这两个命令了，试试看： 1234which nodewhich npmnode -vnpm -v 依次输出看看你得到什么结果。 接下来跟大家展示一下 npm 的威力。我们可以用 npm 的翻译工具做一个随时可用的小字典，这个小工具的名字叫做 fanyi。 运行 npm i -g fanyi 即可安装 fanyi，安装完成之后，输入 fanyi frontend 就可以看到对应的中文释义了！ 是不是很帅呢？！ node 的使用 进入 Git Bash 输入 node，回车，就可以进入 node 运行环境，这个时候我们就可以写 JS 了 试试写最简单的 JS 语句，比如 1+2，回车 2 * 8，回车 这就是 node 的第一种使用方式 node 的另一种使用方式我们可以先创建一个 JS 文件，然后让 node 运行 来到桌面：cd ~/Desktop 新建一个目录用来玩耍：mkdir hello-node 进入这个目录：cd hello-node 新建一个有内容的 JS 文件：echo &quot;console.log(&#39;Hi, Node.js&#39;)&quot; &gt; main.js，那么 main.js 就新建成功了 输入 node main.js，回车，node 就会执行这个 main.js 文件，你会看到「Hi, Node.js」字样 玩完了，删除 hello-node：cd .. ; rm -rf hello-node Git 的安装与配置安装不需要安装，Git Bash 内置了 Git 命令，Git Bash 还内置了以下命令： ls mkdir cp mv 等等，大概有几十个命令，Git Bash 其实是一个 Bash，不是 Git。 Git Bash 给我们提供了一个虚拟的 Linux 环境，这样我们就不用忍受 Windows 里面垃圾一般的命令行体验了。 配置请在命令行运行这五句话！！！一定要运行这五句话，不然 git 就不能用了 12345git config --global user.name 你的英文名字 #方便产品经理找（怼）你git config --global user.email 你的常用邮箱 #方便产品经理找（怼）你git config --global push.default simple # 本来我写的是 matching，不过想了想可能 simple 更好git config --global core.quotepath false #防止文件名变成数字git config --global core.editor &quot;vim&quot; # 使用vim编辑提交信息 另外很重要的一点！你自己运行 git 的时候注意一下：git remote add origin 后面的地址，不允许使用 https 开头的地址，见下图 记得点击 SSH VSCode 的安装与配置从官网下载安装包 安装时把以下选项选中： 使用 找个地方新建一个目录（目录名不要中文），假设目录名为 vs-demo 右键点击该目录，open with code 使用 Ctrl+Shift+E 打开资源管理器，在 vs-demo 目录里新建 HTML 文件，文件名为 index.html 在 index.html 依次输入：英文感叹号、回车 键，即可看到一个完整的 HTML 页面 由于 vscode 时常更新，如果 回车 键不行，就试试 Tab 键 这种快捷写法叫做 Emmet，目前所有的前端编辑器都支持 Emmet。换句话说，如果一个编辑器没有默认支持 Emmet，你就可以卸载这款编辑器了（比如 Sublime Text 括弧笑）。 关于 Emmet 的更多快捷写法，见： 官网的视频介绍 Emmet 作弊表 配置VSCode 的配置方式就写编辑一个配置文件，打开「文件 - 首选项 - 设置」，对应快捷键为 Ctrl + , 左侧为系统默认配置项，右侧为你要覆盖的配置项。把你要修改的项从左边拷贝到右边，然后保存，即可生效。 设置字体与字号在右侧文件中添加一行（注意末尾要有英文逗号） 1&quot;editor.fontSize&quot;: 18, 保存，字号就变大了。 设置字体也是类似，添加 1&quot;editor.fontFamily&quot;: &quot;Consolas, &apos;Courier New&apos;, monospace&quot;, 即可将字体设置为你想要的。这里推荐「10大最适合编程的字体推荐下载」，够你玩一上午了。我用的编程字体一般是 Source Code Pro 和 M Plus 这两款。 其实 VSCode 默认的配置就挺好的。 插件安装VSCode 自带 Emmet、Git 继承和 JS 调试功能（后续会讲到），已经十分完善了，但是还是有一些特殊的需求，这个时候我们就可以安装第三方插件了。由于第三方插件不是微软生产的，所以质量良莠不齐，请注意甄别。 如果你发现 VSCode 没有 Git 功能： 那么你只需要在项目目录运行 git init 来激活 git 功能即可。 安装 open in browser按 Ctrl + Shift + X 打开扩展面板，然后输入 open in browser，点击第一个结果的「安装」按钮，稍等片刻就安装好了（相比之下 Sublime 的插件安装体验就差很多）。 然后你在任意 HTML 文件右键，就可以看到 Open In Default Browser 这个按钮了，点就试试看。]]></content>
      <categories>
        <category>基础知识</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>node</tag>
        <tag>Git Bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP入门]]></title>
    <url>%2F2018%2F10%2F30%2FHTTP%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[什么是HTTP?超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议[1]。HTTP是万维网的数据通信的基础。 设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。 HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。 协议概述HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。 尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。 请求方法HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源： GET 向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法 HEAD 与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。 POST 向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。 PUT 向指定资源位置上传其最新内容。 DELETE 请求服务器删除Request-URI所标识的资源。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 OPTIONS 这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。 方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。 状态码所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。 状态代码的第一个数字代表当前响应的类型： 1xx消息——请求已被服务器接收，继续处理 2xx成功——请求已成功被服务器接收、理解、并接受 3xx重定向——需要后续操作才能完成这一请求 4xx请求错误——请求含有词法错误或者无法被执行 5xx服务器错误——服务器在处理某个正确请求时发生错误 请求与响应下面是一个HTTP客户端与服务器之间会话的例子，运行于www.baidu.com，端口80。我们可以通过Chrome开发者工具查看HTTP的请求与响应内容。 请求首先我们需要打开电脑的命令行工具输入： 1curl -s -v -H "Neil : xxx" -- "https://www.baidu.com" 请求的内容为：12345GET / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.55.1Accept: */*Neil: xxx 我们还可以通过其他的方法来发送请求： 1curl -X POST -d "1234567890" -s -v -H "Neil : xxx" -- "https://www.baidu.com" 请求的内容为：123456789POST / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.55.1Accept: */*Neil: xxxContent-Length: 10Content-Type: application/x-www-form-urlencoded[10 bytes data] 请求的格式：1234567891 动词 路径 协议/版本2 Key1: value12 Key2: value22 Key3: value32 Content-Type: application/x-www-form-urlencoded2 Host: www.baidu.com2 User-Agent: curl/7.54.03 4 要上传的数据 我们可以得出结论一个完整的HTTP请求包含4个部分，分别为请求行、请求头、空行、其他的消息体，其中第四部分有时也可以为空。 如何用 Chrome 查看请求内容 打开 Chrome浏览器F12进入开发者工具点击Network 地址栏输入网址，比如：www.baidu.com 在 Network 点击，查看 request，点击「view source」 如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到了 响应请求了之后，应该都能得到一个响应，除非断网了，或者服务器宕机了。 响应示例上面两个请求的响应分别为 1234567891011121314HTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 2443Content-Type: text/htmlDate: Tue, 10 Oct 2017 09:14:05 GMTEtag: &quot;5886041d-98b&quot;Last-Modified: Mon, 23 Jan 2017 13:24:45 GMTPragma: no-cacheServer: bfe/1.0.8.18Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/[2443 bytes data] 123456789HTTP/1.1 302 FoundConnection: Keep-AliveContent-Length: 17931Content-Type: text/htmlDate: Thu, 01 Nov 2018 13:08:49 GMTEtag: &quot;54d9749e-460b&quot;Server: bfe/1.0.8.18[3824 bytes data] GET 请求和 POST 请求对应的响应可以一样，也可以不一样 响应的第四部分可以很长很长很长 响应的格式12345671 协议/版本号 状态码 状态解释2 Key1: value12 Key2: value22 Content-Length: 179312 Content-Type: text/html34 要下载的内容 如何用 Chrome 查看响应内容 打开 Chrome浏览器F12进入开发者工具点击Network 地址栏输入网址，比如：www.baidu.com 在 Network 点击，查看 Response Headers，点击「view source」 如果有请求的第四部分，点击查看Response或者Preview就可以了]]></content>
      <categories>
        <category>前端</category>
        <category>http</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
</search>
