<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode刷题记录]]></title>
    <url>%2F2018%2F12%2F14%2Fleetcode%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[仅做自己练习记录，尽量保证100%AC，不保证每题都能做出来。不定时更新…… 1. 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 12345678910var twoSum = function(nums, target) &#123; var tempArr = []; for (var i = 0; i &lt; nums.length; i++) &#123; var temp = target - nums[i]; var index = tempArr.lastIndexOf(temp); if (index !== -1) &#123; return [index, i]; &#125; tempArr.push(nums[i]); &#125; return null;&#125;;]]></content>
      <categories>
        <category>基础知识</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对JavaScript吧！12实现一个 jQuery API]]></title>
    <url>%2F2018%2F12%2F12%2F%E9%9D%A2%E5%AF%B9JavaScript%E5%90%A7%EF%BC%8112%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%20jQuery%20API%2F</url>
    <content type="text"><![CDATA[实现一个jQuery的API功能有： 给获取到的元素增加class 给获取到的元素设置文本 实现思路： 大视角：根据js执行的声明语句，判断出window.jQuery本质其实是一个函数，封装要实现上面功能的函数，这个函数需要接受参数，要返回一个对象，同时带有addClass属性和setText属性。下面是分步实现。 在window.jQuery函数中声明一个对象nodes，这个对象中有两个属性，这两个属性的value都是函数，分别实现上面的两个功能。 简单的做法：当调用函数jQuery的时候，根据传入的实参，直接提供一个解决办法，缺点：不实用，只能针对一种情况，遇到其他情况，需要重新改代码 实用的做法：当调用函数jQuery()的时候，在函数中判断传递的参数是字符串还是节点，然后对不同的数据类型做出不同的处理，如果传递的参数是字符串的话，则一定要加上nodes.length = temp.length;，为了之后可以遍历伪数组；如果传递的节点是字符串的话，则返回一个伪数组。 在对象nodes中用添加不同的属性（函数）实现不同的功能。 nodes.addClass添加了一个判断传进来的参数是字符串还是数组，采取不同的处理方法。 调用jQuery函数会返回对象nodes，从而可以在函数外面调用函数里面的对象中的方法 课后习题：补全下面的代码 123456window.jQuery = ???window.$ = jQueryvar $div = $(&apos;div&apos;)$div.addClass(&apos;red&apos;) // 可将所有 div 的 class 添加一个 red$div.setText(&apos;hi&apos;) // 可将所有 div 的 textContent 变为 hi 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546window.jQuery = function(nodeOrSelector)&#123; var nodes = &#123;&#125;; if(typeof nodeOrSelector === &apos;string&apos;)&#123; let temp = document.querySelectorAll(nodeOrSelector);// console.log(temp); for(let i=0;i&lt;temp.length;i++)&#123; nodes[i] = temp[i]; &#125;// console.log(nodes) nodes.length = temp.length; &#125;else if(nodeOrSelector instanceof Node)&#123; nodes=&#123; 0:nodeOrSelector, length : 1 &#125;// console.log(nodes) &#125; nodes.addClass = function(classes)&#123; //判断传进来的参数是字符串还是数组 if(typeof classes === &apos;string&apos;)&#123; for(let i=0;i&lt;nodes.length;i++)&#123; nodes[i].classList.add(classes); &#125; console.log(&quot;lalalal&quot;) &#125;else if(classes instanceof Array)&#123; classes.forEach(value =&gt;&#123; for(let i=0;i&lt;nodes.length;i++)&#123; nodes[i].classList.add(value); &#125; &#125;) &#125; &#125; nodes.setText = function(value)&#123; for(let i=0;i&lt;nodes.length;i++)&#123; nodes[i].textContent = &apos;hi&apos;; &#125; &#125; return nodes&#125;window.$ = jQueryvar $div = $(&apos;div&apos;)$div.addClass([&apos;yellow&apos;,&apos;green&apos;,&apos;blue&apos;]) //可将所有 div 的 class 添加数组里面的元素$div.addClass(&apos;red&apos;) // 可将所有 div 的 class 添加一个 red$div.setText(&apos;hi&apos;) // 可将所有 div 的 textContent 变为 hi]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对JavaScript吧！11DOM API]]></title>
    <url>%2F2018%2F12%2F11%2F%E9%9D%A2%E5%AF%B9JavaScript%E5%90%A7%EF%BC%8111DOM%20API%2F</url>
    <content type="text"><![CDATA[一、DOM1、定义DOM，即文档对象模型（Document Object Model ） 2、现象通过在页面——打开：检查元素——看见：元素为可折叠。可选中页面对应元素，事实上即选择了对象（即也选择了对象对应的属性或方法），相当于把页面文档对象化。事实上，就是用js手段调用操作该文档（即一个对象）。 二、Node接口，方法Node 分为 Document（html）、Element（元素）和 Text（文本），以及其他不重要的。 1、常用接口节点本身某些特征的属性: Node.nodeName: 看着DOM,如果你不确定某个Node节点是什么类型(不确定某个Node节点是矩形还是椭圆形) 返回节点类型,重要的返回的值有大写的HTML元素名, #text ,#document Node.nodeType: 根据Node类型返回某些数字 Element类型,返回的数字是1 Text类型,返回的数字是3 Document类型,返回的数字的9 Node.textContent 返回的当前节点及其所有后代的文本内容 值得注意的是,因为Node.textContent是Node属性,所以文本节点也是有textContent的 innerHTML和innerText是Element的属性,所以TextNode.innerHTML返回的是undefined,注意,并不是返回null 节点结构关系属性 兄弟关系 Node.nextSibling Node.previousSibling 儿子关系 Node.childNodes Node.firstChild Node.lastChild 父关系 Node.parentNode 上面的所有关系属性都可以获取到Text节点(除了父关系) Node.childNodes是最特殊的,它返回的是一个伪数组,里面是Node节点,并且伪数组内的值是动态变化的 2、方法（如果一个属性是函数，那么这个属性就也叫做方法；换言之，方法是函数属性） Node.appendChild() Node.hasChildNodes() Node.cloneNode() Node.insertBefore() Node.removeChild() Node.replaceChild() Node.contains() Node.isEqualNode() Node.isSameNode() Node.normalize() 三、Document对象，属性（或方法）在DOM中最常用的对象就是：document对象（页面——检查，即查看属性）、element对象 1、常用属性123456document.doctypedocument.titledocument.characterSetdocument.headdocument.bodydocument.images 2、document.readyStatereadyState属性 返回当前文档的状态，共有三种可能的值: loading：加载HTML代码阶段，尚未完成解析 interactive：加载外部资源阶段 complete：全部加载完成 图：可在代码中加上几张图片元素，再设置网络条件为慢3G，则出现： 3、 document.compatModecompatMode 属性 返回浏览器处理文档的模式，可能的值为 BackCompat：向后兼容模式，也就是没有添加DOCTYPE CSS1Compat：严格模式，添加了DOCTYPE 4、document.location用于获取一个url 可直接使用location，如： 12document.location === location //truedocument.location === window.location //true 总结： document.location === location === window.locationlocation属性返回一个只读对象，提供了当前文档的URL信息，如： 123456789101112// 假定当前网址为http://user:passwd@www.example.com:4097/path/a.html?x=111#part1document.location.href // &quot;http://user:passwd@www.example.com:4097/path/a.html?x=111#part1&quot;document.location.protocol // &quot;http:&quot;document.location.host // &quot;www.example.com:4097&quot;document.location.hostname // &quot;www.example.com&quot;document.location.port // &quot;4097&quot;document.location.pathname // &quot;/path/a.html&quot;document.location.search // &quot;?x=111&quot;document.location.hash // &quot;#part1&quot;document.location.user // &quot;user&quot;document.location.password // &quot;passed&quot; 其他location属性调用方法： 123456789101112131415// 跳转到另一个网址document.location.assign(&apos;http://www.google.com&apos;)// 优先从服务器重新加载document.location.reload(true)// 优先从本地缓存重新加载（默认值）document.location.reload(false)// 跳转到另一个网址，但当前文档不保留在history对象中，// 即无法用后退按钮，回到当前文档document.location.assign(&apos;http://www.google.com&apos;)// 将location对象转为字符串，等价于document.location.hrefdocument.location.toString() 5、document.write()用document.write()方法时，即向当前文档写入内容，只要当前文档还没有用close方法关闭，它所写入的内容就会追加在已有内容的后面。1 如果页面已经渲染完成再调用write方法，它会先调用open方法，擦除当前文档所有内容，然后再写入。 如果在页面渲染过程中调用write方法，并不会调用open方法。-需要注意的是，虽然调用close方法之后，无法再用write方法写入内容，但这时当前页面的其他DOM节点还是会继续加载。-做测试时，无须使用document.write()方法 四、Element对象，属性（或方法）document对应的具体元素应如何选取（或操作）？element对象表示页面上的元素。使用JS选择页面上的元素（element），然后对其做操作。 那么，对页面元素的操作有哪些？ A、选择它：通过一些方法找到其具体元素（如用css的id，class名，选择器、邻居、赋值等） B、处理它：对拥有类型为元素节点、文本节点、注释节点的子节点进行删除、增加、查找、修改等操作 1、几个常用属性1234567891011nodeName：元素标签名，还有个类似的tagNamenodeType：元素类型className：类名id：元素idchildren：子元素列表（HTMLCollection）childNodes：子元素列表（NodeList）firstChild：第一个子元素lastChild：最后一个子元素nextSibling：下一个兄弟元素previousSibling：上一个兄弟元素parentNode、parentElement：父元素 2、查询元素（如何选中一个元素？）（1）getElementById()结合页面元素使用 +document.getElementByid() 如图：利用此方法选中该id的页面位置 （2）getElementsByClassName() 注：有sdocument.getElementByClassName() 页面元素中不止独一无二的id名，还有类选择器，当我们在页面控制台上通过getElementByClassName()时，可获取（或查询）到一个或多个类选择器，会出现如图现象：这看上去有点像数组，呈现形式相似、也可以用下标去进行访问。但通过list.去查看，并没有有关排序push、pop等的调用数组的方法，而是一种类数组的形式。 通过： 12list.constructor--&gt; ƒ HTMLCollection()&#123; [native code] &#125; 我们可以获知，document.getElementsByClassName() 所调用的是html里类的集合，其类型为HTMLCollection()，是一种页面元素的集合。 （3）getElementsByName()document.getElementsByName()通过此方法可以获取页面元素中带有name属性的html元素。比如form、img、frame、embed和object，返回一个NodeList格式的对象，不会实时反映元素的变化。如： （4）假设,类选择器有嵌套的话，我们如何获取嵌套于内的元素？如图：A、（较为繁琐的） ES3写法：getElementsByName().getElementsByName() 语法：document.getElementsByName().getElementsByName() 例子： 12document.getElementsByClassName(&apos;box&apos;)[0].getElementsByClassName(&apos;child&apos;)--&gt; HTMLCollection [div.child] 事实上，使用document.getElementsByName()做一个联集，即无论是document还是任何一个对象，都可以使用：对象.XXXX 去做一个联集对象去获取相对应的准确元素。 B、（较为简便的）ES5写法：querySelector() 注：可用于选择id元素使用 语法：document.querySelector() 例子： 12document.querySelector(&apos;.box .child&apos;)--&gt; &lt;div class=&quot;child&quot;&gt;child&lt;/div&gt; 不过，它选择元素的时候，只能获取一个元素，如页面元素中有多个div，只会默认选择html元素中排在第一个的div元素。 如果需要在选择元素时，多种页面元素希望可以同时选中，则可以使用这样的写法：querySelectorAll() 注： 可用于选择class元素时使用 例子： 1234567//比如：document.querySelectorAll(&apos;div&apos;)--&gt; NodeList(3) [div.box, div.child, div.box]document.querySelectorAll(&apos;.box&apos;)--&gt; NodeList(2) [div.box, div.box]document.querySelectorAll(&apos;#target&apos;)--&gt; NodeList [p#target] 在控制台测试时，我们可以直接使用$()和$$()直接代document.querySelector()和document.querySelectorAll() 1234$(&apos;#target&apos;)--&gt; &lt;p id=&quot;target&quot;&gt;wangxiaoqin&lt;/p&gt;$$(&apos;#target&apos;)--&gt; [p#target] 可以自己写个方法，让$()和$$()可以在代码编辑器中直接使用，如下： 123456789101112//写个方法：function $(selector)&#123; return document.querySelector(selector)&#125;--&gt; undefined//即下面就可以在编辑器大胆使用$() 和 $$()，举几个例子：$(&apos;#target&apos;)--&gt; &lt;p id=&quot;target&quot;&gt;wangxiaoqin&lt;/p&gt;$(&apos;.box&apos;)--&gt; &lt;div class=&quot;box&quot;&gt;…&lt;/div&gt;$(&apos;.box .child&apos;)--&gt; &lt;div class=&quot;child&quot;&gt;child&lt;/div&gt; （5）getElementsByTagName()document.getElementsByTagName() 此方法返回所有指定标签的元素（搜索范围包括本身），返回值是一个HTMLCollection对象，也就是说，搜索结果是一个动态集合，任何元素的变化都会实时反映在返回的集合中。如图： 3、创建元素（1）createElement() 创建一个新的元素放到页面上 用此方法创建并传入html的元素标签，创建一个虚拟的dom。该dom的节点存在内存里，并没有放在页面上，用户看不见。如： 1234567891011document.createElement(&apos;div&apos;)--&gt; &lt;div&gt;&lt;/div&gt;//可赋值一个变量，之后可通过该变量轻松获取var div = document.createElement(&apos;div&apos;)--&gt; undefineddiv--&gt; &lt;div&gt;&lt;/div&gt;var div = document.createElement(&apos;img&apos;)--&gt; undefineddiv--&gt; &lt;img&gt; （2）createTextNode()光出现元素标签还不够，我们可通过createTextNode()去创建（或生成）一个文本，将文本的内容放入元素中，如： 1234var text = document.createTextNode(&apos;wangxiaoqin&apos;)--&gt; undefinedtext--&gt; &quot;wangxiaoqin&quot; （3）createDocumentFragment()该方法用来生成一个存在于内存的dom片段，但不属于当前文档。即不会生成一个标签，虚拟生成，常用于生成复杂的dom结构，然后插入当前文档。 正因为它不属于当前文档，所以并不参与页面的渲染加载的过程，它的任何改动都不会引发网页的重新渲染。比直接修改当前文档的DOM有更好的性能表现。 4、修改元素（1）appendChild()在元素末尾添加元素。把一个dom对象放入在另外一个对象的内部作为它的孩子 如： 1234var newDiv = document.createElement(&quot;div&quot;)var newContent = document.createTextNode(&quot;Hello&quot;)newDiv.appendChild(newContent)//括号内为新添加的“孩子”--&gt; &quot;hello&quot; 看一个实例： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;navbar&quot;&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;//选择该容器ul，获取指定元素var navbarNode = document.querySelector(&apos;.navbar&apos;)for(var i=0;i&lt;5;i++)&#123;//以下循环5此 //创建一个子元素li var child = document.createElement(&apos;li&apos;) //创建一个文本，参数为字符串 var text = document.createTextNode(&apos;hello&apos;+i) //修改元素 child.appendChild(text) //然后再把li放在我们的navbarNode里 navbarNode.append(child)&#125;&lt;/script&gt; 如图： 另一种方法： 使用appendChild() 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;navbar&quot;&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;//选择该容器ul，获取指定元素var navbarNode = document.querySelector(&apos;.navbar&apos;)//创建一个虚拟的片段，可看成是一个虚拟标签，到最后放在navbarNode，该虚拟标签消失var fragment =document.createDocumentFragment()for(var i=0;i&lt;5;i++)&#123;//以下循环5此 //创建一个子元素li var child = document.createElement(&apos;li&apos;) //创建一个文本，参数为字符串 var text = document.createTextNode(&apos;helloo&apos;+i) //修改元素 child.appendChild(text) //然后再把li放在我们的frgment这个虚拟片段里 fragment.appendChild(child)&#125;//再将这个片段放在navbarNode里navbarNode.appendChild(fragment)&lt;/script&gt; 如图：在控制台我们可以看到：再回看JS代码，则可以知道， 1var fragment =document.createDocumentFragment() 这里创建的这个虚拟片段，我们可看成是一个虚拟标签，到最后放在navbarNode，该虚拟标签消失。并不影响实际页面元素的改动。 假设：我们在createDocumentFragment()里加上一个实际的块元素包裹li，那么则不符合页面的规则，如：控制台则如：这显然不符合规则 （2）insertBefore()在某个元素之前插入元素 123var newDiv = document.createElement(&quot;div&quot;)var newContent = document.createTextNode(&quot;Hello&quot;)newDiv.insertBefore(newContent, newDiv.firstChild) （3）replaceChild()replaceChild()接受两个参数：要插入的元素和要替换的元素 1newDiv.replaceChild(newElement, oldElement) 5、删除元素removeChild() 用于删除元素 1parentNode.removeChild(childNode) 6、clone元素克隆一个完成的dom节点。方法有一个布尔值参数，传入true的时候会深复制，也就是会复制元素及其子元素（IE还会复制其事件），false的时候只复制元素本身 1node.cloneNode(true) 五、属性的操作（即修改dom元素的属性的操作方法）1、getAttribute()（现有页面中有一个图片地址，所对应的是一个src的地址，如果更换图片，则需要修改src对应的值。（或获取一个img的src，或a链接的href））用于获取元素的属性值，如： 1node.getAttribute(&apos;id&apos;) 2、createAttribute() 【一般用不到，一般不创建】用于创建（或获取）属性名，如 1attribute = document.createAttribute(name)//参数name，是属性的名称 3、setAttribute()用于设置属性和值 12var node = document.getElementById(&quot;div1&quot;);node.setAttribute(&quot;my_attrib&quot;, &quot;newVal&quot;); //括号中为“属性名+值” 4、removeAttribute()用于删除对应属性 1node.removeAttribute(&apos;id&apos;) 页面范例展示涉及到的点： （1）查找、修改、获取、删除a链接的属性（这里为id） 12345678910111213var link = document.querySelector(&apos;a&apos;)link &lt;a href=&quot;#&quot;&gt;wanxgiaoqin&lt;/a&gt;//可以创建 a链接的id属性值link.setAttribute(&apos;id&apos;,&apos;login&apos;)//以此类推，可以修改它的idlink.setAttribute(&apos;id&apos;,&apos;logout&apos;)//可以获取（或添加）它的idlink.getAttribute(&apos;id&apos;)//可以删除它的idlink.removeAttribute(&apos;id&apos;) 图： （2）创建一个样式放在页面上，如何操作？ 如：使用js让我们的页面上引入一个新的js，如jquery。可先在Bootstrap 中文网开源项目免费CDN加速服务上找一个jquery的地址 分析：用js引用一个jQuery，那么需要有一个scirpt的标签，用src来指向jQuery地址 123456789101112131415161718192021//创建一个script标签var script = document.createElement(&apos;script&apos;)--&gt; undefinedscript &lt;script&gt;&lt;/script &gt; //设置元素的属性和值script .setAttribute(&apos;src&apos;,&apos;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&apos;)--&gt; undefined//验证一下script--&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script &gt; //通过.body.appendChild(script)将整个标签属性值放置到页面document.body.appendChild(script)--&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script &gt; //使用jquery$--&gt; ƒ (e,t)&#123;return new w.fn.init(e,t)&#125;jQuery--&gt; ƒ (e,t)&#123;return new w.fn.init(e,t)&#125; 5、innerHTML VS innerText（1）innerHTML假设获取了一个dom元素，想知道页面中的html元素是什么，或者放入很多东西（不通过创建dom节点的方式appendChild进去）页面的一些菜单栏设置，通过后台要数据，后台交还一个数组或json数据（包括菜单的所有信息），如何将菜单渲染到页面上？通过字符串操作遍历对象（或数组）去拼装html字符串，拼接后一次性将html放置在空的节点下，则页面看到了东西 几个操作：Ajax获取数据——数据到来之后拼接html字符串（遍历、相加）——通过innerHtml方法将包含菜单信息的html字符串放在页面上 1234567891011121314151617//数组的值渲染做成一个菜单var navbarDate =[1,2,3]//写一个空字符串，去拼接字符串的htmlvar html =&apos; &apos;//遍历这个数组navbarDate.forEach(function(item)&#123; html +=&apos;&lt;li&gt;&apos;+item+&apos;&lt;/li&gt;&apos; //将数组三个数拼在一起&#125;)--&gt; undefinedhtml--&gt; &quot;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&quot; //无需换行，只需要拼接处html字符串即可//可将生成的html字符串放在.navbardocument.querySelector(&apos;.navbar&apos;).innnerHTML = html--&gt; &quot;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;li&gt;3&lt;/li&gt;&quot; document.querySelector(&apos;.navbar&apos;)--&gt; &lt;div class=&quot;navbar&quot;&gt;...&lt;/div&gt; 图： （2）innerText看看所设置的元素标签下文本是什么（或设置它的文本） 注： 没有必要再创建什么元素标签，只需要设置一个空标签，然后设置它的innerText 续上面的例子： 12345document.querySelector(&apos;.navbar&apos;).innerText //作html去执行--&gt;&quot;1 2 3 &quot; 假如代码是这样： 1document.querySelector(&apos;.navbar&apos;).innerText = html //呈现给用户 则将展示文本设置在页面上，如图： 六、常见的使用方式1、修改样式可修改元素的style属性，修改结果直接反映到页面元素（不过，由于CSS权重的关系，虽然控制台修改dom节点上的style属性与页面上的一一对应，但如果权重比不够，修改的结果也不一定生效）如： 123//dom元素的style属性上的 XXX与页面上一一对应document.querySelector(&apos;p&apos;).style.color = &apos;red&apos; //选中对应元素，和修改对象+属性document.querySelector(&apos;.box&apos;).style.backgroundColor = &apos;#ccc&apos; 2、获取样式 getComputedStyle不是获取元素的style属性，而是元素计算后的样式（包括其他地方做的设置、浏览器默认样式、继承样式等综合后的结果）。即 123var node = document.querySelector(&apos;p&apos;)var color = window.getComputedStyle(node).color //可直接使用，它是处在win的一个全局变量属性console.log(color) 如在控制台想要获取页面dom元素的字体大小,如： 12345getComputedStyle(document.querySelector(&apos;#hello&apos;)) //获取的是相对应的对象，通过对象获取对应的style对应的属性getComputedStyle(document.querySelector(&apos;#hello&apos;))[&apos;font-size&apos;]//即获取字体大小//等同于getComputedStyle(document.querySelector(&apos;#hello&apos;)).fontSize 3、class操作当使用样式操作时，涉及到一些样式的切换，可以直接去修改它的style，但这样比较细，且复杂。假设当我们在页面点击一个按钮时，整体发生一个很大的变化（包括字体大小、出现的边框、背景色、背景图片，甚至动画效果），如果都是用style来操作，或导致代码冗长难修改，我们可以将这些样式放在一个css的class里面，如active。正常情况下是没有这些class，当我们点击某个元素的时候，即鼠标放上去时，给这个元素添加一个class 1234567var nodeBox = document.querySelector(&apos;.box&apos;)console.log( nodeBox.classList ) //通过选择元素nodeBox去看看classList里拥有哪些class， //即得到一个类数组对象.通过下标的方式获取classnodeBox.classList.add(&apos;active&apos;) //新增 classnodeBox.classList.remove(&apos;active&apos;) //删除 classnodeBox.classList.toggle(&apos;active&apos;) //新增/删除切换node.classList.contains(&apos;active&apos;) // 判断是否拥有 class 如图：class操作，不用担心class的数量有多少，无需担心同名、正则，只需要采用这种原生JS的API就能操作页面dom元素 4、页面宽高的计算（1）element.clientHeight VS element.clientWidth获取元素窗口的高度、宽度 （2）element.offsetHeight VS element.offsetWidth获取（包含边框+内边距+窗口整体）的高度、宽度获取两种的宽高，得到的结果看具体情况，有些时候是相同，有些时候是不同，如图： （3）element.scrollHeight元素滚动内容的总长度，也分实际情况假设页面上有一处包含内容的div块级，页面若为可滚动的，表示内容长度超出它容器的高度，而容器高度已为固定宽高，此时scrollHeight＞clientHeight若页面若无滚动条、父容器高度没有固定，则scrollHeight=clientHeight=offsetHeight （4）element.scrollTop获取元素滚动的高度，即滚动时滚动了一定的值 1document.body.scrollTop （5）window.innerHeight窗口的高度 1window.innerHeigh 实例操作：http://js.jirengu.com/fuser/1/edit?html,css 以下问题跟之后的解决懒加载有密切联系 问题1：如何去判断一个元素是否出现在窗口的视野中 问题2：如何判断页面滚动到底部 元素到顶点的值=滚动的值 元素滚动的距离+窗口的高度=这个元素到顶点的距离]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对JavaScript吧！10数组]]></title>
    <url>%2F2018%2F12%2F10%2F%E9%9D%A2%E5%AF%B9JavaScript%E5%90%A7%EF%BC%8110%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[一、数组基本使用1、如何去声明一个数组1var arr = [ 值 ] 值里面可以是数据类型中的任何一个，如数字、字符串、对象、函数、数组等任何如： 1var arr = [3，4，5] 题外话： 数组正（fu）规（za）的写法 12Array(3,4,5) //(3) [3, 4, 5] 图： 2、length（表示数组的个数）语法： 1arr.length （1）如何获取数组的最后一位具体数值？ 1arr[arr.length-1] 如： 12345arr = [4,5,6] //(3)[4,5,6] arr[arr.length-1] //6 （2）用arr.length=0来清空数组，变成空数组 1arr.length=0 --&gt;0 arr --&gt;[] （3）length如何进行截断（截断一词，是我自己想的，很形象了😂）假设： 123456789101112131415var arr = [4,5,6] //undefinedarr// (3) [4, 5, 6] arr[100]=100 //100 arr.length //101 arr[3] // undefinedarr[99] //undefinedarr[100] //100` 然后，我们通过设置length进行数组截断 1234arr.length = 2 //2 arr //(2) [4, 5] 3、下标使用语法： 1arr[下标位数] （1）用下标访问数组的每一个元素： 12345678910arr = [4,5,6] //(3)[4,5,6] arr[0] // 4 /* 或 */arr[1] // 5/* 或 */arr[2] // 6 （2）用下标去赋值,假设 123arr[2] =100 arr // (3) [3, 4, 100] 或 12345//为不存在位数赋值 arr[3]=101//101 arr //(4) [3, 4, 100, 101] 或者 1234arr[100]=10 //10 arr // (101) [3, 4, 100, 101, empty × 96, 10] 图： 4、使用for循环遍历length，得出数组里具体的值1234567arr =[4,5,6] //(3) [4, 5, 6] for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i]) &#125; //4 5 6 二、数组的一些操作1、栈方法：在数组里最后一位进行新增、删除操作这是数组中的一种栈方法，能够让我们使用堆栈那样先入后出使用数组（1）新增（于最后一位）：push语法： 1arr.push() 如： 1234arr.push(&apos;wangxiaoqin&apos;) // 4 //返回值输出位数 arr //(4) [4, 5, 6, &quot;wangxiaoqin&quot;] （2）去除（掉最后一位）：pop语法： 1arr.pop() 如： 12345678arr.push(&apos;wangxiaoqin&apos;) // 4 //返回值输出位数 arr //(4) [4, 5, 6, &quot;wangxiaoqin&quot;] arr.pop() //或console.log(arr.pop())，对应变量是一个结果（或方法） //&quot;wangxiaoqin&quot; arr //(3) [4, 5, 6] 2、队列方法：数组里第一位新增、删除这是数组中的一种队列方法，先入先出的队列法使用数组 （1）新增（于第一位）：unshift语法： 1arr.unshift() 如： 1234arr.unshift(&apos;wangxiaoqin&apos;) //4 arr //(4) [&quot;wangxiaoqin&quot;, 4, 5, 6] （2）删除（掉第一位）：shift语法： 1arr.shift() 如： 12345678arr.unshift(&apos;wangxiaoqin&apos;) //4 arr //(4) [&quot;wangxiaoqin&quot;, 4, 5, 6] arr.shift() //&quot;wangxiaoqin&quot; arr//(3) [4, 5, 6] 3、在数组的任意位置新增、删除（1）splice:删除、新增、替换、修改 A、语法：arr.splice (star位数,length/替换值,具体值) B、用处： 用于一次性解决数组添加、删除（二者结合可达到替换效果） C、三个参数： 开始索引 删除元素的位移如：指定前两个参数，可以使用splice删除数组元素，同样会带来索引调整及length调整 12345678var arr = [1,2,3,4,5] // undefinedarr.splice(1,3)//从下标1开始（包括下标1的值2），删除3个，所以数组元素为2，3，4 均被删除 //(3) [2, 3, 4] //所输出的a.splice所执行的结果，是一个新数组为[2, 3, 4] arr.length //2arr //(2) [1, 5] //同时arr本身剩下[1,5] 插入（替换）新元素（可以多写几个） 如：插入和替换，如果从第几个位开始做替换，替换的数组元素个数为0，即把0个元素替换成我需要的数组元素，则是使用splice插入法 12345678var arr =[1,2,3,4,5] --&gt; undefinedarr.splice(1,0,9,99,999) //从下标1开始，即数组元素2前面，替换（其实就是插入）9，99，999三个数组元素 // [] arr.length // 8 arr// (8) [1, 9, 99, 999, 2, 3, 4, 5] 注： 这样的插入法，是连续性的，不在同一脚本同一时刻进行不同位数的插入。执行数组插入（替换）是一次完成，数组本身长度发生变化 实例： 如怎么去掉数组里的负数值，先看一个错误示范： 12345678910var arr =[3, 4, -3, -2, -1, 5] --&gt; undefined for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;0)&#123; //数组里的具体值 arr.splice(i,1) //此时执行完下标为2的-3值，得出新数组[3, 4, -2, -1, 5] //继续执行i++,此时i=3,此时数组元素-1下标为3，直接跳过数组元素-2的下标 &#125; &#125; // [-1] arr // (4) [3, 4, -2, 5] 正确示范： 1234567891011 var arr =[3, 4, -3, -2, -1, 5] // undefined for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;0)&#123; arr.splice(i,1) i -- //通过退回下标，可执行忽略的那个位数上的数组元素 &#125; &#125; //undefined arr //(3) [3, 4, 5] 1splice 方法返回一个由删除元素组成的新数组，没有删除则返回空数组，则原数组发生改变,如： 12345678var arr = [3,4,5] // undefinedarr//(3) [3, 4, 5] arr.splice(1,2) //从下标为1的元素开始，拿出来2个元素作为一个数组返回，原数组发生改变 //(2) [4, 5] arr //[3] //原数组发生改变 12345678arr.push(8,9,10) --&gt; 6 arr --&gt; (6) [4, 5, 6, 8, 9, 10] arr.splice(2,0,1,2,3) //从下标为2的位置（元素6）前开始，删除0个，新增两个元素(在6前面新增8,9,10) --&gt; [] arr --&gt; (9) [4, 5, 1, 2, 3, 6, 8, 9, 10] （2）slice语法：arr.splice(star,end) 如： 123456arr // (9) [4, 5, 1, 2, 3, 6, 8, 9, 10] arr.slice(2,3)/*从arr下标为2开始，到下标为3结束(不包括3)，做为新数组，原数组不变 */ // [1] arr // (9) [4, 5, 1, 2, 3, 6, 8, 9, 10] 4、join（加入一个任意字符串（甚至空字符串））1arr.join() //灵活应对 如： 123456789var arr = [3,4,5] // undefinedarr// (3) [3, 4, 5] arr.join(&apos;-&apos;) // &quot;3-4-5&quot; /* 或 */arr.join(&apos;.&apos;) // &quot;3.4.5&quot; 5、reverse（数组里的值进行倒序（本身发生变化））倒序法，会修改原数组 语法：arr.reverse() 如： 123456var arr=[3,4,5,6,7,8] // undefinedarr// (6) [3, 4, 5, 6, 7, 8] arr.reverse() // (6) [8, 7, 6, 5, 4, 3] 假如，当数组索引（下标）不是连续或以0 开始，结果需要注意： 1234567891011121314var a = [1,2,3,4,5] // undefineda =[] // [] a[2]=2 // 2 a[3]=3 // 3 a[7]=4 // 4 a[8]=5 // 5 a.reverse() // (9) [5, 4, empty × 3, 3, 2, empty × 2] 6、concat（合成两个数组）如： 12345678910var a = [1, 2, 3, 4, 5] --&gt;undefined var b = [6, 7, 8, 9] --&gt;undefineda.concat(b) // (9) [1, 2, 3, 4, 5, 6, 7, 8, 9] //返回一个新数组，由于原数组保持不变，所以需要为这个数组赋值一个新变量 a// (5) [1, 2, 3, 4, 5] //原数组保持不变 b // (4) [6, 7, 8, 9] //原数组保持不变 7、sort（对数组进行排序）排序法，是一种内部的排序。可排序数字、字符串 语法：a.sort() 如： 对数字 1234var a=[5,4,3,2,1] // undefineda.sort() // (5) [1, 2, 3, 4, 5] 对字符串 1234var a=[5,&quot;a&quot;, &quot;c&quot;, &quot;h&quot;, &quot;z&quot;] // undefineda.sort() // (5) [5, &quot;a&quot;, &quot;c&quot;, &quot;h&quot;, &quot;z&quot;] 但是假如，这样排序，结果则不是按顺序排序 1234var a=[7,8,9,10,11] // undefineda.sort() // (5)[10, 11, 7, 8, 9] 不加参数用sort排序法直接排序，它会将数组里的元素当成字符串去排序。按照字母表排序，7就比10大，这时候我们可以在sort内部传入自定义排序函数（比较函数）： 123456789101112131415161718192021222324252627282930var a=[7,8,9,10,11] --&gt;undefineda.sort() // (5) [10, 11, 7, 8, 9] a.sort(function(v1,v2)&#123; return v1-v2 &#125;) // (5) [7, 8, 9, 10, 11]/*或者*/var friends = [&#123;age:3,name:&apos;dog&apos;&#125;,&#123;age:2,name:&apos;cat&apos;&#125;,&#123;age:4,name:&apos;bird&apos;&#125;] --&gt;undefinedfriends.sort(function(v1,v2)&#123; return v1.age -v2.age &#125;) // --&gt;(3) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;] --&gt;0: &#123;age: 2, name: &quot;cat&quot;&#125; 1: &#123;age: 3, name: &quot;dog&quot;&#125; 2: &#123;age: 4, name: &quot;bird&quot;&#125; length: 3__proto__: Array(0) friends //--&gt;(3) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;] friends.sort(function(v1,v2)&#123; return v1.name &gt; v2.name &#125;) //--&gt;(3) [&#123;…&#125;, &#123;…&#125;, &#123;…&#125;] --&gt; 0: &#123;age: 4, name: &quot;bird&quot;&#125; 1: &#123;age: 2, name: &quot;cat&quot;&#125; 2: &#123;age: 3, name: &quot;dog&quot;&#125; length: 3__proto__: Array(0) 三、如何创建一个数组1、通过构造函数数组，作为一个特殊对象，通过传统的newArray创建数组 2、通过使用字面量如： 1234var arr= [5] // undefineda.length // 1 注：使用带初始化参数的方式创建数组的时候，最好最后不要带多余的,，在不同的浏览器下对此处理方式不一样，如 1234var a1 = [1,2,3,]//该脚本在现代浏览器上运行结果和我们设想一样，长度是3，但是在低版本IE下确实长度为4的数，而最后一条数据是undefined,就会造成误会 。 console.log(a1.length) console.log(a1) 四、数组的索引、长度数组也是对象，我们可以使用索引的奥秘在于，数组会把索引值转换为对应字符串（如 1=&gt;“1”）作为对象属性名如： 1234567var arr =[1,2,3,4] arr[0] // 1 var i = 1 console.log(arr[i]) // 2console.log(arr[++i]) // 3 题外话： 不过在做这道题的时候，我发现一旦没有深刻理解操作符和运行机制的话，会导致结果不同，如：由于i++是后置，运行时按照：先拿i的值——再进行++操作；++i则是前置，运行时按照：先++操作再拿i的值。所以，运行机制上 五、数组的两三话1、数组的底层数据结构数组 === 特殊的对象（注：对象，由属性和属性值构成）。通过数组和对象的研究可以看出，数组可看成在对象的基础上做了一层的封装，然后自身又增加了一些方法。如： 123456arr = [4,5,6] //--&gt;(3) [4, 5, 6] //--&gt;0: 4 //展开之后数组的底层数据结构 1: 5 2: 6 length: 3 __proto__: Array(0) 再如： 123456obj = &#123;1:4,2:5,3:6,length:3&#125; //&#123;1: 4, 2: 5, 3: 6, length: 3&#125;//数组底层的数据结构构成obj[1] // 4obj.length // 3 2、数组的一些用法（1）关于数组里的属性和值的一些奇怪的写法 12345678910111213arr [-10] = &apos;aaa&apos; --&gt; &quot;aaa&quot; arr [-10] --&gt; &quot;aaa&quot; arr //--&gt;(3) [4, 5, 6, -10: &quot;aaa&quot;] (3) [4, 5, 6, -10: &quot;aaa&quot;] --&gt; 0: 4 1: 5 2: 6 -10: &quot;aaa&quot; //这是一个很奇怪的属性和值， length: 3 __proto__: Array(0) （2）关于数组中删除的问题 A、首先，删除数组元素，可以直接使用delete，如 1234567891011var arr = [3,4,5] //undefinedarr // (3) [3, 4, 5] delete arr[2]//通过最后的输出，则能知道数组里的是位数属性 //true arr// (3) [3, 4, empty] console.log(arr[2]) // undefined undefined B、以此，我们可以联想到，如果a[2]被赋值为undefined，情况也和delete之后的undefined类似，不会改变数组长度，也不会改变其他数据的index和value对应关系。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对JavaScript吧！09对象]]></title>
    <url>%2F2018%2F12%2F09%2F%E9%9D%A2%E5%AF%B9JavaScript%E5%90%A7%EF%BC%8109%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[一、对象1、定义：本质上是一种无序的数据集合，由若干个“键值对”（又称为：成员）（key-value）构成。其中，键值对，包括键名（key，即成员的名称）、键值（value，即成员的值）。 2、先前我们对对象的定义：123456object() // &#123;&#125; ⏬ var obj = object() obj //&#123;&#125; 再让我们看看，{}+键值对所定义的对象，让我们再看一个例子： 123var obj = &#123; p: &apos;Hello World&apos; &#125;; 这样看来，相当于 1object() === &#123;&#125; 例子中，{}定义了一个对象，且被赋值给变量obj。这个对象内部包含一个键值对，P为“键名”，字符串hello world为“键值”，即：{键名：键值}，包含多对键值对，每个键值对之间用逗号分隔，如： 1var o = &#123; p1: &apos;Hello&apos;, p2: &apos;World&apos; &#125;; 是不是知道对象是什么了？事实上，{key：value}这种写法，在JS中我们把它称为JS的对象字面量（也是数组字面量写法）。让我们继续。。。 二、基本使用首先要定义一个对象 1、对象的一般写法：12345678 var company = &#123; name:&apos;wangxiaoqin&apos; &#125; --&gt;undefined/* 调用属性name，输出值：&quot;wangxiaoqin&quot; */ company //&#123;name: &quot;wangxiaoqin&quot;&#125; 或者 12345678910111213141516var company = &#123; name: &apos;世界你好&apos;, age: 3, sayHello: function()&#123; console.log(&apos;hello world&apos;) &#125; &#125; // undefined/* 分别调用各属性和值 */company.name// &quot;世界你好&quot; company.age // 3 company.sayHello() //hello world 如图： 2、对象里属性值的获取写法：方法一： 1234console.log(company.name)//变量名.属性名 以此来调用值​``` 方法二： console.log(company[‘name’])//变量名[‘字符串’] 1错误写法： company[name]// undefined 1### 3、新增属性，直接赋值 company.addr = ‘杭州市’//“杭州市” / 验证：调用变量，输出：{属性：值} /company//{name: “世界你好”, age: 3, sayHello: ƒ, addr: “杭州市”} 1或者 company[‘business’] = ‘学习课程’//“学习课程” company// {name: “世界你好”, age: 3, sayHello: ƒ, addr: “杭州市”, business: “学习课程”} 12### 4、遍历对象里的属性和值使用： for(var 属性名 in 声明的变量）{console.log(key)console.log（company[key]）}//key进行遍历时，每一次循环这个变量key，都能调用key里的属性 1效果如下： for(var key in company){console.log(key)}// name// age// sayHello// addr// business// undefined 1而单个的属性名如何调用: company[key] === company[‘name’] 123# 三、具体使用### 1、键名：（1）键名是字符串（加不加引号都可以） var o = { ‘p’: ‘Hello World’}; 1（2）键名是数值，会被自动转为字符串 var o ={1: ‘a’,3.2: ‘b’,1e2: true,1e-2: true,.234: true,0xFF: true}; o// Object {// 1: “a”,// 3.2: “b”,// 100: true,// 0.01: true,// 0.234: true,// 255: true// } 1（3）键名不符合标识符条件：第一个字符为数字、含空格和运算符等，必须加上引号（否则报错），如： 1234567var o = &#123; &apos;1p&apos;: &quot;Hello World&quot;, &apos;h w&apos;: &quot;Hello World&quot;, &apos;p+q&apos;: &quot;Hello World&quot; &#125;;### 2、键名 === 属性如果属性值为函数 `===`方法，能像函数那样调用 var o = {p: function (x){return 2 * x;}};//p为函数 o.p(1)// 2 1234### 3、多个对象的属性，用逗号分隔（随意加不加）### 4、属性可以动态创建（不一定在对象声明时就指定）如：对`obj`对象的`foo`属性赋值，结果就在运行时创建了`foo`属性。 var obj = {};obj.foo = 123;obj.foo// 123 1234### 5、引用（1）对象的引用：A、不同的变量名指向同一个对象，那么它们（变量名）都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。o1和o2指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。 var o1 = {};var o2 = o1; o1.a = 1;o2.a // 1 o2.b = 2;o1.b // 2 1B、取消某一个变量对于原对象的引用，不会影响到另一个变量。 var o1 = {};var o2 = o1;o1 = 1;o2 // {} 1234（2）传值引用：不同变量名不对同一对象引用，第（1）种的引用只限于对象，对原始类型的数据则使用传值引用当x的值发生变化后，y的值并不变，这就表示y和x并不是指向同一个内存地址。 var x = 1; var y = x; x = 2; y // 1 1### 6、表达式 ？语句？ { foo: 123 } 1作为语句，可能是一个代码区块，里面有一个标签`foo`，指向表达式`123`。` === `如果行首是大括号，一律解释为语句（即代码块），如： / 假如没有赋值，js引擎默认为块语句 /{ foo:123 } ==={ label：123}–&gt;{foo: 123}-&gt;foo: 123-&gt;proto: Object 1作为表达式，可能是一个包含foo属性的对象`===`,如果要解释为表达式（即对象），必须在大括号前加上圆括号，如： ({ foo:123})//123 12**题外话：关于eval**（1）将字符串当做JS语句去执行 eval(‘console.log(123)’)// 123 123（2）`字符串 === 对象`：没有`圆括号 ===块语句===代码块` VS `圆括号===表达式===对象` eval(‘{foo: 123}’)// 123eval(‘({foo: 123})’)// {foo: 123} 123###7、检测变量是否声明（或被定义）可以在全局作用域中这样检测：（1）没有声明 ‘abc’ in window// false 1（2）有声明 var hello//undefined‘hello’ in window// true 123### 8、查看所有属性查看对象本身的所有属性，可用`Object.key`或使用`for...in`循环遍历。（1）方法一：`Object.keys` var o = {key1: 1,key2: 2}; Object.keys(o);//(2) [“key1”, “key2”] 1（2）方法二：`for...in循环遍历` var o = {key1: 1,key2: 2};for(var keys in o){console.log(keys)}// VM4390:6 key1// VM4390:6 key2 123456### 9、delete命令（1）删除一个存在的属性：两种情况：**A、只能删除属性** var o = {p: 1};Object.keys(o)// [“p”]delete o.p -&gt;o.pObject.keys(o)// [] 123**B、不能删除var命令声明的变量**var声明的全局变量都是顶层对象的属性，而且默认不得删除。 var p = 1;delete p // falsedelete window.p // false 12（2）删除一个不存在的属性delete不报错，而且返回true。不能根据delete命令的结果，认定某个属性是存在的，只能保证读取这个属性肯定得到`undefined`。 var o = {};delete o.p // true`]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对JavaScript吧！08原型和原型链]]></title>
    <url>%2F2018%2F12%2F08%2F%E9%9D%A2%E5%AF%B9JavaScript%E5%90%A7%EF%BC%8108%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[一、原型和原型链与大部分面向对象语言不同，JavaScript中并没有引入类（class）的概念，但JavaScript仍然大量地使用了对象，为了保证对象之间的联系，JavaScript引入了原型与原型链的概念。 在Java中，声明一个实例的写法是这样的： 1ClassName obj = new ClassName() 为了保证JavaScript“看起来像Java”，JavaScript中也加入了new操作符： 1var obj = new FunctionName() 可以看到，与Java不同的是，JavaScript中的new操作符后面跟的并非类名而是函数名，JavaScript并非通过类而是直接通过构造函数来创建实例。 12345678910function Dog(name, color) &#123; this.name = name this.color = color this.bark = () =&gt; &#123; console.log(&apos;wangwang~&apos;) &#125;&#125;const dog1 = new Dog(&apos;dog1&apos;, &apos;black&apos;)const dog2 = new Dog(&apos;dog2&apos;, &apos;white&apos;) 上述代码就是声明一个构造函数并通过构造函数创建实例的过程，这样看起来似乎有点面向对象的样子了，但实际上这种方法还存在一个很大的问题。 在上面的代码中，有两个实例被创建，它们有自己的名字、颜色，但它们的bark方法是一样的，而通过构造函数创建实例的时候，每创建一个实例，都需要重新创建这个方法，再把它添加到新的实例中。这无疑造成了很大的浪费，既然实例的方法都是一样的，为什么不把这个方法单独放到一个地方，并让所有的实例都可以访问到呢。 这里就需要用到原型（prototype）： 每一个构造函数都拥有一个prototype属性，这个属性指向一个对象，也就是原型对象。当使用这个构造函数创建实例的时候，prototype属性指向的原型对象就成为实例的原型对象。 原型对象默认拥有一个constructor属性，指向指向它的那个构造函数（也就是说构造函数和原型对象是互相指向的关系）。 每个对象都拥有一个隐藏的属性[[prototype]]，指向它的原型对象，这个属性可以通过 Object.getPrototypeOf(obj) 或 obj.__proto__ 来访问。 实际上，构造函数的prototype属性与它创建的实例对象的[[prototype]]属性指向的是同一个对象，即 对象.__proto__ === 函数.prototype 。 如上文所述，原型对象就是用来存放实例中共有的那部分属性。 在JavaScript中，所有的对象都是由它的原型对象继承而来，反之，所有的对象都可以作为原型对象存在。 访问对象的属性时，JavaScript会首先在对象自身的属性内查找，若没有找到，则会跳转到该对象的原型对象中查找。 那么可以将上述代码稍微做些修改，这里把bark方法放入Dog构造函数的原型中： 12345678function Dog(name, color) &#123; this.name = name this.color = color&#125;Dog.prototype.bark = () =&gt; &#123; console.log(&apos;wangwang~&apos;)&#125; 接着再次通过这个构造函数创建实例并调用它的bark方法： 12const dog1 = new Dog(&apos;dog1&apos;, &apos;black&apos;)dog1.bark() //&apos;wangwang~&apos; 可以看到bark方法能够正常被调用。这时再创建另一个实例并重写它的bark方法，然后再次分别调用两个实例的bark方法并观察结果： 123456const dog2 = new Dog(&apos;dog2&apos;, &apos;white&apos;)dog2.bark() = () =&gt; &#123; console.log(&apos;miaomiaomiao???&apos;)&#125;dog1.bark() //&apos;wangwang~&apos;dog2.bark() //&apos;miaomiaomiao???&apos; 这里dog2重写bark方法并没有对dog1造成影响，因为它重写bark方法的操作实际上是为自己添加了一个新的方法使原型中的bark方法被覆盖了，而并非直接修改了原型中的方法。若想要修改原型中的方法，需要通过构造函数的prototype属性： 12345Dog.prototype.bark = () =&gt; &#123; console.log(&apos;haha~&apos;)&#125;dog1.bark() //&apos;haha~&apos;dog2.bark() //&apos;haha~&apos; 这样看起来就没什么问题了，将实例中共有的属性放到原型对象中，让所有实例共享这部分属性。如果想要统一修改所有实例继承的属性，只需要直接修改原型对象中的属性即可。而且每个实例仍然可以重写原型中已经存在的属性来覆盖这个属性，并且不会影响到其他的实例。 原型链与继承上文提到，JavaScript中所有的对象都是由它的原型对象继承而来。而原型对象自身也是一个对象，它也有自己的原型对象，这样层层上溯，就形成了一个类似链表的结构，这就是原型链（prototype chain）。 所有原型链的终点都是Object函数的prototype属性，因为在JavaScript中的对象都默认由Object()构造。Objec.prototype指向的原型对象同样拥有原型，不过它的原型是null，而null则没有原型。 通过原型链就可以在JavaScript中实现继承，JavaScript中的继承相当灵活，有多种继承的实现方法，这里只介绍一种最常用的继承方法也就是组合继承。 123456789101112131415function Dog(name, color) &#123; this.name = name this.color = color&#125;Dog.prototype.bark = () =&gt; &#123; console.log(&apos;wangwang~&apos;)&#125;function Husky(name, color, weight) &#123; Dog.call(this, name, color) this.weight = weight&#125;Husky.prototype = new Dog() 这里声明了一个新的构造函数Husky，通过call方法继承Dog中的属性（call方法的作用可以简单理解为将Dog中的属性添加到Husky中，因为还涉及到其他的知识点所以不多赘述），并添加了一个weight属性。然后用Dog函数创建了一个实例作为Husky的原型对象赋值给Husky.prototype以继承方法。这样，通过Husky函数创建的实例就拥有了Dog中的属性和方法。 二、__proto__和prototype这是容易混淆的两个属性。__proto__指向当前对象的原型，prototype是函数才具有的属性，默认情况下，new 一个函数创建出的对象，其原型都指向这个函数的prototype属性。面试遇到的时候，也可以直接说前者是对象，后者是函数，两者指向同一个对象。 三、问题有如下代码： 123456789101112131415161718//代码1function People()&#123;&#125;var p = new People()p.__proto__ === People.prototype People.__proto__ === Function.prototypePeople.prototype.__proto__ === Object.prototype//代码2Function.prototype === Function.__proto__ Function.prototype === Object.__proto__ Function.prototype.__proto__ === Object.prototype Function instanceof Object//代码3Object instanceof FunctionFunction instanceof ObjectFunction instanceof FunctionObject instanceof Object 问题1：画出代码1的原型图？ 问题2：从代码2你能得出什么结论？试画出原型图？ 问题3：解释代码3的原因？ -———————————————————————— 解答： 在解答上面的问题之前，先记住下面几句话，这几句话能解释一切关于原型方面的问题： 当 new 一个函数的时候会创建一个对象，『函数.prototype』 等于 『被创建对象.proto』 一切函数都是由 Function 这个函数创建的，所以『Function.prototype === 被创建的函数.proto』 一切函数的原型对象都是由 Object 这个函数创建的，所以『Object.prototype === 一切函数.prototype.proto』 下面是代码1的原型图： （1）People函数创建了对象 p，所以People.prototype === p.proto； （2）Object函数创建了People.prototype对象，所以Object.prototype === People.prototype.proto； （3）People 作为对象的角色被函数Function创建，所以 Function.prototype === People.proto 下面是代码2的原型图： （1）任何函数都是 Function 创建，所以Function 创建了 Function，所以 Function.prototype === Function.proto； （2）Object 也是函数。所以Function创建了Object，所以 Function.prototype === Object.proto ； （3）Function.prototype 是普通对象，普通对象是由Object创建的，所以 Function.prototype.proto === Object.prototype 关于代码3： instanceof 的作用是判断一个对象是不是一个函数的实例。比如 obj instanceof fn， 实际上是判断fn的prototype是不是在obj的原型链上。比如: obj.proto === fn.prototype， obj.proto.proto === fn.prototype，obj.proto…_proto__ === fn.prototype，只要一个成立即可。 所以（根据图2来找） 对于 Function instanceof Function，因为 Function.proto === Function.prototype，所以为true。 对于 Object instanceof Object， 因为 Object.proto.proto === Function.prototype.proto === Object.prototype ， 所以为true 对于 Function instanceof Object, 因为 Function.proto.proto === Function.prototype.proto === Object.prototype， 所以为 true 对于 Object instanceof Function， 因为 Object.proto === Function.prototype，所以为 true 至此，问题全被完美解决。 参考文章：对原型、原型链、 Function、Object 的理解]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对JavaScript吧!07引用类型和深浅拷贝]]></title>
    <url>%2F2018%2F12%2F07%2F%E9%9D%A2%E5%AF%B9JavaScript%E5%90%A7%EF%BC%8107%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[一、基本类型VS引用类型注： 这里的内存，为虚拟内存 1、引用类型： 定义：保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象 包括：对象、数组、函数、正则 假设变量中有一个函数，函数内东西特别多（或者有一个对象，对象里的数据特别大），这里可选堆的空白处存放函数、对象的数据（随机选择未使用的空白堆，随意变大变小），放在堆中的均为引用类型 2、基本类型（值类型）： 定义：指的是保存在栈内存中的简单字段（成块排列，栈，允许放进去拿出来） 包括：数值(number)、布尔值(boolean)、null、undefined、string(在赋值传递中会以引用类型的方式来处理) 栈里面仍存有变量，只不过存放的不是数据，而是大数据地址，比如这个地址为0x0011,栈内存放的东西，均为可控、较小容量。从一个变量向另一个变量赋值基本类型时，会在该变量上创建一个新值，然后再把该值复制到为新变量分配的位置上。 3、实例一：基本类型12345678910111213141516171819 var a var b var obj var obj2 a = 1; b = 2; var obj = &#123; name: &apos;xiaoqin&apos;, sex: &apos;male&apos;, age: 30, friend: &#123; name: &apos;hello&apos;, age: 100 &#125; &#125; var newObj = &#123;&#125; b = a; console.log(b) //返回1 如图： （1）基本类型的值被赋值给另一个变量，其实就是分配内存空间一开始，a的值为 1 ，当使用a 来初始化b时，b值此时为1。但b中的1与a中的是完全独立的，该值只是a中的值的一个副本。说明在栈里变量再次变化，但这个两个变量可以参加任何操作而相互不受影响。 总结：一个变量赋值给另一个变量时，其实是分配了一块新的内存空间。按照以上操作，基本类型在赋值操作后，事实上就a分配了一块新内存空间给b，两个变量是相互不受影响。 （2）基本类型的比较是值的比较 只有在它们的值相等的时候它们才相等。 当比较的两个值的类型不同的时候==运算符会进行类型转换，但是当两个值的类型相同的时候，即使是==也相当于是===。 123var a = 1;var b = true;console.log(a == b);//true （3）基本类型的变量其实就是存放在栈区。结合以上，栈区指内存里的栈内存，但是栈区里包括了变量名和变量值。 4、实例二：（续上面的例子）引用类型（1）引用类型的值是可变的可为引用类型添加属性和方法，也可以删除其属性和方法。看一下这个例子：一个为引用类型的变量赋值给另一个为引用类型的变量 12345 var obj2 = obj //控制台测试一下二者的值 obj// &#123;name: &quot;ruoyu&quot;, sex: &quot;male&quot;, age: 30, friend: &#123;…&#125;&#125; obj2 // &#123;name: &quot;ruoyu&quot;, sex: &quot;male&quot;, age: 30, friend: &#123;…&#125;&#125; 值是一样的。因为var obj2=obj，即通过obj的值（一个对象）赋值给obj2，那么obj2的值就是赋值后原本obj对应属性和值。作为一个引用类型，它被放在堆中。所以寻找obj2则在堆里找到，只是换了另一个名字为obj2 如图： 总结：原本在栈中的对象分别指向了同一个堆，那么存放在堆中即为对象的内存地址。引用类型的赋值其实是对象保存在栈区地址指针的赋值，因此两个变量指向同一个对象，任何的操作都会相互影响。 （2）引用类型的比较是引用的比较A、我们先看一下基本类型值的比较： 1234var obj3 = &apos;&#123;name: &apos;hello&apos;&#125;&apos;; var obj4 = &apos;&#123;name: &apos;hello&apos;&#125;&apos;; console.log( obj3 == obj4 ); // true 总结：可以得出基本类型的比较：当两个比较值的类型相同(如字符串)的时候，相当于是用 === ，所以输出是true。 B、再来看一下引用类型值的比较： 1234var obj3 = &#123;name: &apos;hello&apos;&#125;var obj4 = &#123;name: &apos;hello&apos;&#125; obj3 === obj4 //返回false，说明二者并不相等 为什么是false？不相等呢？放在栈中的变量 obj3、obj4，声明前置均为undefined，当两者均被被声明值的时候，是两个对象，引用类型是引用访问，相当于在堆中分别开辟了两个空间，堆中会有对应的属性+值，此时这两个对象在堆中存的便是堆的地址。obj4与obj3一样都开辟了新的堆空间，但是存放的地址也不一样。判断obj3是否与obj4相等，看了分析之后，便知道堆存放的地址并不同，二者也就不相等 如图： （3）引用类型的值是同时保存在栈内存和堆内存中的对象 123456function sum()&#123; console.log(&apos;sum...&apos;) &#125; var sum2 = sum; sum2() //返回sum... 二者是相等的 我们可以就此分析，函数function sum(),分别有变量sum和函数对象代码（为引用类型，已放在堆中）。之后sum赋值给sum2，即sum2事实上使用的是赋值后sum所指代堆的内存地址,即后续sum和sum2共用了堆里的代码（变量的内存地址就像指针一样，通过JS自身引擎找到这个堆），一堆东西起了两个不同的名字 如图： 总结： js不同于其他语言，其不允许直接访问内存中的位置，即不能直接操作对象的内存空间，实际上，是操作对象的引用，所以引用类型的值是按引用访问的。 准确地说，引用类型的存储需内存的栈区（栈区是指内存里的栈内存）和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，然后，栈区内存地址也可以说是该对象在堆内存的地址。 二、引用类型的实际应用1、函数的参数传递第1个例子： 123456789101112131415161718192021function inc(n)&#123; n++; &#125; var a = 10; inc(a) console.log(a) //返回10 /*等同于*/ function inc()&#123; var n = arguments[0] n++ &#125; //在函数的一开始将var a = 10赋值进var n = arguments[0]， //n=arguments[0]=10,此时与n++为11并没有返回，所以与a并无关系 var a = 10 inc(a) console.log(a) //返回10 ✨第2个例子： 123456789101112131415 function incObj(obj)&#123; //var obj = o //0x0001 obj.n++ &#125; var o = &#123;n: 10&#125; //o = 0x0001 对其做声明，为一个对象 incObj(o) console.log(o) //等同于 function incObj()&#123; var obj =arguments[0] obj.n++ &#125; //incObj(o) 相当于function incObj()&#123;var obj =arguments[0]；obj.n++&#125;， //可知道obj=arguments[0]=o,相当于设obj为临时变量，而o= 0x0001 var o = &#123;n: 10&#125; incObj(o) console.log(o) 如图： 总结：引用类型的本质，变量所存的是这个对象的内存地址指向堆，当去做赋值时是把这个地址进行一个赋值；当去访问的时候是通过这个地址去访问这个对象 ✨第3个例子： 12345678910function squireArr( arr )&#123; //var arr = 0x0011 for(var i = 0; i &lt; arr.length; i++)&#123; arr[i] = arr[i] * arr[i]; &#125; &#125; var arr = [2,1,3,6] squireArr(arr) console.log(arr) //(4) [4, 1, 9, 36] 即把function squireArr(arr){}中的数组squireArr(arr)里的每一项变为原来的平方，即参数arr为数组里的值，用for循环进行操作，外界调用时，只需调用一次squireArr(arr)，事实上数组squireArr(arr)操作就是对arr的操作 ✨第4个例子： 12345678910111213 function squireArr2( arr )&#123; var newArr = []; for(var i = 0; i &lt; arr.length; i++)&#123; newArr[i] = arr[i] * arr[i]; &#125; return newArr; &#125; var arr2 = squireArr2(arr) console.log(arr2) //返回(4) [16, 1, 81, 1296] arr // (4) [4, 1, 9, 36] arr2 --&gt; (4) [16, 1, 81, 1296] 2、对象的深浅拷贝针对这个例子: 123456789101112 var obj; var obj2; var obj = &#123; name: &apos;ruoyu&apos;, sex: &apos;male&apos;, age: 30, friend: &#123; name: &apos;hello&apos;, age: 100 &#125; &#125; var obj2 = obj; 想要创造一个新的b，那么就需要遍历原始a的每一项属性+值，用来获取成为新个体的b所需的东西，并一一对b进行改造，即从一无所有，改造成与a相似的新个体，此为克隆。 如果在遍历的时候，b这个新个体只是遍历a的前半部分或者局部，那么这称之为浅拷贝，如： 123456789function shallowCopy(oldObj) &#123; var newObj = &#123;&#125;; for(var i in oldObj) &#123; if(oldObj.hasOwnProperty(i)) &#123; newObj[i] = oldObj[i]; &#125; &#125; return newObj; &#125; 而如果b是遍历原始a的每一项属性和值，但是b又是一个独立个体，与a不相关，当修改b的时候，a仍然不会发生变化，而这叫做深拷贝，如： 1234567891011function deepCopy(oldObj) &#123; var newObj = &#123;&#125;; for(var key in oldObj) &#123; if(typeof oldObj[key] === &apos;object&apos;) &#123; newObj[key] = deepCopy(oldObj[key]); &#125;else&#123; newObj[key] = oldObj[key]; &#125; &#125; return newObj; &#125; json——string——对象]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对JavaScript吧!06作用域和作用域链]]></title>
    <url>%2F2018%2F12%2F06%2F%E9%9D%A2%E5%AF%B9JavaScript%E5%90%A7%EF%BC%8106%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
    <content type="text"><![CDATA[一、什么是作用域1、先看一段简单代码:123456function fn() &#123; var a = &apos;miya&apos;; console.log(a); // 输出&quot;miya&quot; &#125; fn(); 在fn函数执行的时候，输出一个a变量，那么这个a变量是哪里来?有看到函数第一行有定义a变量的代码var a = &#39;miya&#39; 2、继续看另外一段代码：1234var b = &apos;programmer&apos;; function fn() &#123; console.log(b); // 输出&quot;programmer&quot; &#125; fn(); 同样，在输出b的时候，自己函数内部没有找到变量b，那么就在外层的全局中查找，找到了就停止查找并输出了。 3、那么，可以注意到以上两段代码都有查找变量。第一段代码是在函数中找到a变量，第二段代码是在全局中找到b变量。当然也要注意：javascript中{}`并没有带来块级作用域，如：123456&#123; var a=1 &#125; console.log(a) //1/*即使这样的定义，同样能输出：1*/ javascript的作用域是通过函数来形成，也就是说一个函数内定义的变量，函数外是不可以访问，如： 123456function fn()&#123; var a =1; &#125; //js编译器从此函数作用域出来之后，外界的变量函数或者声明变量均与之无关 fn(); console.log(a); /*&quot;ReferenceError: a is not defined&quot;说明在全局作用域中变量未被声明*/ 接下来，我们在函数、全局，两个概念名分别都加上作用域三个字，是不是又打开一个新世界了？ 关注细节的就知道，作用域，本质是一套规则，用于确定在何处以及如何查找变量（标识符）的规则。关键点在于：查找变量（标识符）。接下来让我们继续探索作用域链。 二、作用域链1、还是看刚才这段代码12345var b = &apos;programmer&apos;; function fn() &#123; console.log(b); // 输出&quot;programmer&quot; &#125; fn(); 一般来说，我们在查找b变量时，先在函数作用域中查找，没有找到，再去全局作用域中查找，你会注意到，这是一个往外层查找的过程，即顺着一条链条从下往上查找变量，这条链条，我们就称之为作用域链。 2、全局作用域，我们先从js页面中同时存在变量fn和变量a所处的位置来看在页面里所写的代码都是出于一个全局作用域下。全局作用域，相当于页面上有一个含有声明变量a或者函数fn的window对象，所声明的全局变量都是window对象下对应的一个属性。 还没有接触到ES6的let、const之前，只有函数作用域和全局作用域，函数作用域肯定是在全局作用域里面的，而函数作用域中又可以继续嵌套函数作用域，如： 三、从面试题解构作用域和作用域链1、解密原理： 每当执行完一块作用域里的函数后，它就进入一个新的作用域下（一般从下往上找） 当你使用一个变量或者给一个变量去赋值时，变量是从当前的作用域找，再从上层作用域（指当前这个函数所声明的作用域里）上找 2、具体如何运用解密原理（0）测试： 1var name = &apos;iceman&apos; 这段小小的js代码有其编译过程，经历了下面的步骤：A、编译器在当前作用域中声明一个变量nameB、运行时引擎在作用域中查找该变量，找到了变量name并为其赋值下面这道题则证明以上说法： 12console.log(name); // undefined var name = &apos;miya&apos;; 在 1234name编译器工作，是在代码执行前从上到下进行编译，当遇到某个用var声明变量时，先检查在当前作用域下是否存在了该变量。如果存在，则忽略这个声明；如果不存在，则在当前作用域中声明该变量。查找的规则：是从当前作用域开始找，如果没找到再到父级作用域中找，一层层往外找，如果在全局作用域如果还没找到的话，就会报错了： ReferenceError: 某变量 is not defined 1（1）第1题： var a = 1function fn1(){function fn2(){console.log(a)}function fn3(){var a = 4fn2()}var a = 2return fn3}var fn = fn1()fn() //输出多少 //a=2//执行fn2函数，fn2找不到变量a,接着往上在找到创建当前fn2所在的作用域fn1中找到a=2 1（2）第2题： var a = 1function fn1(){function fn3(){var a = 4fn2()}var a = 2return fn3}function fn2(){console.log(a)}var fn = fn1()fn() //输出多少 //a=1//最后执行fn2函数，fn2找不到变量a,接着往上在找到创建当前fn2所在的全局作用域中找到a=1 1（3）【重点】第3题： var a = 1function fn1(){function fn3(){function fn2(){console.log(a)}var afn2()a = 4}var a = 2return fn3}var fn = fn1()fn() //输出多少 //undefined//函数fn2在执行的过程中，先从自己内部找变量找不到，再从创建当前函数所在的作用域fn去找,注意此时变量声明前置，a已声明但未初始化为undefined 12345678事实上，我发现上一节函数中立刻执行的函数表达式本质上也可以感受一下局部作用域和全局作用域的区别。（4）再深入看几道网上的经典题，感受一下已经模糊的智商~😂（其实也还好啦~并没有对智商多大的撞击）在作用域链中查找过程的伪代码：**第1道题：** var x = 10bar()function foo() {console.log(x)}function bar(){var x = 30foo()} /第2行，bar（）调用bar函数第6行，bar函数里面调用foo函数第3行，foo函数从自己的局部环境里找x，结果没找到第1行，foo函数从上一级环境里找x，即从全局环境里找x，找到了var x=10。foo（）的输出结果为10。 / 1第2道题： var x = 10;bar()function bar(){var x = 30;function foo(){console.log(x)}foo();}/第2行，bar（）调用bar函数第3行，bar函数里面是foo函数foo函数在自己的局部环境里寻找x，没找到foo函数到自己的上一级环境，即bar函数的局部环境里找x，找到var x=30所以第2行的bar（）输出为30 / 1第3道题： var x = 10;bar()function bar(){var x = 30;(function (){console.log(x)})()}/第2行，bar（）调用bar函数第三行，bar函数里的function（）在自己的局部环境里寻找x，但没找到function（）在上级环境即bar的局部环境里寻找x，找到var x=30，于是显示结果为30 /`]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对JavaScript吧!05声明提前和立即执行函数]]></title>
    <url>%2F2018%2F12%2F05%2F%E9%9D%A2%E5%AF%B9JavaScript%E5%90%A7%EF%BC%8105%E5%A3%B0%E6%98%8E%E6%8F%90%E5%89%8D%E5%92%8C%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、声明提前1、变量声明提前——变量提升1234//先输出a,再声明var a=3 console.log(a) //undefined var a=3 再如： 123console.log(a)//undefined console.log(b) //报错 var a=3 为什么console.log(a)输出undefined，而console.log(b) 则会报错呢？出现这样的情况是为什么？实际上JS引擎在一行行执行代码的时候，有一些默认的运行我们并不知道，即： 123var a //undefined,变量a已经前置声明，则结果为undefined console.log（a） //undefined console.log（b） //报错，没有变量b，引用失败 a=3 最后是：变量的声明前置的完整运行： 12345var a //undefined,已经前置声明为undefined console.log(a) //undefined a=3 console.log(a) --&gt; undefined 3 2、函数的声明前置先看这段代码： 1234sum(5,3) //放在任何的地方，但是只是一个函数值，并没有打印这个函数出来function sum(a,b)&#123; return a+b&#125; 设置两种看两种执行结果： 看代码，不是没有任何的变量声明？为什么就可以使用函数输出结果？这是因为函数所执行的JS引擎默认操作与变量声明前置机制是类似。相当于：包含变量数据的function函数前置，即以上代码等同于 12345function sum(a,b)&#123; return a+b &#125; sum(5,3) //直接返回8 3、函数表达式的声明前置还是先看代码： 12345fn()var fn = function()&#123; console.log(&apos;fn...&apos;)&#125;//报错，直接说fn不是一个函数 这里，function函数是一个变量，相当于把一个数字赋值给fn，而这个function函数表达式，事实上也是有一个声明前置的，即： 12345var fn //undefined fn() //此为函数，会执行，但是如果是undefined(),这种是不成立，即报错 fn = function()&#123; console.log(&apos;fn...&apos;) &#125; 那么原始代码是怎么执行的？原始代码： 12345678fn() sum(3,4) var fn = function()&#123; console.log(&apos;fn...&apos;) &#125; function sum(a,b)&#123; return a+b &#125; 对于浏览器来说它做了什么：一个声明前置：包括变量声明前置和函数声明前置 12345678var fn //变量声明前置 function sum(a,b)&#123; return a+b &#125; //函数声明前置 fn() sum(3,4) fn = function()&#123; console.log(&apos;fn...&apos;) &#125; 二、立刻执行的函数表达式注：关于js的语法规则如何体现？ 1、先看下面这个代码12 (function()&#123; console.log(&apos;wangxiaoqin&apos;) &#125;)() --&gt;&quot;wangxiaoqin&quot; 先暂且不管它的结果如何产生。先了解一下JS的语法规则 按照这样写，为何只有function(){}单独作为一个变量时，通过模仿语句a( );，function(){}();这个语句则会操作会报错，这是为什么？ 对于JS引擎来说不认为是一个表达式，很像一个函数声明，再加一个括号，即会报错。那么如何让这个语句正常赋值？直接将整个函数声明加一个括号，即： 1(function()&#123;&#125;)() 由于作为运算符，括号和括号里的内容组合为一个表达式。加上括号之后，会让JS引擎认为它是一个表达式（或引用类型），那么就符合了JS的语法规则。 总结：当在一个函数声明后加了圆括号（也是一种运算符）后运行的话，会报错。因为这被认为是语法错误。在JS中，以function开头会被认为是语句，而语句不应该以圆括号结尾。所以此时可以选用的解决办法是把整个语句用圆括号包起来。 2、那么刚才列举的代码：123456789(function()&#123; console.log(&apos;wangxiaoqin&apos;) &#125;)() --&gt;&quot;wangxiaoqin&quot; //即函数表达式，立刻去执行它 //等同于 var fn = function()&#123; &#125; fn() 这类型的函数表达式有什么用？这里涉及了函数中所对应的作用域的概念，假设我们在这类函数里添加一个变量 123456 (function()&#123; var a =3 console.log(&apos;wangxiaoqin&apos;) &#125;)() console.log(a)//运行，后台报错，a是没有被定义的。 //因为a变量是不被看到的，因为a在function函数的这个作用域里，与外界无关 3、立刻执行函数的好处：1var fn=function()&#123;&#125; 相当于 1fn()===(函数表达式)() 12345678910作为一种运算符，用这种局部作用域的方式将函数引用包裹起来，形成一个立即执行的表达式，好处在于：A、函数不必再另外命名，避免污染全局，不会在复杂页面协作中造成错乱；B、实现一个作用域隔离，封装外部无法读取的私有变量;C、避免命名冲突，符合js语法规则，并立刻执行。# 三、命名冲突当在同一个作用域内定义了名字相同的变量和方法的话，会根据前置顺序产生覆盖 var fn = 3;function fn(){}console.log(fn);// 3 1相当于 var fn function fn(){} //覆盖上面的 fn = 3 //重新赋值 console.log(fn) //为函数 1当函数执行有命名冲突的时候，可以认为在还是内部一开始有隐藏的声明变量这个操作 function fn(fn){console.log(fn);var fn = 3;console.log(fn);}fn(10) //10 3 //等同于有一个默认的var fn = arguments[0]的操作 function fn(){var fn = arguments[0] //1、将它先声明前置，再赋值，再输出console.log(fn);var fn = 3; //2、再赋值console.log(fn);} fn(10) //10 3`]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础面试题（附答案）]]></title>
    <url>%2F2018%2F12%2F05%2FHTML%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E9%99%84%E7%AD%94%E6%A1%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.DOCTYPE有什么作用？标准模式与混杂模式如何区分？它们有何意义?（1）&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 标签之前。告诉浏览器的解析器，用什么文档类型规范来解析这个文档。 （2）严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。（3）在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 （4）DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 （5）加入XMl声明可触发，解析方式更改为IE5.5 拥有IE5.5的bug 2.HTML5为什么只需要写 &lt;!DOCTYPE HTML&gt;？HTML5不基于SGML，因此不需要对DTD进行引用，但是需要DOCTYPE来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；HTML4.01基于SGML，所以需要对DTD进行引用，才能让浏览器知道该文档所使用的文档类型。 3.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？CSS的盒模型?声明：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。 1234（1）行内元素有：a b span img input select strong（强调的语气）（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p（3）常见的空元素：&lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; &lt;br&gt; 鲜为人知的空元素： &lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt; 4.CSS引入的方式有哪些? 页面导入样式时，使用link和@import有什么区别？内联, 内嵌 ,外链, 导入。 link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; 5.无样式内容闪烁（FOUC）Flash of Unstyle Content@import导入CSS文件会等到文档加载完后再加载CSS样式表。因此，在页面DOM加载完成到CSS导入完成之间会有一段时间页面上的内容是没有样式的。 解决方法：使用link标签加载CSS样式文件。因为link是顺序加载的，这样页面会等到CSS下载完之后再下载HTML文件，这样先布局好，就不会出现FOUC问题。 6.介绍一下你对浏览器内核的理解？主要分成两部分：渲染引擎(Layout Engine或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。JS引擎：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 7.常见的浏览器内核有哪些？Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等。 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）] EdgeHTML内核：Microsoft Edge。 [此内核其实是从MSHTML fork而来，删掉了几乎所有的IE私有特性] 8.HTML5有哪些新特性,移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分HTML和HTML5？新增加了图像、位置、存储、多任务等功能。新增元素： canvas 用于媒介回放的video和audio元素 本地离线存储。localStorage长期存储数据，浏览器关闭后数据不丢失;sessionStorage的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article footer header nav section 位置API：Geolocation 表单控件，calendar date time email url search 新的技术：web worker(web worker是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行) web socket 拖放API：drag、drop 移除的元素： 纯表现的元素：basefont big center font s strike tt u 性能较差元素：frame frameset noframes 区分： DOCTYPE声明的方式是区分重要因素 根据新增加的结构、功能来区分 9.什么是语义化的HTML，语义化的作用是什么？语义化的HTML就是写出的HTML代码，符合内容的结构化（内容语义化），选择合适的标签（代码语义化），能够便于开发者阅读和写出更规范性代码的同时让浏览器的爬虫和机器很好地解析。 作用： a.有利于SEO，有利于搜索引擎爬虫更好的理解我们的网页，从而获取更多的有效信息，提升网页的权重。 b.在没有CSS的时候能够清晰的看出网页的结构，增强可读性。 c.便于团队开发和维护，语义化的HTML可以让开发者更容易的看明白，从而提高团队的效率和协调能力。 d.支持多终端设备的浏览器渲染。 10.HTML5的文件离线储存怎么使用，工作原理是什么？浏览器是怎么对HTML5的离线存储资源进行管理和加载的？在线情况下，浏览器发现HTML头部有manifest属性，它会请求manifest文件，如果是第一次访问，那么浏览器就会根据manifest文件的内容下载相应的资源，并进行离线存储。如果已经访问过并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面。然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不会做任何操作，如果文件改变了，那么就会重新下载文件中的资源，并且进行离线存储。例如， 在页面头部加入manifest属性 1&lt;html manifest=&apos;cache.manifest&apos;&gt; 在cache.manifest文件中编写离线存储的资源 123456789CACHE MANIFEST#v0.11CACHE:js/app.jscss/style.cssNETWORK:Resourse/logo.pngFALLBACK: //offline.html 在离线状态时，操作 window.applicationCache 进行需求实现。在线情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 11.cookies，sessionStorage和localStorage的区别？共同点：都是保存在浏览器端，且是同源的。 区别： cookies是为了标识用户身份而存储在用户本地终端上的数据，始终在同源http请求中携带，即cookies在浏览器和服务器间来回传递，而sessionstorage和localstorage不会自动把数据发给服务器，仅在本地保存。 存储大小的限制不同。cookie保存的数据很小，不能超过4k，而sessionstorage和localstorage保存的数据大，可达到5M。 数据的有效期不同。cookie在设置的cookie过期时间之前一直有效，即使窗口或者浏览器关闭。sessionstorage仅在浏览器窗口关闭之前有效。localstorage始终有效，窗口和浏览器关闭也一直保存，用作长久数据保存。 作用域不同。cookie在所有的同源窗口都是共享；sessionstorage不在不同的浏览器共享，即使同一页面；localstorage在所有同源窗口都是共享 12.iframe框架有那些优缺点？优点： iframe能够原封不动的把嵌入的网页展现出来。 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 缺点： iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO； iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好通过JavaScript动态给iframe添加src属性值，这样可以绕开以上两个问题。 13.label的作用是什么? 是怎么用的?label标签用来定义表单控件间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。label 中有两个属性是非常有用的, FOR和ACCESSKEY。FOR属性功能：表示label标签要绑定的HTML元素，你点击这个标签的时候，所绑定的元素将获取焦点。例如， 1&lt;Label FOR=&quot;InputBox&quot;&gt;姓名&lt;/Label&gt;&lt;input ID=&quot;InputBox&quot; type=&quot;text&quot;&gt; ACCESSKEY属性功能：表示访问label标签所绑定的元素的热键，当您按下热键，所绑定的元素将获取焦点。例如， 1&lt;Label FOR=&quot;InputBox&quot; ACCESSKEY＝&quot;N&quot;&gt;姓名&lt;/Label&gt;&lt;input ID=&quot;InputBox&quot; type=&quot;text&quot;&gt; 14.HTML5的form如何关闭自动完成功能？HTML的输入框可以拥有自动完成的功能，当你往输入框输入内容的时候，浏览器会从你以前的同名输入框的历史记录中查找出类似的内容并列在输入框下面，这样就不用全部输入进去了，直接选择列表中的项目就可以了。但有时候我们希望关闭输入框的自动完成功能，例如当用户输入内容的时候，我们希望使用AJAX技术从数据库搜索并列举而不是在用户的历史记录中搜索。 方法： 在IE的internet选项菜单中里的自动完成里面设置 设置form输入框的autocomplete为on或者off来来开启输入框的自动完成功能 15.如何实现浏览器内多个标签页之间的通信? WebSocket SharedWorker 也可以调用 localstorge、cookies 等本地存储方式。 localstorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。 ​ 注意：Safari 在无痕模式下设置 localstorge 值时会抛出QuotaExceededError 的异常 16.webSocket如何兼容低浏览器？ Adobe Flash Socket ActiveX HTMLFile (IE) 基于 multipart 编码发送 XHR 基于长轮询的 XHR 引用WebSocket.js这个文件来兼容低版本浏览器。 17.页面可见性（Page Visibility）API 可以有哪些用途？ 通过visibility state的值得检测页面当前是否可见，以及打开网页的时间。 在页面被切换到其他后台进程时，自动暂停音乐或视频的播放。 18.如何在页面上实现一个圆形的可点击区域？ map+area或者svg border-radius 纯js实现，一个点不在圆上的算法 19.实现不使用 border 画出1px高的线，在不同浏览器的Quirks mode和CSS Compat模式下都能保持同一效果1&lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt; 20.网页验证码是干嘛的，是为了解决什么安全问题？ 区分用户是计算机还是人的程序; 可以防止恶意破解密码、刷票、论坛灌水； 21.title与h1的区别、b与strong的区别、i与em的区别？title属性没有明确意义，只表示标题；h1表示层次明确的标题，对页面信息的抓取也有很大的影响strong标明重点内容，语气加强含义；b是无意义的视觉表示em表示强调文本；i是斜体，是无意义的视觉表示视觉样式标签：b i u s语义样式标签：strong em ins del code 22.元素的alt和title有什么异同？在alt和title同时设置的时候，alt作为图片的替代文字出现，title是图片的解释文字。23.xhtml和html有什么区别? 区别是： XHTML 元素必须被正确地嵌套。 XHTML 元素必须被关闭。 标签名必须用小写字母。 XHTML 文档必须拥有根元素。 23.对WEB标准以及W3C的理解与认识？标签闭合、标签小写、不乱嵌套、提高搜索引擎、使用外链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性. 24.前端页面有哪三层构成，分别是什么?作用是什么?Hnml结构层，css表示层，js行为层 作用是：实现分离。使用html去创建文档的结构，使用css去设置文档的呈现效果，使用js脚本去实现文档的行为。 25.CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?标签选择符 类选择符 id选择符 继承不如指定 Id&gt;class&gt;标签选择 后者优先级高 26.css的基本语句构成是?选择器{属性1:值1;属性2:值2;……} 27.写出几种IE6 BUG的解决方法a.双边距BUG float引起的 使用display b.像素问题 使用float引起的 使用dislpay:inline -3px c.超链接hover 点击后失效 使用正确的书写顺序 link visited hover active d.Ie z-index问题 给父级添加position:relative e.Png 透明 使用js代码 改 f.Min-height 最小高度 ！Important 解决’ g.select 在ie6下遮盖 使用iframe嵌套 h.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px） 28.浏览器标准模式和怪异模式之间的区别是什么?盒子模型 渲染模式的不同 使用 window.top.document.compatMode 可显示为什么模式 29.你如何对网站的文件和资源进行优化?期待的解决方案包括：文件合并 文件最小化/文件压缩 使用CDN托管 缓存的使用 30.描述css reset的作用和用途。Reset重置浏览器的css默认属性 浏览器的品种不同，样式不同，然后重置，让他们统一. 31.解释css sprites，如何使用。Css 精灵 把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量. 32.清除浮动的几种方式，各自的优缺点?a使用空标签清除浮动 clear:both（理论上能清除任何标签，增加无意义的标签） b.使用overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE） c.是用afert伪元素清除浮动(用于非IE浏览器 33.浏览器标准模式和怪异模式之间的区别是什么?盒子模型 渲染模式的不同 使用 window.top.document.compatMode 可显示为什么模式 34.如何优化代码？​ a.代码重用 ​ b.避免全局变量（命名空间，封闭空间，模块化mvc..） ​ c.拆分函数避免函数过于臃肿 ​ d.注释 ​ e.代码压缩 ​ f.减少http请求 ​ g.图片css sprite 35.什么是媒体查询，如何使用？媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成。媒体查询中可用于检测的媒体特性有 width 、 height 和 color （等）。使用媒体查询，可以在不改变页面内容的情况下，为特定的一些输出设备定制显示效果。 一，首先需要在html文档中添加以下代码，用来兼容移动设备的显示效果 123456789&lt;meta name=&quot;viewport content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot;/&gt;注意：width=device-width:宽度等于当前设备的宽度initial-scale=1：初始的缩放比例（默认为1）maximum-scale=1：允许用户缩放到得最大比例（默认为1）user-scalable=no：用户不能手动缩放 二，在CSS文件中写CSS响应式媒体查询 例: 123456789@media screen and (max-width:720px) and (min-width:320px)&#123; body&#123;​ background-color:red;​ &#125;@media screen and (max-width:320px)&#123; body&#123;​ background-color:blue; &#125;&#125; 该段媒体查询的意思是：当设备屏幕宽度在320px——720px之间时，媒体查询中body的背景色（background-color:red;）会重叠之前的body背景色，当设备屏幕宽度在320px以下时，媒体查询中body的body背景色（background-color:blue;）会重叠之前的body背景色 怎么样才能做到屏幕适配？ 需要用的是： meta viewport 中有6个通用属性： 1）width 设置layout viewport的宽度 正整数或字符串 ‘width-device’ 2）initial-scale 设置页面的初始缩放值，数字或小数 3）minimum-scale 允许用户的最小缩放值 数字或小数 4）maximum-scale 允许用户的最大缩放值 数字或小数 5）height 设置layout viewport 的高度，这个属性很少用到 6）user-scaleabel 是否允许用户进行缩放 ‘no’或‘yes’ 还有2个需要特别注意的两个属性 7）target-densitydpi 在andriod 4.0一下的设备中，不支持设置viewport的width，android 自带浏览器支持设置 target-densitydpi来达到目的； 36.请说出三种减低页面加载时间的方法a、压缩css、js文件 b、合并js、css文件，减少http请求 c、外部js、css文件放在最底下 d、减少dom操作，尽可能用变量替代不必要的dom操作 37.http和https有什么区别?​ 在URL前加https://前缀表明是用SSL加密的。 你的电脑与服务器之间收发的信息传输将更加安全。 Web服务器启用SSL需要获得一个服务器证书并将该证书与要使用SSL的服务器绑定。​ http和https使用的是完全不同的连接方式,用的端口也不一样,前者是80,后者是443。​ http的连接很简单,是无状态的,…​ HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全 38.浏览器缓存有几种，有什么区别？ 网站后台缓存 是网站程序产生的一些临时文件，如PHP程序最喜欢。这个文件一般是在网站程序目录。​ 服务器缓存是服务器为了提升速度而产生的一些临时文件，如gzip的文件，一般是防在特定的目录。​ 浏览器缓存是用户本地浏览器缓存的网页文件，比如我们第一次打开一个网站速度会慢一些，第二次打开就很快，就是缓存在了本地。 39.有做过页面性能优化么？如何做的？​ 把样式表置于顶部​ 把脚本置于页面底部​ 避免使用 CSS 表达式（Expression）​ 使用外部 JavaScript 和 CSS​ 削减 JavaScript 和 CSS​ 用 代替 @import​ 避免使用滤镜​ 剔除重复脚本​ 减少DOM访问​ 开发智能事件处理程序​ Coockie:​ 减小Cookie体积​ 对于页面内容使用无coockie域名​ 图片：​ 优化图像​ 优化CSS Spirite​ 不要在HTML中缩放图像​ favicon.ico要小而且可缓存 40.XML和JSON的区别？(1).数据体积方面。 JSON相对于XML来讲，数据的体积小，传递的速度更快些。 (2).数据交互方面。 JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。 (3).数据描述方面。 JSON对数据的描述性比XML较差。 (4).传输速度方面。 JSON的速度要远远快于XML。 41.CSS3有哪些新特性？CSS3实现圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform），transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜，增加了更多的CSS选择器 多背景 rgba，在CSS3中唯一引入的伪元素是::selection.，媒体查询，多栏布局，border-image 未完待续，不定期更新…]]></content>
      <categories>
        <category>面试题</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对JavaScript吧!04函数]]></title>
    <url>%2F2018%2F12%2F04%2F%E9%9D%A2%E5%AF%B9JavaScript%E5%90%A7%EF%BC%8104%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、函数的使用1、什么是语句：先看这几个概念表达式： 12a=1 a+btypeof 语句：代表一定功能的表达式的组合 1a+b; 2、但是特定功能需要几条语句实现，太复杂123statement1; statement2; statement3; 那么，可以将语句打包成一个函数，然后调用这个函数即可，如： 1function doSomething()&#123; statement1; statement2; statement3; &#125; 调用这个函数。调用函数通过函数名称( )的形式调用 1doSomething(); //需要的时候就调用 实例： 12345678function sum()&#123; console.log(&apos;hello&apos;) console.log(&apos;wangxiaoqin&apos;) &#125; sum() //返回//&quot;hello&quot; //&quot;wangxiaoqin&quot;` 二、函数的五种声明方式1、具名函数1234function f(x,y)&#123; return x+y &#125; f.name // &apos;f&apos; 2、具名函数12345var ff = function(x,y)&#123; return x+y&#125;f.name // &apos;f&apos; 3、具名函数赋值1234var f f = function f2(x,y)&#123; return x+y &#125; f.name // &apos;f2&apos; console.log(f2) // undefined 4、window.Function12var f = new Function(&apos;x&apos;,&apos;y&apos;,&apos;return x+y&apos;) f.name // &quot;anonymous&quot; 5、箭头函数12345var f = (x,y) =&gt; &#123; return x+y &#125; var sum = (x,y) =&gt; x+y var n2 = n =&gt; n*n 三、参数1、只使用定义函数较为僵化，可通过参数方式让函数调用、复用。举例说明： 123456789101112131415161718192021222324 function printName(name)&#123; //括号中的name为函数的参数 console.log(name) &#125; printName(&apos;hunger&apos;) printName(&apos;valley) //等同于在函数设置变量 function printName()&#123; //括号为空括号 var name = arguments[0] console.log(name); &#125; printName(&apos;hunger&apos;); //假设没有传递参数 function printName()&#123; //括号为空括号 var name = arguments[0] console.log(name); &#125; printName(); //arguments[0] 为undefined，name=undefined ,那么结果为undefined //函数在定义的时候可以写多个参数 function printPersonInfo(name, age, sex)&#123; console.log(name) console.log(age) console.log(sex) &#125; 2、Arguments传参数通过函数内部的arguments对象获取到该函数的所有传入参数（按顺序传入），通过 1console.log(arguments) //输出每一个参数的值 即： 12function printPersonInfo(name, age, sex)&#123; console.log(name) console.log(age) console.log(sex) console.log(arguments) 即：console.log(arguments[0]===name) console.log(arguments.length) console.log(arguments[1] === age) &#125; 3、实例例1： 例2： 例3： 1234567891011function getInfo(name, age, sex)&#123; console.log(&apos;name:&apos;,name); console.log(&apos;age:&apos;, age); console.log(&apos;sex:&apos;, sex); console.log(arguments); arguments[0] = &apos;valley&apos;; console.log(&apos;name&apos;, name); &#125; getInfo(&apos;小明&apos;, 2, &apos;男&apos;); getInfo(&apos;小小明&apos;, 3); getInfo(&apos;男&apos;); 即： 1234567891011121314151617181920function getInfo(name, age, sex)&#123; console.log(&apos;name:&apos;,name); console.log(&apos;age:&apos;, age); console.log(&apos;sex:&apos;, sex); console.log(arguments); arguments[0] = &apos;valley&apos;; console.log(&apos;name&apos;, name); &#125; getInfo(&apos;小明&apos;, 2, &apos;男&apos;); 传递的参数：最终获得的值name:小明 //函数内部对参数无赋值，所以选择输入的值。 age: 2 //理由同上 sex: 男 //理由同上 0:valley //console.log(arguments)表示输出每一个参数的值。 于是先读取getInfo函数自己的局部环境，读取到了valley。于是显示valley。 1: 2 //先读取getInfo函数自己的局部环境，没读取到值。于是向上找，找到了输入的值2。 3: 男 //理由同上 name: valley //在getInfo函数的局部环境里向上读取，在上方发现了name赋值，所以显示valley。 123456789101112131415161718192021222324252627282930function getInfo(name, age, sex)&#123; console.log(&apos;name:&apos;,name); console.log(&apos;age:&apos;, age); console.log(&apos;sex:&apos;, sex); console.log(arguments); arguments[0] = &apos;valley&apos;; console.log(&apos;name&apos;, name); &#125; getInfo(&apos;小小明&apos;, 3); name: 小小明 //函数内部对参数无赋值，所以选择输入的值。 age: 3 //理由同上。 sex: undefined //第三个参数没有输入，所以显示undefined。 0: valley //console.log(arguments)表示输出每一个参数的值。于是先读取getInfo函数自己的局部环境， //读取到了valley。于是显示valley。 1: 3 //函数内部对参数无赋值，所以选择输入的值。 name: valley //在函数局部环境内向上读取发现已经对name赋值，所以显示valley。function getInfo(name, age, sex)&#123; console.log(&apos;name:&apos;,name); console.log(&apos;age:&apos;, age); console.log(&apos;sex:&apos;, sex); console.log(arguments); arguments[0] = &apos;valley&apos;; console.log(&apos;name&apos;, name); \ &#125; getInfo(&apos;男&apos;); name: 男 //在自己的局部环境的上方没有读取到值，所以向上一级读取，显示为男。age:undefined //整个环境内都没有赋值，所以显示为undefined sex:undefined //整个环境内都没有赋值，所以显示为undefined 0: valley //console.log(arguments)表示输出每一个参数的值。于是先读取getInfo函数自己的局部环境， 读取到了valley。于是显示valley。name:valley //在函数局部环境内向上读取发现已经对name赋值，所以显示valley。 题外话：函数是有参数的，在声明函数的时候可以在定义的函数旁加一个参数，当你要执行的时候，需要调用带有该参数的函数，如果没有传递这个参数的话，相当于这个带有参数的函数结果就为：undefined如： 1234567function printName()&#123; var name = arguments[0] console.log(name); &#125; printName() --&gt;输出：undefined 图： 5、函数返回值函数，即把一段语句包装起来，调用函数的参数的时候，就会执行这些语句，更多的是得到一些结果。就像表达式给一个结果，希望函数执行后给一个反馈，我们可以通过return来实现如: 12345function sum(a,b,c)&#123; console.log(a+b) //只是把计算的结果展示在控制台，无其他事（用户若不打开控制台无意义） return a+b &#125; var result = sum(4,6) console.log(result) //返回10 假设：没有return，会出现什么结果呢？ 以上结果以说明，console.log(a+b)，输出10，只是把计算结果呈现在控制台，表示它做了这件事情，只不过没有把结果返回。但是console.log(a+b)本身也是一个函数，整个函数本质上执行的结果为undefined，调用result，结果也是undefined ❌错误写法： 1234567function sum(a,b,c)&#123; return console.log(a+b) &#125; var result = sum(4,6) console.log(result) //返回10 //undefined 但是有这样的写法： 12345678910111213141516171819202122232425 function fn(score)&#123; if(score&lt;0) return console.log(score) &#125; fn(-3) //等同于 function fn(score)&#123; if(score&lt;0) &#123; return undefined &#125; console.log(score) &#125; fn(-3) //等同于 function fn(score)&#123; if(score&lt;0) &#123; &#125; else&#123; console.log(score) &#125; &#125; fn(-3) 四、重载1、什么是函数重载重载是很多面向对象语言实现多态的手段之一，在静态语言中确定一个函数的手段是靠方法签名——函数名+参数列表，也就是说相同名字的函数参数个数不同或者顺序不同都被认为是不同的函数，称为函数重载。 2、JS没有函数重载在JavaScript中没有函数重载的概念，函数通过名字确定唯一性，参数不同也被认为是相同的函数，后面的覆盖前面。函数调用没必要把所有参数都传入，只要你函数体内做好处理就行，但前提是传的参数永远被当做前几个传递不同的参数，做不同的事情，根据函数中参数类型和个数去进行逻辑判断。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对JavaScript吧!03流程控制判断]]></title>
    <url>%2F2018%2F12%2F03%2F%E9%9D%A2%E5%AF%B9JavaScript%E5%90%A7%EF%BC%8103%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[一、if语句if语句是编程语言最常用的语句， 1、语法：12345if(condition)&#123; //true statement &#125;else &#123; //false statement &#125; 其中condition可以是任意表达式，结果不一定是布尔值，JavaScript解释器会自动调用Boolean()将表达式结果转为布尔值，如果表达式为真，执行第一个代码块内语句；如果为假，执行第二个代码块内语句 if语句可以单独使用，也可以和多个else连续使用 123456789101112/* 满足这些条件做对应的事情*/ if(a &gt; 2)&#123; // statement &#125; if( a == 1)&#123; &#125;else if(a == 2)&#123; &#125;else if(a == 3 )&#123; &#125;else&#123; &#125; 2、例子:1234567var a = 1 if(a === 1)&#123; console.log(&apos;ok&apos;) &#125;else&#123; console.log(&apos;not ok&apos;) &#125; ---&gt;&quot;ok&quot; 二、switch语句注： JavaScript switch语句虽然参考的C语言的写法，但是有特殊性 switch和case可以使用任意表达式，不一定是常量 switch语句进行比较的时候是全等于（===）操作，不会发生类型转换 1、语法：12345678910switch(expresstion)&#123; case value1: //该条件：（满足）这个值 statement; //则执行该语句 break; //强制输出 case value2: statement; break; default: statement; &#125; 2、例子： 123456789var score =prompt(&apos;请输入分数&apos;) switch (score)&#123; case 100: console.log(&apos;100分&apos;) break; case 99: consolelog(&apos;99分&apos;) break; default: console.log(&apos;其他分数&apos;) &#125; --&gt;可弹出一个表单输入框输入分数 题外话：break，如果表达式等于case的值，对应的语句就会执行，break关键字会使程序跳出switch语句，很多编程规范强调必须添加break，不添加不会有语法错误，程序会多次判断case，进入相应流程。 当没有一个值符合case或者没有break，流程则进入default子句，很多规范也强调必须添加default部分 break VS continuebreak关键字在switch语句中已经见过，这两个关键字多用在循环语句中 break 用于强制退出循环体，执行循环后面的语句 continue 用于退出本次循环，执行下次循环 例子： break 12345for(var i = 1; i&lt; 10; //第一步 i++ //第三步（2）（如果不符合函数：i % 4 === 0，继续循环）)&#123; if(i % 4 === 0)&#123; break; &#125;//第二步 console.log(i); //第三步（1）（如果符合函数：i % 4 === 0，输出相应值，；如果不符合， 输出当值，继续执行第三步（2）） &#125; continue 12345for(var i = 1; i&lt; 10; i++)&#123; if(i % 4 === 0)&#123; continue; //如果符合函数条件：i % 4 === 0，那么则直接退出本循环，不输出（跳过） 此次结果，继续执行i&lt; 10这个条件的循环 &#125; console.log(i); &#125; 三、循环语句：while和do-while1、while循环 先条件判断，后执行 while 语句，属于前测试循环语句，也就是在循环体内的代码被执行之前，就会对条件求值，不符合的话就不会执行（1）语法： 123while(expression)&#123; statement; &#125; （2）例子： 1234var i = 10; while(i &gt; 0)&#123; console.log(i); i--; &#125; 2、do-while循环 先执行，后条件判断 do-while是后测试循环语句，在出口条件判断之前就会执行一次代码语法： 123 do&#123; statement;&#125;while(expression); 例子： 12345var i = 4; do&#123; console.log(i); i--; &#125;while(i &gt; 5); --&gt;4 3、for循环（1）for语句，前测试循环语句。具备在执行循环代码以前初始化变量和定义循环后要执行代码的能力，改造一下while语句A、语法： 123for(var i = 10; i &gt; 0;//第一步 i-- //第三步)&#123; console.log(i);//第二步 &#125; （2）for-in语句for-in是一种迭代语句，用于枚举对象的属性A、语法： 123 for(property in object)&#123; statement &#125; B、例子： 123for(var prop in window)&#123; console.log(prop); &#125; 因为ECMAScript规定对象中的属性没有顺序，所以for-in遍历出来的属性的顺序也不是固定的（虽然大部分浏览器是按属性名称排序，我们不能依赖这个） 四、label语句label语句是很多熟练的jser都会忽略的知识，我们可以为代码添加标签，方便后续使用。label语句单独使用的时候没有什么作用几乎，经常和其它语句结合使用。 1、语法：1labelname: statement; 2、例子：1234567var a = 1, b = 2, c = 3, d = 4, e = 5, f = 6; a:b:c:d:e:f:7;]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对JavaScript吧!02数据类型、运算符、运算符优先级]]></title>
    <url>%2F2018%2F12%2F02%2F%E9%9D%A2%E5%AF%B9JavaScript%E5%90%A7%EF%BC%8102%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[前言：最近在学习javascript中数据类型、运算符，以及运算符优先级等相关基础知识，相对简单、基础但也很重要。加上老师的推荐看了阮一峰老师所写的《javascript教程》。从中刷新了过往认知的概念和固有的规则，明白了javascript的出现会打破以往的惯性思维。 在这里1+1不再一定等于2，你常见的算数符号也不是你通常认为的那种作用，一个数字可以是表达式，同时一个表达式也是一个值。。。所以学习这样一种新知识，你要学会先接受，然后敢于去打破自身的思维惯性，之后才能勇于迎接更多挑战。 一、基本语法1、调试打开chrome开发工具：右键——检查——console（esc键调取另一个console） Win F12 Mac Command + Option + I Windows / Linux Ctrl + Shift + I 2、语句（1）语句 VS 表达式A、区别： 语句，主要为了进行某种任务而进行的操作，一般情况下不需要返回值； 表达式，为了得到返回值的计算式，一定会返回一个值。凡是JavaScript语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式 B、例子： 赋值语句：var a = 1 + 3; //先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a 表达式：1 + 3 （2）分号分号前面可以没有任何内容，JavaScript引擎将其视为空语句。;;;A、语句，以分号结尾。一个分号就表示一个语句结束。多个语句可以写在一行内。不需要加分号，换行默认上一行为语句。 123456var a = 1 + 3 ; var b = &apos;abc&apos;; /*或*/var a = 3 var b = 4 var c = a+b B、表达式不需要分号结尾。一旦在表达式后面添加分号，则JavaScript引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。下面两行语句有返回值，但是没有任何意义，因为只是返回一个单纯的值，没有任何其他操作。 121 + 3; //语句，但无任何意义 &apos;abc&apos;; 如图： 3、变量（1）定义最前面的var是变量声明命令。它表示通知解释引擎，要创建一个变量a（相当于申请了1个内存放在变量a这里）。变量是对“值”的引用，使用变量等同于引用一个值。每一个变量都有一个变量名。如：var a = 1; （2）变量提升A、定义：变量提升（hoisting），即JavaScript引擎的工作方式是：先解析代码获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有变量的声明语句，都会被提升到代码的头部，如： 1234567891011//假设 var a = 1/*这里会产生一个变量提升*/var a ;a =1;/* 或*/a = 3var a/* 控制台显示并不会报错，只要有var变量命令的声明，默认情况下就会自动提升到最前面，之后再作赋值*/ 总结： 变量提升只对var命令声明的变量有效，如果一个变量不是用var命令声明的，就不会发生变量提升。 B、说说变量提升的几种场景第1种场景： 1console.log(a); var a = 1; 代码首先使用console.log方法，在控制台显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为有var存在，即也存在变量提升，引擎中真正运行的是下面这段代码： 1var a; console.log(a); a = 1; 最后的结果是显示undefined，表示变量a已声明，且位于最前面，但还未赋值。注： 这种变量提升的技巧很重要，与之后函数作用，复杂函数执行时所出现的一些情况都可解释 第2种场景：console.log(b); b = 1;语句将会报错，提示“ReferenceError:b is not defined”，即变量b未声明，这是因为b不是用var命令声明的，JavaScript引擎不会将其提升，而只是视为对顶层对象的b属性的赋值。 4、标识符（1）定义：标识符（identifier），用来识别具体对象的一个名称。最常见标识符：变量名、函数名。注： JavaScript语言的标识符对大小写敏感，所以a和A是两个不同的标识符。 （2）标识符命名规则A、第一个字符，可以是任意Unicode字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。B、第二个字符及后面的字符，除了Unicode字母、美元符号和下划线，还可以用数字0-9。C、一些命名实例： 下面这些都是合法的标识符。 1234arg0_tmp$elemπ 下面这些则是不合法的标识符。 123451a // 第一个字符不能是数字23 // 同上*** // 标识符不能包含星号a+b // 标识符不能包含加号-d // 标识符不能包含减号或连词线 中文是合法的标识符，可以用作变量名。 1var 临时变量 = 1; JavaScript有一些保留字，不能用作标识符： arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield 三个词具有特别含义，也不应该用作标识符： 123InfinityNaNundefined 5、注释：123456789// 这是单行注释/* 这是 多行 注释*///历史上JavaScript兼容HTML代码的注释，所以&lt;!--和--&gt;也被视为单行注释。x = 1; &lt;!-- x = 2;--&gt; x = 3; 6、区块（1）定义 JavaScript使用大括号，将多个相关的语句组合在一起，称为区块（block）。（2）与大多数编程语言不一样，JavaScript的区块不构成单独的作用域（scope）。即区块中的变量与区块外的变量，属于同一个作用域。如： 1234&#123; var a = 1;&#125;a // 1 二、数据类型1、定义JS语言的每一个值，都属于某一种数据类型。 2、值所属的数据类型分类JavaScript 的数据类型，共有6种： 注： ES6 又新增了第七种 Symbol 类型的值（1）数值（number）：值为整数和小数（比如1和3.14）（2）字符串（string）：值为字符组成的文本（比如&quot;Hello World&quot;）（3）布尔值（boolean）：值判定为true（真）和false（假）两个特定值 注： 用于询问的便可用boolean进行变量命名,如：var isBoy = true （4）undefined：值判定为未处理，未定义或不存在。目前未定义所以此处暂时没有任何值，但之后可以去放东西。注： 一个变量没有赋值，只能是undefined，不会是null （5）null：值为表示经过处理之后的无值，即此处的值就是“无”的状态。 （6）对象（object）：或称“引用类型”，各种值组成的集合。对象=属性+值对象又可以分成三个子类型： 狭义的对象（object） 数组（array） 函数（function） 3、typeof 运算符（用来确定值所属的数据类型）（1）三种运算符用来确定数据类型运算符，用于连接简单表达式，组成一个复杂的表达式（即通过一个关键字，后面加一个变量或值，得出一个结果） JavaScript有三种方法，可以确定一个值到底属于什么类型。 typeof运算符 instanceof运算符 Object.prototype.toString方法 （2）作用用typeof可以判断一个变量或可以返回一个值为哪种数据类型，如：※数值、字符串、布尔值分别返回number、string、boolean。 1234//数值、字符串、布尔值分别返回number、string、boolean。typeof 123// &quot;number&quot;typeof &apos;123&apos;// &quot;string&quot;typeof false// &quot;boolean&quot; ※函数返回function。 12345function f()&#123;&#125;typeof f// &quot;function&quot; ※ undefined返回 undefined 12typeof undefined// &quot;undefined&quot; ※ 利用这一点，typeof用来检查一个没有声明的变量，而不报错。如代码中变量v没有用var命令声明，直接使用就会报错；但放在typeof后面就不报错了，而是返回undefined。 12345v// ReferenceError: v is not defined typeof v// &quot;undefined&quot; ※实际编程中，变量v要用var命令声明，这个特点通常用在判断语句。 12345678910// 错误的写法if (v) &#123; // ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === &quot;undefined&quot;) &#123; // ...&#125; ※除此以外，其他情况都返回object。 12345//除此以外，其他情况都返回objecttypeof window // &quot;object&quot;typeof &#123;&#125; // &quot;object&quot;typeof [] // &quot;object&quot;typeof null // &quot;object&quot; 实际操作中： 如何判断一个变量是否为函数？ 4、布尔值（1）作用布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。（2）下列运算符会返回布尔值A、两元逻辑运算符：&amp;&amp;(And)，||(Or)B、前置逻辑运算符：!(Not)C、相等运算符：===，!==，==，!=D、比较运算符：&gt;，&gt;=，&lt;，&lt;=如：4&gt;3--&gt;true （3）如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六种值被转为false，其他值都视为true。 undefined –&gt;false null –&gt;false false –&gt;false +0，-0，NaN –&gt; false【其他number（数字）为true】 &quot;&quot;或&#39;&#39;（空字符串）–&gt;false【其他string（字符串,包含&quot; &quot;空白字符串）为true】 A、关于&quot;&quot;或&#39;&#39;（空字符串）布尔值往往用于程序流程的控制，如： 12345if (&apos;&apos;) &#123; console.log(true);&#125;/* 没有任何输出*//*上面代码的if命令后面的判断条件，预期应该是一个布尔值，所以JavaScript自动将空字符串，转为布尔值false，导致程序不会进入代码块，所以没有任何输出*/ B、空数组（[]）和空对象（{}）对应的布尔值，都是true。如： 123456789if ([]) &#123; console.log(true);&#125;// trueif (&#123;&#125;) &#123; console.log(true);&#125;// true 三、数据类型转换解密 总结：js的数据类型如何判断，即任何表达式先转字符串再转数字 1、if判断（1）js如何转换判断从面试题说说if的数据类型： 1234567891011121314151617181920212223242526272829303132// 题目1：如下代码输出什么?if (&quot;hello&quot;) &#123; console.log(&quot;hello&quot;)&#125; //true// 题目2：如下代码输出什么?if (&quot;&quot;) &#123; console.log(&apos;empty&apos;)&#125;//空字符串，代表里面什么都没有 //false// 题目3：如下代码输出什么?if (&quot; &quot;) &#123; console.log(&apos;blank&apos;)&#125;//空白字符串，仍然代表一个值，只不过是空值 //true// 题目4：如下代码输出什么?if ([0]) &#123; console.log(&apos;array&apos;)//对象 true&#125;if（[]）&#123; console.log(&apos;hahah&apos;)&#125; //特殊对象 true// 题目5：如下代码输出什么?if(&apos;0.00&apos;)&#123; console.log(&apos;0.00&apos;)&#125; //字符串（除空字符串外）trueif（+0.00）&#123; console.log(&apos;hahah&apos;)&#125; //false （2）判断原理：对于if（）里括号的表达式（如以下），会被强制转换为布尔类型 undefined –&gt; false null –&gt;false false` –&gt;false +0，-0 ，NaN –&gt;false 【其他number（数字）为true】 &quot;&quot;或&#39;&#39;（空字符串）–&gt;false【其他string（字符串,包含” “空白字符串）为true】 2、==判断（1）js处理 ==的表达式 判断 1234567891011121314151617181920212223242526&quot;&quot; == 0 //题目1 &quot;&quot;空字符串===false===0 0==0 //true&quot; &quot; == 0 //题目2 Number(&apos; &apos;)--&gt;0===false 0==0 //true&quot;&quot; == true //题目3 0===1 //false&quot;&quot; == false //题目4 0===0 //true&quot; &quot; == true //题目5 false===0 0==1 //false!&quot; &quot; == true //题目6 &quot; &quot;空白字符串===true !0===false===0 0不等于true //false!&quot; &quot; == false //题目7 false==false //true*&quot;hello&quot; == true //题目8 字母字符串===Nan Nan不等于1 //fasle*&quot;hello&quot; == false //题目9 字母字符串===Nan Nan不等于0 //fasle&quot;0&quot; == true //题目10 &quot;0&quot;（数字字符串）===0不等于1 //false&quot;0&quot; == false //题目11 &quot;0&quot;（数字字符串）===0===0 //true&quot;00&quot; == false //题目12 &quot;00&quot;（数字字符串）===00===0 //true&quot;0.00&quot; == false //题目13 &quot;0.00&quot;（数字字符串）===0===0 //trueundefined == null //题目14 undefined===Nan===null //true&#123;&#125; == true //题目15 &#123;&#125;===object（没有字符串）不等于true //fasle[] == true //题目16 []（空数组）===object（没有字符串）不等于true //faslevar obj = &#123; a: 0, valueOf: function()&#123;return 1&#125; &#125; obj == &quot;[object Object]&quot; //题目17 //falseobj == 1 //题目18 //trueobj == true //题目19 //true （2）判断原理两图对照，就能判断表达式的数据类型： 四、运算符1、作用：运算符，主要用于连接简单表达式，组成一个复杂的表达式如typeof，为运算符。即typeof 100 === &#39;numeber&#39; 是一个值为字符串&#39;numeber&#39;的表达式再如： 3 ： 表达式 3+4：表达式+ :为运算符 （1+2）*5：表达式。+和* : 均为运算符 2、判断参考标准：（1）有些操作符对不同的数据类型有不同的含义，比如+,在两个操作数都是数字的时候，会做加法运算 （2）两个参数都是字符串或在有一个参数是字符串的情况下会把另外一个参数转换为字符串,做字符串拼接 （3）在参数有对象的情况下会调用其valueOf或toString的函数（两者同时使用，注意优先级） （4）在只有一个字符串参数的时候会尝试将其转换为数字 注： 如果字符串无法转换成数字，那么则转换失败，通常结果为：Nan （5）在只有一个数字参数的时候返回其正数值 12345678console.log(2+4); //6 加法运算console.log(&quot;2&quot;+&quot;4&quot;); //&quot;24&quot;为字符串 字符串的拼接console.log(2+&quot;4&quot;); //&quot;24&quot; 一个数字+字符串，会把数字转化成字符串，然后再进行拼接，不是一个连读的数字24，而是2和4的分开读console.log(2+new Date());//&quot;2Mon Jan 20 2014 17:15:01 GMT+0800 (China Standard Time)&quot;/* 一个数字+一个对象，会调用这个对象的valueOf或toString这个方法*/console.log(+&quot;4&quot;);//4 3、常见类型： 算数表达式 比较表达式 逻辑表达式 赋值表达式 单目运算符 关键字作为运算符，如typeof、delete、instanceof等 （1）算数表达式A、加法运算符（Addition）：x + yB、减法运算符（Subtraction）：x - yC、乘法运算符（Multiplication）：x * yD、除法运算符（Division）：x / y加减乘除的运算，这里会尽可能将字符串转化成数字，如果转换不了数字，则会得出Nan这个结果 E、余数运算符（Remainder）：x % y 用于循环语句 F、自增运算符（Increment）：x ++或者++x x++,由简单表达式（x）和运算符（++）组成一个复杂的表达式，一个表达式本身整体，就是一个值，那么x++的值就是x的原始值; x++，作为表达式的结果是是它自己本身，同一作用域中的下一个变量，则是x++内部又自增了1，即x=x+1 注： x++：是自增前x的原始值 ++x：是自增后下一个x变量的值如： 而++ e则是自增后的那个值，图1所示，自增+1的e ===10，那么++e === 11 自减运算符（Decrement）：--x或者 x--同上可得 求负运算符（Negate）：-x 数值运算符（Convert to number）：+x （2）赋值运算符 1234567891011x += y // 等同于 x = x + yx -= y // 等同于 x = x - yx *= y // 等同于 x = x * yx /= y // 等同于 x = x / yx %= y // 等同于 x = x % yx &gt;&gt;= y // 等同于 x = x &gt;&gt; yx &lt;&lt;= y // 等同于 x = x &lt;&lt; yx &gt;&gt;&gt;= y // 等同于 x = x &gt;&gt;&gt; yx &amp;= y // 等同于 x = x &amp; yx |= y // 等同于 x = x | yx ^= y // 等同于 x = x ^ y （3）比较运算符比较运算符比较两个值，然后返回一个布尔值（实际上是ture或false），表示是否满足比较条件。JavaScript提供了8个比较运算符。A、= 赋值= 为赋值运算符，连接两个简单的表达式构成复杂的表达式，如x=y即为表达式，若将其看成一个整体，即会输出一个值，这个值则为最终赋的值，如： B、== 相等这里的相等是，近似相等，后台得到的值则是ture或者false如数字和字符串的比较，后台会将字符串做一个类型转换： C、===严格相等这里的相等则更严格，值和类型的严格相等 题外话： === VS == ===叫做严格运算符 == 叫做相等运算符 关于这两者的区别我在知乎上看到一篇文章：Javascript 中 == 和 === 区别是什么？ a、严格运算符的运算规则如下：(1)不同类型值如果两个值的类型不同，直接返回false。(2)同一类的原始类型值同一类型的原始类型的值(数值、字符串、布尔值)比较时，值相同就返回true，值不同就返回false。(3)同一类的复合类型值两个复合类型(对象、数组、函数)的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。(4)undefined和nullundefined 和 null与自身严格相等。 12null === null //trueundefined === undefined // true b、相等运算符在比较相同类型的数据时，与严格相等运算符完全一样。在比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。类型转换规则如~下:(1)原始类型的值原始类型的数据会转换成数值类型再进行比较。字符串和布尔值都会转换成数值，所以题主的问题中会有第二个string输出。(2)对象与原始类型值比较对象(这里指广义的对象，包括数值和函数)与原始类型的值比较时，对象转化成原始类型的值，再进行比较。(3)undefined和 nullundefined和null与其他类型的值比较时，结果都为false, 它们互相比较时结果为true。(4)相等运算符的缺点相等运算符隐藏的类型转换，会带来- -些违反直觉的结果。 123456789== &apos;0&apos; // false0 == // true0 == // truefalse == &apos;false&apos; // falsefalse == &apos;0&apos; //truefalse == undefined // falsefalse == null // falsenull == undefined // true&apos; \t\r\n &apos; == 0 // true 这就是为什么建议尽量不要使用相等运算符。至于使用相等运算符会不会对后续代码造成意外影响，答案是有可能会。 1234567891011121314151617 var a = undefined;if(!a)&#123; console.log(&quot;1&quot;); &#125;//1 var a = undefined;if(a == null)&#123; console.log(&quot;1&quot;); &#125; //1 var a = undefined;if(a === null)&#123; console.log(&quot;1&quot;); &#125; // 无输出 也就是说当a为undefined时，输出的值会有变化，而在编程中对象变成undefined实在是太常见了。D、 != 不相等E 、!== 严格不相等F、 &lt; 小于G、 &lt;= 小于或等于H、 &gt; 大于I 、 &gt;= 大于或等于 （5）布尔运算符A、! 取反运算符B、&amp;&amp; 且运算符表达式&amp;&amp;表达式 会自动地转化成ture或者false 进行比较。或判断一个东西是否存在，是否满足条件C、|| 或运算符初始化赋值的时候可用 题外话：&amp;&amp; 且 运算符 VS ||或 运算符a、且——&amp;&amp; ：用于判断一个东西是否存在，或是否满足条件（有false就判断）如果第一个为true，第二个也为true，最终值就是第二个值；如：var a = “hello”，那么a&amp;&amp;console.log（a）就能进行判断，第二个值的最终结果为true 如果第一个为true，再看第二个是否为false，那最终的值就是为第一个值； 如果第一个为false，那就不用再判断第二个，就是第一个值总结： 如果是false就不用再看了；如果有true，再看第二个 b、或——||: 用于初始化值如果第一个为true，后面就不用再管；如果第一个为false，再看第二个总结： 如果是true，就不会再管了；如果有false，再看第二个。只要一项为真，那就不用管,如：第二个cc为undefined，转化为Boolean类型为false，||中还会看第二个，0为true，那么结果就为0。将0赋值给第一个cc，那么cc则有了初始值。假如cc=100，再执行cc=cc||0，那么cc仍然等于100，转换为boolean类型为true，那么则不需要在看第二个数如果cc之前没有声明的话，得到的是一个默认值；如果cc之前声明过，值还保持不变。 D、condition? true case : false case三元条件运算符题外话： 三目运算符 Condition？true case：false case这里有一个条件判断，如果条件判断为真的话，那么整个表达式的结果就是true case执行的结果；如果条件判断为假的话，那么整个表达式的结果就是false case执行的结果，当然，false case还是会再做一些执行，如： 123456if (a &gt; 10) &#123; b = a&#125; else &#123; b = a - 2&#125; 答：b = a&gt;10? a : a-2 （5）位运算符必要时看看二进制转换对照表也行：二进制转换对照表 A、或运算（or）：符号为|，表示两个二进制位中有一个为1，则结果为1，否则为0。B、与运算（and）：符号为&amp;，表示两个二进制位都为1，则结果为1，否则为0。C、否运算（not）：符号为～，表示将一个二进制位变成相反值。D、异或运算（xor）：符号为ˆ，表示两个二进制位中有且仅有一个为1时，结果为1，否则为0。E、左移运算（left shift）：符号为&lt;&lt;F、右移运算（right shift）：符号为&gt;&gt;J、带符号位的右移运算（zero filled right shift）：符号为&gt;&gt;&gt; （6）其它运算符（考虑优先级）A、小括号在JavaScript中，圆括号是一种运算符，它有两种用法：如果把表达式放在圆括号之中，作用是求值；如果跟在函数的后面，作用是调用函数。B、voidvoid运算符的作用是执行一个表达式，然后返回undefined。C、逗号运算符逗号运算符用于对两个表达式求值，并返回后一个表达式的值。如： 五、运算符优先级和结合性1、定义结合性是指多个具有同样优先级的运算符表达式中的运算顺序 2、实践——理论：（1）有的运算符是左结合的，即运算从左到右执行，下面两个运算是一样的 12w = x + y + z;w = (x + y) + z; （2）有的运算符是右结合的 1234w = x = y = z;w = (x = (y = z));w = a: b: c ? d : e? f : g;w = a? b : (c? d: (e? f : g)); 如： 最高：typeof 最低：， 3、理论——实践 几个优先级从高到低： typrof （） ++ -- ！ +-*% &amp;&amp; || = （1）typeof的优先级相当的高，比加减乘除都优先，所以虽然是操作符，但在复杂表达式的时候我们还是习惯加括号，如： 123typeof 2*3;//NaNtypeof (2*3);//&quot;number&quot;typeof 2+3;// &quot;number3&quot; 题外话： NanN（即not and number）定义：是一个数字类型，不过它不是一个有效的数，表示为错误数字。通过number函数可以把一个数字的字符创转化成数字，不过无法将一个字母的字符串转化成数字，得出结果为NaN。当NaN===NaN—&gt;false，一个数字与自己不相等，作为一个数字，二者对等与否对方均无从得知，没有突出一个数字的识别性。如： （2）++、--是右结合的操作符（优先级最高的几个都是右结合），而且比加减乘除优先级高。同时自增、自减运算符的运算数得是左值（可以放在赋值符号左边的值），而不能是常数 123454++; //ReferenceError: Invalid left-hand side expression in postfix operationvar a=0,b=0;//, 忽略第一个操作数，返回第二个操作数 L(往左运算）a+++b;//0a;//1，++优先级比+高，所以相当于(a++)+bb;//0 （3）赋值运算符的优先级相当的低a = b == c; //等同于a = (b==c) （4）逻辑非!也在优先级队列的前端，比加减乘除高，但逻辑与、逻辑或优先级很低，不如加减乘除!2*0; //0, 等价于(!2)*0 （5）一个关于逻辑运算符的有意思地方是其“短路”功能，会结合表达式计算值来判断 1231 &amp;&amp; 3;1 &amp;&amp; &quot;foo&quot; || 0;1 || &quot;foo&quot; &amp;&amp; 0 如：]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面对JavaScript吧!01了解JS（包括白屏和fouc）]]></title>
    <url>%2F2018%2F12%2F01%2F%E9%9D%A2%E5%AF%B9JavaScript%E5%90%A7%EF%BC%8101%E4%BA%86%E8%A7%A3JS%EF%BC%88%E5%8C%85%E6%8B%AC%E7%99%BD%E5%B1%8F%E5%92%8Cfouc%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言：面对疾风吧！咳咳…不对是面对JavaScript吧！开始学javascript了，HTML和CSS学完但是感觉自己并没有记住啥，还需要系统的梳理大量的练习！！！学习JavaScript，大家都安利阮一峰的教程，好吧我就从阮一峰老师的新手教程开始学习好了，冲鸭！面对JavaScript吧！ 一、网页的构成 网页 = Html+CSS+JavaScript Html: 网页元素内容 CSS: 控制网页样式 JavaScript：操作网页内容，实现功能或者效果 浏览器端（web应用）、服务端（nodejs）。。。 二、JavaScirpt 发展历史 参考：阮一峰js标准教程 1995年5月，Brendan Eich只用了10天，就设计完成了这种语言的第一版。 1996年8月，微软模仿JavaScript开发了一种相近的语言，取名为JScript（JavaScript是Netscape网景公司的注册商标，微软不能用），首先内置于IE 3.0。 1996年11月，Netscape公司决定将JavaScript提交给国际标准化组织ECMA（European Computer Manufacturers Association），希望JavaScript能够成为国际标准，以此抵抗微软。 1997年7月，ECMA组织发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript。这个版本就是ECMAScript 1.0版。基本上，JavaScript这个名字的原意是“很像Java的脚本语言”。在JavaScript语言中，函数是一种独立的数据类型，以及采用基于原型对象（prototype）的继承链。这是它与Java语法最大的两点区别。JavaScript语法要比Java自由得多。 1999年12月，ECMAScript 3.0版发布，成为JavaScript的通行标准，得到了广泛支持。 2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA开会决定，中止ECMAScript 4.0的开发（即废除了这个版本），将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，会后不久，ECMAScript 3.1就改名为ECMAScript 5。 2009年12月，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6； 2006年，jQuery函数库诞生，作者为John Resig。jQuery为操作网页DOM结构提供了非常强大易用的接口，成为了使用最广泛的函数库，并且让JavaScript语言的应用难度大大降低，推动了这种语言的流行。 2009年，Node.js项目诞生，创始人为Ryan Dahl，它标志着JavaScript可以用于服务器端编程，从此网站的前端和后端可以使用同一种语言开发。并且，Node.js可以承受很大的并发流量，使得开发某些互联网大规模的实时应用变得容易。 2012年，微软发布TypeScript语言。该语言被设计成JavaScript的超集，这意味着所有JavaScipt程序，都可以不经修改地在TypeScript中运行。同时，TypeScript添加了很多新的语法特性，主要目的是为了开发大型程序，然后还可以被编译成JavaScript运行。 2013年5月，Facebook发布UI框架库React，引入了新的JSX语法，使得UI层可以用组件开发。 2015年4月，Angular框架宣布，2.0版将基于微软公司的TypeScript语言开发，这等于为JavaScript语言引入了强类型。 三、JS引入使用12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;标题&lt;/title&gt; /*这里引入css代码*/ &lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;style&gt; body&#123; background: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;/p&gt; /*一般来说，这里引入js代码*/ &lt;script src=&quot;index.js&quot;&gt;/*空*/&lt;/script&gt; 或 &lt;script&gt; alert(1); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 四、浏览器渲染机制你所看到的浏览器网页，浏览器是经历了什么你才能看到？ 解析 HTML 标签, 构建 DOM 树⏬ 解析 CSS 标签, 构建 CSSOM 树⏬ 把 DOM 和 CSSOM 组合成 渲染树 (render tree)⏬ 在渲染树的基础上进行布局, 计算每个节点的几何结构 ⏬ 把每个节点绘制到屏幕上 (painting) 当发一个请求到服务器之后，服务器会把页面上的html发给浏览器，浏览器收到之后则会解析该html标签，解析的过程中遇到了类似需要加载的样式，如link，则会再次发送请求到服务器。这样一来，如此循环，标签属性的请求不断被发出到服务器，资源不断被获取资源获取之后，如何被用户看见？ 首先，先对html标签进行解析。解析成一个dom树（即类似于树状结构，dom，即文档、模型）同时，也对css样式进行解析，同时也解析成cssom树，将css样式（默认+添加）汇聚一起形成css树——dom树元素和css树元素结合起来获得一个对象，该对象所拥有的元素和具体位置都有其相互关系，对应节点和对应数据形成一个渲染树——执行layout（布局）计算它的位置和样式——绘制——排列形成页面 五、浏览器引起的Repaint 和 Reflow问题1、Repaint问题：重新绘制。将css样式改变的话，其他元素并未改变，只需要重新绘制某一处就行。 2、Reflow问题：重新回流，重新计算。即自身位置发生变化，给其他元素带来了影响，要重新进行计算。 从一个外网中截取出来的关于Repaint 和 Reflow分辨片段： Anything that changes input information used to construct the rendering tree can cause a repaint or a reflow, for example:Adding, removing, updating DOM nodesHiding a DOM node with display: none (reflow and repaint) or visibility: hidden(repaint only, because no geometry changes)Moving, animating a DOM node on the pageAdding a stylesheet, tweaking style propertiesUser action such as resizing the window, changing the font size, or (oh, OMG, no!) scrollin Let’s see a few examples: 1234567891011121314var bstyle = document.body.style; // cachebstyle.padding = &quot;20px&quot;; // reflow, repaintbstyle.border = &quot;10px solid red&quot;; // another reflow and a repaintbstyle.color = &quot;blue&quot;; // repaint only, no dimensions changedbstyle.backgroundColor = &quot;#fad&quot;; // repaintbstyle.fontSize = &quot;2em&quot;; // reflow, repaint/* new DOM element - reflow, repaint */document.body.appendChild(document.createTextNode(&apos;dude!&apos;)); 六、白屏和FOUC1、即指影响浏览器页面加载顺序的两种场景 白屏：特指一种场景，打开页面是一片白色，突然页面出现，样式正确。那么一片白色的时间，则称之为白屏。 FOUC (Flash of UnstyledContent)：无样式内容闪烁，网速情况差，打开页面时仍有样式，之后样式时有时无，甚至一开始并无出现样式，突然样式恢复。（常出现在firefox浏览器）此类现象，在不同浏览器进行的资源加载和页面渲染时，所采用的不同的处理方式，并不是bug。 2、写一个server，验证白屏和fouc效果在index.html中 12345678910111213141516171819202122232425262728//index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;fouc &amp; 白屏&lt;/title&gt; &lt;!--在下面模拟一个延时装置--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;b.css?t=10&quot;&gt; //设置这个工具，当请求该文件时，服务器会延迟请求10s再去加载这个资源，以此可以模拟一个网速特别慢的情况 &lt;link rel=&quot;stylesheet&quot; href=&quot;a.css?t=3&quot;&gt; &lt;/head&gt;&lt;body&gt; &lt;p&gt;hello&lt;/p&gt; &lt;p&gt;饥人谷&lt;/p&gt;&lt;!-- &lt;script src=&quot;A.js?t=5&quot;&gt;&lt;/script&gt; --&gt; &lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/15/1653c442f35af77c?w=211&amp;h=200&amp;f=png&amp;s=8004&quot; alt=&quot;&quot;&gt;&lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;c.css?t=6&quot;&gt; --&gt; &lt;!-- &lt;script src=&quot;http://a.jrg.com:8080/B.js?t=4&quot; &gt;&lt;/script&gt; &lt;script src=&quot;http://b.jrg.com:8080/A.js?t=8&quot; &gt;&lt;/script&gt; --&gt; &lt;/body&gt;&lt;/html&gt; （1）关于白屏，需要注意的是，浏览器对于样式和js的处理，即CSS和JS放置顺序。推荐：将样式放在 head里面,将JS放在body内部下方。如上面代码所示，html页面里引入了两个css：a.css和b.css。b.css引用了c.ss（@import&quot;./c.css?t=5&quot;;）b.css中加入了一个10s的延时文件（&lt;link rel=&quot;stylesheet&quot; href=&quot;b.css?t=10&quot;&gt;），加载这个10s的css样式文件，浏览器是如何完成加载工作，有两种方式：第1种： html解析完成，此时10s延时的css文件先不管，先展示body里所展示的内容，等css文件全加载后再去计算样式，再去重新渲染一次；第2种： 即使html的dom树已经解析、渲染都完成，对未加载完成的样式都必须等待，即css样式要全部加载、获取，img资源加载完成，此时底部JS立刻执行，才一次性展示出页面。例子中展示这种方法，即为白屏很久的原因。 （2）不同浏览器的不同处理机制所出现的场景不同A、白屏场景（常出现在chrome）：打开一个国外网站，使用国外服务器，嵌在css的字体使用的是谷歌字体，运行特别慢，等了好久突然出现页面样式效果。这是因为页面需要等待css样式加载所有完成，甚至出现404加载失败，最后才展示出页面。那么那段加载时间，等待了几秒左右的白色一片的页面，就是白屏B、Fouc场景（常出现在Firefox）：一开始的时候，先让你看见样式，如字的小号样式，样式加载完后看到所规定字号的大字。对用户来说，同样的样式，突然从小变大，则这个场景就是Fouc（无样式内容闪烁）。总结： 不管是css样式，还是js文件，只要加长延时，都会造成白屏 （3）CSS 和 JS 最佳放置顺序 使用 link 标签将样式表放在顶部 将JS放在底部（3.1）场景：假设JS文件页面顶部： JS脚本会阻塞后面内容的呈现 JS脚本会阻塞其后组件（如图片）的下载 JS加载时间过长，css需等待，则会出现一段时间白屏 场景说明：引入一个JS文件在顶部，设置一个延时时间。 加载顺序：css—js—img—全部获取到展现页面效果此时，img和css加载时会并发加载，即如一个域名下同时加载两个文件（并发是有限度的），加载在顶部的js时，会禁用并发img和css，并阻止其他内容下载和渲染。 js并不影响css加载，但是会影响css样式的一个计算。当js加载时，css已经获取到（不过此时页面还是一片空白），直到js获取立即执行后，图片立刻出现，页面才展示效果。所以js文件放入页面顶部head里，也会导致白屏现象出现 （3.2）JS加载特点总结A、优先加载js文件，加载后js立刻去执行，展示页面（CSS样式则是全部加载完，然后一次性展示出页面）注： css放前面，优先加载； 若放后面，其他资源则会阻碍css加载，那么时机就太晚。 B、由于渲染线程和js脚本线程是互斥的，白屏是渲染进程被阻塞的原因，当碰到script标签的时候，会先执行js脚本，然后再渲染。 （放顶部时）JS加载时机过晚导致一系列问题，脚本会阻塞后面内容的呈现、脚本会阻塞其后组件的下载（主要指img资源下载）、白屏等。 （放底部）则可以先让其他先加载完成，JS立刻执行的特点可以“扫尾”最后的页面效果 C、JS脚本操作页面上的html+css元素，（放顶部时）JS先执行，元素都未加载到（即不存在），未出现在文档流中【加载，这里指资源加载和资源是否出现在文档流中】，所以也不能操作相应JS功能，此时后台将会报错。D、（放顶部时）其他JS若作为一种框架语言，则能提前形成一个初步的框架有效构成页面结构。 七、JS脚本的异步加载1、一个问题？即一个放在head的js文件，如下：&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;原本放在顶部的这个js文件，会提前加载，如何使它在顶部仍然稍后加载呢？ 2、解决方法：async和defer（1）作用：没有 defer 或async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该script标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。也就是说，使用defer或async后能够改变这种加载、执行的时机。常应用在引用了广告和统计的页面中，不会影响、堵塞，更不会影响到到页面其他元素 （2）asyncHTML5里为script标签里新增了async属性，用于异步加载脚本：不保证顺序（独立的个体）&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;或&lt;script type=&quot;text/javascript&quot; src=&quot;alert.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;浏览器解析到HTML里的该行script标签，发现指定为async，会异步下载解析执行脚本（即加载后续文档元素的过程将和script.js的加载并行进行）。 页面的DOM结构里假设&lt;script&gt;在img之前，如果你的浏览器支持async的话，就会异步加载脚本。此时DOM里已经有img了，所以脚本里能顺利取到img的src并弹框。 （3）deferscript标签里可以设置defer，表示延迟加载脚本：脚本先不执行，延迟到文档解析和显示后执行，有顺序&lt;script defer src=&quot;script.js&quot;&gt;&lt;/script&gt;或&lt;script type=&quot;text/javascript&quot; src=&quot;alert.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;浏览器解析到HTML里该行script标签，发现指定为defer，会暂缓下载解析执行脚本，等到页面文档解析并加载执行完毕后，才会加载该脚本（更精确地说，是在DOM树构建完成后，在DOMContentLoaded事件触发前，加载`defer`的脚本）。 页面的DOM结构里假设script在img图片之前，如果你的浏览器支持defer的话，就会延迟到页面加载完后才下载脚本。此时DOM里已经有img元素了，所以脚本里能顺利取到img的src并弹框。 总结： JS实质采用一种可以更自由地选择加载时机和任何位置，让处于顶部的js文件能够像在底部时，在页面必要元素加载完成时进行“异步”加载。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记（一）数据类型]]></title>
    <url>%2F2018%2F11%2F20%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[简介JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 Symbol 类型的值，暂不涉及。） 数值（number）：整数和小数（比如1和3.14） 字符串（string）：文本（比如Hello World）。 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假） undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 null：表示空值，即此处的值为空。 对象（object）：各种值组成的集合。 通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值。 对象是最复杂的数据类型，又可以分成三个子类型。 狭义的对象（object） 数组（array） 函数（function） 狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的”对象“都特指狭义的对象。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。 typeof 运算符JavaScript 有三种方法，可以确定一个值到底是什么类型。 typeof运算符 instanceof运算符 Object.prototype.toString方法 instanceof运算符和Object.prototype.toString方法，将在后文介绍。这里介绍typeof运算符。 typeof运算符可以返回一个值的数据类型。 数值、字符串、布尔值分别返回number、string、boolean。 123typeof 123 // &quot;number&quot;typeof &apos;123&apos; // &quot;string&quot;typeof false // &quot;boolean&quot; 函数返回function。 123function f() &#123;&#125;typeof f// &quot;function&quot; undefined返回undefined。 12typeof undefined// &quot;undefined&quot; 利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。 12345v// ReferenceError: v is not definedtypeof v// &quot;undefined&quot; 上面代码中，变量v没有用var命令声明，直接使用就会报错。但是，放在typeof后面，就不报错了，而是返回undefined。 实际编程中，这个特点通常用在判断语句。 12345678910// 错误的写法if (v) &#123; // ...&#125;// ReferenceError: v is not defined// 正确的写法if (typeof v === &quot;undefined&quot;) &#123; // ...&#125; 对象返回object。 123typeof window // &quot;object&quot;typeof &#123;&#125; // &quot;object&quot;typeof [] // &quot;object&quot; 上面代码中，空数组（[]）的类型也是object，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，instanceof运算符可以区分数组和对象。instanceof运算符的详细解释，请见《面向对象编程》一章。 12345var o = &#123;&#125;;var a = [];o instanceof Array // falsea instanceof Array // true null返回object。 1typeof null // &quot;object&quot; null的类型是object，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑null，只把它当作object的一种特殊值。后来null独立出来，作为一种单独的数据类型，为了兼容以前的代码，typeof null返回object就没法改变了。 null, undefined 和布尔值null 和 undefined概述null与undefined都可以表示“没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。 123var a = undefined;// 或者var a = null; 上面代码中，变量a分别被赋值为undefined和null，这两种写法的效果几乎等价。 在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。 123456789101112if (!undefined) &#123; console.log(&apos;undefined is false&apos;);&#125;// undefined is falseif (!null) &#123; console.log(&apos;null is false&apos;);&#125;// null is falseundefined == null// true 从上面代码可见，两者的行为是何等相似！谷歌公司开发的 JavaScript 语言的替代品 Dart 语言，就明确规定只有null，没有undefined！ 既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。 1995年 JavaScript 诞生时，最初像 Java 一样，只设置了null表示”无”。根据 C 语言的传统，null可以自动转为0。 12Number(null) // 05 + null // 5 上面代码中，null转为数字时，自动变成0。 但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，null就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果null自动转为0，很不容易发现错误。 因此，他又设计了一个undefined。区别是这样的：null是一个表示“空”的对象，转为数值时为0；undefined是一个表示”此处无定义”的原始值，转为数值时为NaN。 12Number(undefined) // NaN5 + undefined // NaN 用法和含义对于null和undefined，大致可以像下面这样理解。 null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。 undefined表示“未定义”，下面是返回undefined的典型场景。 1234567891011121314151617// 变量声明了，但没有赋值var i;i // undefined// 调用函数时，应该提供的参数没有提供，该参数等于 undefinedfunction f(x) &#123; return x;&#125;f() // undefined// 对象没有赋值的属性var o = new Object();o.p // undefined// 函数没有返回值时，默认返回 undefinedfunction f() &#123;&#125;f() // undefined 布尔值布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。 下列运算符会返回布尔值： 前置逻辑运算符： ! (Not) 相等运算符：===，!==，==，!= 比较运算符：&gt;，&gt;=，&lt;，&lt;= 如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefined null false 0 NaN &quot;&quot;或&#39;&#39;（空字符串） 布尔值往往用于程序流程的控制，请看一个例子。 1234if (&apos;&apos;) &#123; console.log(&apos;true&apos;);&#125;// 没有任何输出 上面代码中，if命令后面的判断条件，预期应该是一个布尔值，所以 JavaScript 自动将空字符串，转为布尔值false，导致程序不会进入代码块，所以没有任何输出。 注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。 123456789if ([]) &#123; console.log(&apos;true&apos;);&#125;// trueif (&#123;&#125;) &#123; console.log(&apos;true&apos;);&#125;// true 更多关于数据类型转换的介绍，参见《数据类型转换》一章。 数值概述整数和浮点数JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。 11 === 1.0 // true 这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算，参见《运算符》一章的”位运算“部分。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 123456780.1 + 0.2 === 0.3// false0.3 / 0.1// 2.9999999999999996(0.3 - 0.2) === (0.2 - 0.1)// false 数值精度根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。 第1位：符号位，0表示正数，1表示负数 第2位到第12位（共11位）：指数部分 第13位到第64位（共52位）：小数部分（即有效数字） 符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。 指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1，不保存在64位浮点数之中。也就是说，有效数字这时总是1.xx...xx的形式，其中xx..xx的部分保存在64位浮点数之中，最长可能为52位。因此，JavaScript 提供的有效数字最长为53个二进制位。 1(-1)^符号位 * 1.xx...xx * 2^指数部分 上面公式是正常情况下（指数部分在0到2047之间），一个数在 JavaScript 内部实际的表示形式。 精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。 1234567891011121314Math.pow(2, 53)// 9007199254740992 Math.pow(2, 53) + 1// 9007199254740992Math.pow(2, 53) + 2// 9007199254740994Math.pow(2, 53) + 3// 9007199254740996Math.pow(2, 53) + 4// 9007199254740996 上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理。 123456Math.pow(2, 53)// 9007199254740992// 多出的三个有效数字，将无法保存9007199254740992111// 9007199254740992000 上面示例表明，大于2的53次方以后，多出来的有效数字（最后三位的111）都会无法保存，变成0。 数值范围根据标准，64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为21024到2-1023（开区间），超出这个范围的数无法表示。 如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。 1Math.pow(2, 1024) // Infinity 如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。 1Math.pow(2, -1075) // 0 下面是一个实际的例子。 1234567var x = 0.5;for(var i = 0; i &lt; 25; i++) &#123; x = x * x;&#125;x // 0 上面代码中，对0.5连续做25次平方，由于最后结果太接近0，超出了可表示的范围，JavaScript 就直接将其转为0。 JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。 12Number.MAX_VALUE // 1.7976931348623157e+308Number.MIN_VALUE // 5e-324 数值的表示法JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如35（十进制）和0xFF（十六进制）。 数值也可以采用科学计数法表示，下面是几个科学计数法的例子。 1234123e3 // 123000123e-3 // 0.123-3.1E+12.1e-23 科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分。 以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。 （1）小数点前的数字多于21位。 123451234567890123456789012// 1.2345678901234568e+21123456789012345678901// 123456789012345680000 （2）小数点后的零多于5个。 123456// 小数点后紧跟5个以上的零，// 就自动转为科学计数法0.0000003 // 3e-7// 否则，就保持原来的字面形式0.000003 // 0.000003 数值的进制使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。 十进制：没有前导0的数值。 八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。 十六进制：有前缀0x或0X的数值。 二进制：有前缀0b或0B的数值。 默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。 1230xff // 2550o377 // 2550b11 // 3 如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。 1230xzz // 报错0o88 // 报错0b22 // 报错 上面代码中，十六进制出现了字母z、八进制出现数字8、二进制出现数字2，因此报错。 通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。 120888 // 8880777 // 511 前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。 特殊数值JavaScript 提供了几个特殊的数值。 正零和负零前面说过，JavaScript 的64位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连0也不例外。 JavaScript 内部实际上存在2个0：一个是+0，一个是-0，区别就是64位浮点数表示法的符号位不同。它们是等价的。 123-0 === +0 // true0 === -0 // true0 === +0 // true 几乎所有场合，正零和负零都会被当作正常的0。 1234+0 // 0-0 // 0(-0).toString() // &apos;0&apos;(+0).toString() // &apos;0&apos; 唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的。 1(1 / +0) === (1 / -0) // false 上面的代码之所以出现这样结果，是因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的（关于Infinity详见下文）。 NaN（1）含义 NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。 15 - &apos;x&apos; // NaN 上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为NaN，表示它是“非数字”（NaN）。 另外，一些数学函数的运算结果会出现NaN。 123Math.acos(2) // NaNMath.log(-1) // NaNMath.sqrt(-1) // NaN 0除以0也会得到NaN。 10 / 0 // NaN 需要注意的是，NaN不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。 1typeof NaN // &apos;number&apos; （2）运算规则 NaN不等于任何值，包括它本身。 1NaN === NaN // false 数组的indexOf方法内部使用的是严格相等运算符，所以该方法对NaN不成立。 1[NaN].indexOf(NaN) // -1 NaN在布尔运算时被当作false。 1Boolean(NaN) // false NaN与任何数（包括它自己）的运算，得到的都是NaN。 1234NaN + 32 // NaNNaN - 32 // NaNNaN * 32 // NaNNaN / 32 // NaN Infinity（1）含义 Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。 1234567// 场景一Math.pow(2, 1024)// Infinity// 场景二0 / 0 // NaN1 / 0 // Infinity 上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回Infinity。第二个场景是0除以0会得到NaN，而非0数值除以0，会返回Infinity。 Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。 1234Infinity === -Infinity // false1 / -0 // -Infinity-1 / -0 // Infinity 上面代码中，非零正数除以-0，会得到-Infinity，负数除以-0，会得到Infinity。 由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript 都不报错，所以单纯的数学运算几乎没有可能抛出错误。 Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了NaN）。 12Infinity &gt; 1000 // true-Infinity &lt; -1000 // true Infinity与NaN比较，总是返回false。 12345Infinity &gt; NaN // false-Infinity &gt; NaN // falseInfinity &lt; NaN // false-Infinity &lt; NaN // false （2）运算规则 Infinity的四则运算，符合无穷的数学计算规则。 12345 * Infinity // Infinity5 - Infinity // -InfinityInfinity / 5 // Infinity5 / Infinity // 0 0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。 1230 * Infinity // NaN0 / Infinity // 0Infinity / 0 // Infinity Infinity加上或乘以Infinity，返回的还是Infinity。 12Infinity + Infinity // InfinityInfinity * Infinity // Infinity Infinity减去或除以Infinity，得到NaN。 12Infinity - Infinity // NaNInfinity / Infinity // NaN Infinity与null计算时，null会转成0，等同于与0的计算。 123null * Infinity // NaNnull / Infinity // 0Infinity / null // Infinity Infinity与undefined计算，返回的都是NaN。 12345undefined + Infinity // NaNundefined - Infinity // NaNundefined * Infinity // NaNundefined / Infinity // NaNInfinity / undefined // NaN 与数值相关的全局方法parseInt()（1）基本用法 parseInt方法用于将字符串转为整数。 1parseInt(&apos;123&apos;) // 123 如果字符串头部有空格，空格会被自动去除。 1parseInt(&apos; 81&apos;) // 81 如果parseInt的参数不是字符串，则会先转为字符串再转换。 123parseInt(1.23) // 1// 等同于parseInt(&apos;1.23&apos;) // 1 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。 12345parseInt(&apos;8a&apos;) // 8parseInt(&apos;12**&apos;) // 12parseInt(&apos;12.34&apos;) // 12parseInt(&apos;15e2&apos;) // 15parseInt(&apos;15px&apos;) // 15 上面代码中，parseInt的参数都是字符串，结果只返回字符串头部可以转为数字的部分。 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。 12345parseInt(&apos;abc&apos;) // NaNparseInt(&apos;.3&apos;) // NaNparseInt(&apos;&apos;) // NaNparseInt(&apos;+&apos;) // NaNparseInt(&apos;+1&apos;) // 1 所以，parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。 如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。 1parseInt(&apos;0x10&apos;) // 16 如果字符串以0开头，将其按照10进制解析。 1parseInt(&apos;011&apos;) // 11 对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。 1234567parseInt(1000000000000000000000.5) // 1// 等同于parseInt(&apos;1e+21&apos;) // 1parseInt(0.0000008) // 8// 等同于parseInt(&apos;8e-7&apos;) // 8 （2）进制转换 parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。 123parseInt(&apos;1000&apos;) // 1000// 等同于parseInt(&apos;1000&apos;, 10) // 1000 下面是转换指定进制的数的例子。 123parseInt(&apos;1000&apos;, 2) // 8parseInt(&apos;1000&apos;, 6) // 216parseInt(&apos;1000&apos;, 8) // 512 上面代码中，二进制、六进制、八进制的1000，分别等于十进制的8、216和512。这意味着，可以用parseInt方法进行进制的转换。 如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。 12345parseInt(&apos;10&apos;, 37) // NaNparseInt(&apos;10&apos;, 1) // NaNparseInt(&apos;10&apos;, 0) // 10parseInt(&apos;10&apos;, null) // 10parseInt(&apos;10&apos;, undefined) // 10 如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。 12parseInt(&apos;1546&apos;, 2) // 1parseInt(&apos;546&apos;, 2) // NaN 上面代码中，对于二进制来说，1是有意义的字符，5、4、6都是无意义的字符，所以第一行返回1，第二行返回NaN。 前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果。 12345678910parseInt(0x11, 36) // 43parseInt(0x11, 2) // 1// 等同于parseInt(String(0x11), 36)parseInt(String(0x11), 2)// 等同于parseInt(&apos;17&apos;, 36)parseInt(&apos;17&apos;, 2) 上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1。 这种处理方式，对于八进制的前缀0，尤其需要注意。 1234567parseInt(011, 2) // NaN// 等同于parseInt(String(011), 2)// 等同于parseInt(String(9), 2) 上面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，所以返回NaN。如果直接计算parseInt(&#39;011&#39;, 2)，011则是会被当作二进制处理，返回3。 JavaScript 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定。 parseFloat()parseFloat方法用于将一个字符串转为浮点数。 1parseFloat(&apos;3.14&apos;) // 3.14 如果字符串符合科学计数法，则会进行相应的转换。 12parseFloat(&apos;314e-2&apos;) // 3.14parseFloat(&apos;0.0314E+2&apos;) // 3.14 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。 1parseFloat(&apos;3.14more non-digit characters&apos;) // 3.14 parseFloat方法会自动过滤字符串前导的空格。 1parseFloat(&apos;\t\v\r12.34\n &apos;) // 12.34 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。 123parseFloat([]) // NaNparseFloat(&apos;FF2&apos;) // NaNparseFloat(&apos;&apos;) // NaN 上面代码中，尤其值得注意，parseFloat会将空字符串转为NaN。 这些特点使得parseFloat的转换结果不同于Number函数。 1234567891011parseFloat(true) // NaNNumber(true) // 1parseFloat(null) // NaNNumber(null) // 0parseFloat(&apos;&apos;) // NaNNumber(&apos;&apos;) // 0parseFloat(&apos;123.45#&apos;) // 123.45Number(&apos;123.45#&apos;) // NaN isNaN()isNaN方法可以用来判断一个值是否为NaN。 12isNaN(NaN) // trueisNaN(123) // false 但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。 123isNaN(&apos;Hello&apos;) // true// 相当于isNaN(Number(&apos;Hello&apos;)) // true 出于同样的原因，对于对象和数组，isNaN也返回true。 1234567isNaN(&#123;&#125;) // true// 等同于isNaN(Number(&#123;&#125;)) // trueisNaN([&apos;xzy&apos;]) // true// 等同于isNaN(Number([&apos;xzy&apos;])) // true 但是，对于空数组和只有一个数值成员的数组，isNaN返回false。 123isNaN([]) // falseisNaN([123]) // falseisNaN([&apos;123&apos;]) // false 上面代码之所以返回false，原因是这些数组能被Number函数转成数值，请参见《数据类型转换》一章。 因此，使用isNaN之前，最好判断一下数据类型。 123function myIsNaN(value) &#123; return typeof value === &apos;number&apos; &amp;&amp; isNaN(value);&#125; 判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。 123function myIsNaN(value) &#123; return value !== value;&#125; isFinite()isFinite方法返回一个布尔值，表示某个值是否为正常的数值。 123456isFinite(Infinity) // falseisFinite(-Infinity) // falseisFinite(NaN) // falseisFinite(undefined) // falseisFinite(null) // trueisFinite(-1) // true 除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。 字符串概述定义字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。 12&apos;abc&apos;&quot;abc&quot; 单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。 12&apos;key = &quot;value&quot;&apos;&quot;It&apos;s a long journey&quot; 上面两个都是合法的字符串。 如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。 12345&apos;Did she say \&apos;Hello\&apos;?&apos;// &quot;Did she say &apos;Hello&apos;?&quot;&quot;Did she say \&quot;Hello\&quot;?&quot;// &quot;Did she say &quot;Hello&quot;?&quot; 由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号，本教程遵守这个约定。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。 字符串默认只能写在一行内，分成多行将会报错。 1234&apos;abc&apos;// SyntaxError: Unexpected token ILLEGAL 上面代码将一个字符串分成三行，JavaScript 就会报错。 如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。 1234567var longString = &apos;Long \long \long \string&apos;;longString// &quot;Long long long string&quot; 上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。 连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。 1234var longString = &apos;Long &apos; + &apos;long &apos; + &apos;long &apos; + &apos;string&apos;; 如果想输出多行字符串，有一种利用多行注释的变通方法。 12345678(function () &#123; /*line 1line 2line 3*/&#125;).toString().split(&apos;\n&apos;).slice(1, -1).join(&apos;\n&apos;)// &quot;line 1// line 2// line 3&quot; 上面的例子中，输出的字符串就是多行。 转义反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。 需要用反斜杠转义的特殊字符，主要有下面这些。 \0 ：null（\u0000） \b ：后退键（\u0008） \f ：换页符（\u000C） \n ：换行符（\u000A） \r ：回车键（\u000D） \t ：制表符（\u0009） \v ：垂直制表符（\u000B） \&#39; ：单引号（\u0027） \&quot; ：双引号（\u0022） \\ ：反斜杠（\u005C） 上面这些字符前面加上反斜杠，都表示特殊含义。 123console.log(&apos;1\n2&apos;)// 1// 2 上面代码中，\n表示换行，输出的时候就分成了两行。 反斜杠还有三种特殊用法。 （1）\HHH 反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的 Unicode 码点，比如\251表示版权符号。显然，这种方法只能输出256种字符。 （2）\xHH \x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的 Unicode 码点，比如\xA9表示版权符号。这种方法也只能输出256种字符。 （3）\uXXXX \u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的 Unicode 码点，比如\u00A9表示版权符号。 下面是这三种字符特殊写法的例子。 1234567&apos;\251&apos; // &quot;©&quot;&apos;\xA9&apos; // &quot;©&quot;&apos;\u00A9&apos; // &quot;©&quot;&apos;\172&apos; === &apos;z&apos; // true&apos;\x7A&apos; === &apos;z&apos; // true&apos;\u007A&apos; === &apos;z&apos; // true 如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。 12&apos;\a&apos;// &quot;a&quot; 上面代码中，a是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。 如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。 12&quot;Prev \\ Next&quot;// &quot;Prev \ Next&quot; 字符串与数组字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。 1234567var s = &apos;hello&apos;;s[0] // &quot;h&quot;s[1] // &quot;e&quot;s[4] // &quot;o&quot;// 直接对字符串使用方括号运算符&apos;hello&apos;[1] // &quot;e&quot; 如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。 123&apos;abc&apos;[3] // undefined&apos;abc&apos;[-1] // undefined&apos;abc&apos;[&apos;x&apos;] // undefined 但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。 12345678910var s = &apos;hello&apos;;delete s[0];s // &quot;hello&quot;s[1] = &apos;a&apos;;s // &quot;hello&quot;s[5] = &apos;!&apos;;s // &quot;hello&quot; 上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。 length 属性length属性返回字符串的长度，该属性也是无法改变的。 12345678var s = &apos;hello&apos;;s.length // 5s.length = 3;s.length // 5s.length = 7;s.length // 5 上面代码表示字符串的length属性无法改变，但是不会报错。 字符集JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。 JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成\uxxxx的形式，其中xxxx代表该字符的 Unicode 码点。比如，\u00A9代表版权符号。 12var s = &apos;\u00A9&apos;;s // &quot;©&quot; 解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。 12var f\u006F\u006F = &apos;abc&apos;;foo // &quot;abc&quot; 上面代码中，第一行的变量名foo是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。 我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。 但是，UTF-16 有两种长度：对于码点在U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。举例来说，码点U+1D306对应的字符为𝌆，它写成 UTF-16 就是0xD834 0xDF06。 JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到U+FFFF，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符𝌆，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。 1&apos;𝌆&apos;.length // 2 上面代码中，JavaScript 认为𝌆的长度为2，而不是1。 总结一下，对于码点在U+10000到U+10FFFF之间的字符，JavaScript 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。 Base64 转码有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。 所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。 JavaScript 原生提供两个 Base64 相关的方法。 btoa()：任意值转为 Base64 编码 atob()：Base64 编码转为原来的值 123var string = &apos;Hello World!&apos;;btoa(string) // &quot;SGVsbG8gV29ybGQh&quot;atob(&apos;SGVsbG8gV29ybGQh&apos;) // &quot;Hello World!&quot; 注意，这两个方法不适合非 ASCII 码的字符，会报错。 1btoa(&apos;你好&apos;) // 报错 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。 12345678910function b64Encode(str) &#123; return btoa(encodeURIComponent(str));&#125;function b64Decode(str) &#123; return decodeURIComponent(atob(str));&#125;b64Encode(&apos;你好&apos;) // &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;b64Decode(&apos;JUU0JUJEJUEwJUU1JUE1JUJE&apos;) // &quot;你好&quot; 对象概述生成方法对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。 什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。 1234var obj = &#123; foo: &apos;Hello&apos;, bar: &apos;World&apos;&#125;; 上面代码中，大括号就定义了一个对象，它被赋值给变量obj，所以变量obj就指向一个对象。该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是foo: &#39;Hello&#39;，其中foo是“键名”（成员的名称），字符串Hello是“键值”（成员的值）。键名与键值之间用冒号分隔。第二个键值对是bar: &#39;World&#39;，bar是键名，World是键值。两个键值对之间用逗号分隔。 键名对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样。 1234var obj = &#123; &apos;foo&apos;: &apos;Hello&apos;, &apos;bar&apos;: &apos;World&apos;&#125;; 如果键名是数值，会被自动转为字符串。 1234567891011121314151617181920var obj = &#123; 1: &apos;a&apos;, 3.2: &apos;b&apos;, 1e2: true, 1e-2: true, .234: true, 0xFF: true&#125;;obj// Object &#123;// 1: &quot;a&quot;,// 3.2: &quot;b&quot;,// 100: true,// 0.01: true,// 0.234: true,// 255: true// &#125;obj[&apos;100&apos;] // true 上面代码中，对象obj的所有键名虽然看上去像数值，实际上都被自动转成了字符串。 如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 1234567891011// 报错var obj = &#123; 1p: &apos;Hello World&apos;&#125;;// 不报错var obj = &#123; &apos;1p&apos;: &apos;Hello World&apos;, &apos;h w&apos;: &apos;Hello World&apos;, &apos;p+q&apos;: &apos;Hello World&apos;&#125;; 上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。 1234567var obj = &#123; p: function (x) &#123; return 2 * x; &#125;&#125;;obj.p(1) // 2 上面代码中，对象obj的属性p，就指向一个函数。 如果属性的值还是一个对象，就形成了链式引用。 12345var o1 = &#123;&#125;;var o2 = &#123; bar: &apos;hello&apos; &#125;;o1.foo = o2;o1.foo.bar // &quot;hello&quot; 上面代码中，对象o1的属性foo指向对象o2，就可以链式引用o2的属性。 对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。 1234var obj = &#123; p: 123, m: function () &#123; ... &#125;,&#125; 上面的代码中，m属性后面的那个逗号，有没有都可以。 属性可以动态创建，不必在对象声明时就指定。 123var obj = &#123;&#125;;obj.foo = 123;obj.foo // 123 上面代码中，直接对obj对象的foo属性赋值，结果就在运行时创建了foo属性。 对象的引用如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 12345678var o1 = &#123;&#125;;var o2 = o1;o1.a = 1;o2.a // 1o2.b = 2;o1.b // 2 上面代码中，o1和o2指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。 此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。 12345var o1 = &#123;&#125;;var o2 = o1;o1 = 1;o2 // &#123;&#125; 上面代码中，o1和o2指向同一个对象，然后o1的值变为1，这时不会对o2产生影响，o2还是指向原来的那个对象。 但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。 12345var x = 1;var y = x;x = 2;y // 1 上面的代码中，当x的值发生变化后，y的值并不变，这就表示y和x并不是指向同一个内存地址。 表达式还是语句？对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？ 1&#123; foo: 123 &#125; JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含foo属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。 为了避免这种歧义，V8 引擎规定，如果行首是大括号，一律解释为对象。不过，为了避免歧义，最好在大括号前加上圆括号。 1(&#123; foo: 123&#125;) 这种差异在eval语句（作用是对字符串求值）中反映得最明显。 12eval(&apos;&#123;foo: 123&#125;&apos;) // 123eval(&apos;(&#123;foo: 123&#125;)&apos;) // &#123;foo: 123&#125; 上面代码中，如果没有圆括号，eval将其理解为一个代码块；加上圆括号以后，就理解成一个对象。 属性的操作属性的读取读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。 123456var obj = &#123; p: &apos;Hello World&apos;&#125;;obj.p // &quot;Hello World&quot;obj[&apos;p&apos;] // &quot;Hello World&quot; 上面代码分别采用点运算符和方括号运算符，读取属性p。 请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。 123456789var foo = &apos;bar&apos;;var obj = &#123; foo: 1, bar: 2&#125;;obj.foo // 1obj[foo] // 2 上面代码中，引用对象obj的foo属性时，如果使用点运算符，foo就是字符串；如果使用方括号运算符，但是不使用引号，那么foo就是一个变量，指向字符串bar。 方括号运算符内部还可以使用表达式。 12obj[&apos;hello&apos; + &apos; world&apos;]obj[3 + 3] 数字键可以不加引号，因为会自动转成字符串。 123456var obj = &#123; 0.7: &apos;Hello World&apos;&#125;;obj[&apos;0.7&apos;] // &quot;Hello World&quot;obj[0.7] // &quot;Hello World&quot; 上面代码中，对象obj的数字键0.7，加不加引号都可以，因为会被自动转为字符串。 注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。 123456var obj = &#123; 123: &apos;hello world&apos;&#125;;obj.123 // 报错obj[123] // &quot;hello world&quot; 上面代码的第一个表达式，对数值键名123使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。 属性的赋值点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。 1234var obj = &#123;&#125;;obj.foo = &apos;Hello&apos;;obj[&apos;bar&apos;] = &apos;World&apos;; 上面代码中，分别使用点运算符和方括号运算符，对属性赋值。 JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。 123456var obj = &#123; p: 1 &#125;;// 等价于var obj = &#123;&#125;;obj.p = 1; 属性的查看查看一个对象本身的所有属性，可以使用Object.keys方法。 1234567var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj);// [&apos;key1&apos;, &apos;key2&apos;] 属性的删除：delete 命令delete命令用于删除对象的属性，删除成功后返回true。 123456var obj = &#123; p: 1 &#125;;Object.keys(obj) // [&quot;p&quot;]delete obj.p // trueobj.p // undefinedObject.keys(obj) // [] 上面代码中，delete命令删除对象obj的p属性。删除后，再读取p属性就会返回undefined，而且Object.keys方法的返回值也不再包括该属性。 注意，删除一个不存在的属性，delete不报错，而且返回true。 12var obj = &#123;&#125;;delete obj.p // true 上面代码中，对象obj并没有p属性，但是delete命令照样返回true。因此，不能根据delete命令的结果，认定某个属性是存在的。 只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。 1234567var obj = Object.defineProperty(&#123;&#125;, &apos;p&apos;, &#123; value: 123, configurable: false&#125;);obj.p // 123delete obj.p // false 上面代码之中，对象obj的p属性是不能删除的，所以delete命令返回false（关于Object.defineProperty方法的介绍，请看《标准库》的 Object 对象一章）。 另外，需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性（关于继承参见《面向对象编程》章节）。 123var obj = &#123;&#125;;delete obj.toString // trueobj.toString // function toString() &#123; [native code] &#125; 上面代码中，toString是对象obj继承的属性，虽然delete命令返回true，但该属性并没有被删除，依然存在。这个例子还说明，即使delete返回true，该属性依然可能读取到值。 属性是否存在：in 运算符in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。它的左边是一个字符串，表示属性名，右边是一个对象。 123var obj = &#123; p: 1 &#125;;&apos;p&apos; in obj // true&apos;toString&apos; in obj // true in运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象obj本身并没有toString属性，但是in运算符会返回true，因为这个属性是继承的。 这时，可以使用对象的hasOwnProperty方法判断一下，是否为对象自身的属性。 1234var obj = &#123;&#125;;if (&apos;toString&apos; in obj) &#123; console.log(obj.hasOwnProperty(&apos;toString&apos;)) // false&#125; 属性的遍历：for…in 循环for...in循环用来遍历一个对象的全部属性。 123456789101112var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log(&apos;键名：&apos;, i); console.log(&apos;键值：&apos;, obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 for...in循环有两个使用注意点。 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 举例来说，对象都继承了toString属性，但是for...in循环不会遍历到这个属性。 12345678var obj = &#123;&#125;;// toString 属性是存在的obj.toString // toString() &#123; [native code] &#125;for (var p in obj) &#123; console.log(p);&#125; // 没有任何输出 上面代码中，对象obj继承了toString属性，该属性不会被for...in循环遍历到，因为它默认是“不可遍历”的。关于对象属性的可遍历性，参见《标准库》章节中 Object 一章的介绍。 如果继承的属性是可遍历的，那么就会被for...in循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用for...in的时候，应该结合使用hasOwnProperty方法，在循环内部判断一下，某个属性是否为对象自身的属性。 12345678var person = &#123; name: &apos;老张&apos; &#125;;for (var key in person) &#123; if (person.hasOwnProperty(key)) &#123; console.log(key); &#125;&#125;// name with 语句with语句的格式如下： 123with (对象) &#123; 语句;&#125; 它的作用是操作同一个对象的多个属性时，提供一些书写的方便。 1234567891011121314151617181920212223// 例一var obj = &#123; p1: 1, p2: 2,&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;// 等同于obj.p1 = 4;obj.p2 = 5;// 例二with (document.links[0])&#123; console.log(href); console.log(title); console.log(style);&#125;// 等同于console.log(document.links[0].href);console.log(document.links[0].title);console.log(document.links[0].style); 注意，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。 12345678var obj = &#123;&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;obj.p1 // undefinedp1 // 4 上面代码中，对象obj并没有p1属性，对p1赋值等于创造了一个全局变量p1。正确的写法应该是，先定义对象obj的属性p1，然后在with区块内操作它。 这是因为with区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。 123with (obj) &#123; console.log(x);&#125; 单纯从上面的代码块，根本无法判断x到底是全局变量，还是对象obj的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用with语句，可以考虑用一个临时变量代替with。 1234567with(obj1.obj2.obj3) &#123; console.log(p1 + p2);&#125;// 可以写成var temp = obj1.obj2.obj3;console.log(temp.p1 + temp.p2); 函数概述函数的声明JavaScript 有三种声明函数的方法。 （1）function 命令 function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。 123function print(s) &#123; console.log(s);&#125; 上面的代码命名了一个print函数，以后使用print()这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）。 （2）函数表达式 除了用function命令声明函数，还可以采用变量赋值的写法。 123var print = function(s) &#123; console.log(s);&#125;; 这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。 采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。 123456789var print = function x()&#123; console.log(typeof x);&#125;;x// ReferenceError: x is not definedprint()// function 上面代码在函数表达式中，加入了函数名x。这个x只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。 1var f = function f() &#123;&#125;; 需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。 （3）Function 构造函数 第三种声明函数的方式是Function构造函数。 12345678910var add = new Function( &apos;x&apos;, &apos;y&apos;, &apos;return x + y&apos;);// 等同于function add(x, y) &#123; return x + y;&#125; 上面代码中，Function构造函数接受三个参数，除了最后一个参数是add函数的“函数体”，其他参数都是add函数的参数。 你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。 12345678var foo = new Function( &apos;return &quot;hello world&quot;;&apos;);// 等同于function foo() &#123; return &apos;hello world&apos;;&#125; Function构造函数可以不使用new命令，返回结果完全一样。 总的来说，这种声明函数的方式非常不直观，几乎无人使用。 函数的重复声明如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 123456789function f() &#123; console.log(1);&#125;f() // 2function f() &#123; console.log(2);&#125;f() // 2 上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升（参见下文），前一次声明在任何时候都是无效的，这一点要特别注意。 圆括号运算符，return 语句和递归调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。 12345function add(x, y) &#123; return x + y;&#125;add(1, 1) // 2 上面代码中，函数名后面紧跟一对圆括号，就会调用这个函数。 函数体内部的return语句，表示返回。JavaScript 引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined。 函数可以调用自身，这就是递归（recursion）。下面就是通过递归，计算斐波那契数列的代码。 1234567function fib(num) &#123; if (num === 0) return 0; if (num === 1) return 1; return fib(num - 2) + fib(num - 1);&#125;fib(6) // 8 上面代码中，fib函数内部又调用了fib，计算得到斐波那契数列的第6个元素是8。 第一等公民JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。 由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。 12345678910111213function add(x, y) &#123; return x + y;&#125;// 将函数赋值给一个变量var operator = add;// 将函数作为参数和返回值function a(op)&#123; return op;&#125;a(add)(1, 1)// 2 函数名的提升JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。 123f();function f() &#123;&#125; 表面上，上面代码好像在声明之前就调用了函数f。但是实际上，由于“变量提升”，函数f被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript 就会报错。 123f();var f = function ()&#123;&#125;;// TypeError: undefined is not a function 上面的代码等同于下面的形式。 123var f;f();f = function () &#123;&#125;; 上面代码第二行，调用f的时候，f只是被声明了，还没有被赋值，等于undefined，所以会报错。因此，如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。 123456789var f = function () &#123; console.log(&apos;1&apos;);&#125;function f() &#123; console.log(&apos;2&apos;);&#125;f() // 1 函数的属性和方法name 属性函数的name属性返回函数的名字。 12function f1() &#123;&#125;f1.name // &quot;f1&quot; 如果是通过变量赋值定义的函数，那么name属性返回变量名。 12var f2 = function () &#123;&#125;;f2.name // &quot;f2&quot; 但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名。 12var f3 = function myName() &#123;&#125;;f3.name // &apos;myName&apos; 上面代码中，f3.name返回函数表达式的名字。注意，真正的函数名还是f3，而myName这个名字只在函数体内部可用。 name属性的一个用处，就是获取参数函数的名字。 1234567var myFunc = function () &#123;&#125;;function test(f) &#123; console.log(f.name);&#125;test(myFunc) // myFunc 上面代码中，函数test内部通过name属性，就可以知道传入的参数是什么函数。 length 属性函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。 12function f(a, b) &#123;&#125;f.length // 2 上面代码定义了空函数f，它的length属性就是定义时的参数个数。不管调用时输入了多少个参数，length属性始终等于2。 length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）。 toString()函数的toString方法返回一个字符串，内容是函数的源码。 123456789101112function f() &#123; a(); b(); c();&#125;f.toString()// function f() &#123;// a();// b();// c();// &#125; 函数内部的注释也可以返回。 12345678910function f() &#123;/* 这是一个 多行注释*/&#125;f.toString()// &quot;function f()&#123;/*// 这是一个// 多行注释// */&#125;&quot; 利用这一点，可以变相实现多行字符串。 12345678910111213var multiline = function (fn) &#123; var arr = fn.toString().split(&apos;\n&apos;); return arr.slice(1, arr.length - 1).join(&apos;\n&apos;);&#125;;function f() &#123;/* 这是一个 多行注释*/&#125;multiline(f);// &quot; 这是一个// 多行注释&quot; 函数作用域定义作用域（scope）指的是变量存在的范围。在 ES5 的规范中，Javascript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，本教程不涉及。 函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。 12345678var v = 1;function f() &#123; console.log(v);&#125;f()// 1 上面的代码表明，函数f内部可以读取全局变量v。 在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。 12345function f()&#123; var v = 1;&#125;v // ReferenceError: v is not defined 上面代码中，变量v在函数内部定义，所以是一个局部变量，函数之外就无法读取。 函数内部定义的变量，会在该作用域内覆盖同名全局变量。 123456789var v = 1;function f()&#123; var v = 2; console.log(v);&#125;f() // 2v // 1 上面代码中，变量v同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量v覆盖了全局变量v。 注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。 1234if (true) &#123; var x = 5;&#125;console.log(x); // 5 上面代码中，变量x在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。 函数内部的变量提升与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。 12345678910111213function foo(x) &#123; if (x &gt; 100) &#123; var tmp = x - 100; &#125;&#125;// 等同于function foo(x) &#123; var tmp; if (x &gt; 100) &#123; tmp = x - 100; &#125;;&#125; 函数本身的作用域函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。 1234567891011var a = 1;var x = function () &#123; console.log(a);&#125;;function f() &#123; var a = 2; x();&#125;f() // 1 上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。 总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。 很容易犯错的一点是，如果函数A调用函数B，却没考虑到函数B不会引用函数A的内部变量。 1234567891011var x = function () &#123; console.log(a);&#125;;function y(f) &#123; var a = 2; f();&#125;y(x)// ReferenceError: a is not defined 上面代码将函数x作为参数，传入函数y。但是，函数x是在函数y体外声明的，作用域绑定外层，因此找不到函数y的内部变量a，导致报错。 同样的，函数体内部声明的函数，作用域绑定函数体内部。 1234567891011function foo() &#123; var x = 1; function bar() &#123; console.log(x); &#125; return bar;&#125;var x = 2;var f = foo();f() // 1 上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了下文要讲解的“闭包”现象。 参数概述函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。 123456function square(x) &#123; return x * x;&#125;square(2) // 4square(3) // 9 上式的x就是square函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。 参数的省略函数参数不是必需的，Javascript 允许省略参数。 123456789function f(a, b) &#123; return a;&#125;f(1, 2, 3) // 1f(1) // 1f() // undefinedf.length // 2 上面代码的函数f定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为undefined。需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。 但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。 123456function f(a, b) &#123; return a;&#125;f( , 1) // SyntaxError: Unexpected token ,(…)f(undefined, 1) // undefined 上面代码中，如果省略第一个参数，就会报错。 传递方式函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。 12345678var p = 2;function f(p) &#123; p = 3;&#125;f(p);p // 2 上面代码中，变量p是一个原始类型的值，传入函数f的方式是传值传递。因此，在函数内部，p的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。 但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。 12345678var obj = &#123; p: 1 &#125;;function f(o) &#123; o.p = 2;&#125;f(obj);obj.p // 2 上面代码中，传入函数f的是参数对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。 注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。 12345678var obj = [1, 2, 3];function f(o) &#123; o = [2, 3, 4];&#125;f(obj);obj // [1, 2, 3] 上面代码中，在函数f内部，参数对象obj被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（o）的值实际是参数obj的地址，重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响。 同名参数如果有同名的参数，则取最后出现的那个值。 12345function f(a, a) &#123; console.log(a);&#125;f(1, 2) // 2 上面代码中，函数f有两个参数，且参数名都是a。取值的时候，以后面的a为准，即使后面的a没有值或被省略，也是以其为准。 12345function f(a, a) &#123; console.log(a);&#125;f(1) // undefined 调用函数f的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。 12345function f(a, a) &#123; console.log(arguments[0]);&#125;f(1) // 1 arguments 对象（1）定义 由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。 arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。 12345678910var f = function (one) &#123; console.log(arguments[0]); console.log(arguments[1]); console.log(arguments[2]);&#125;f(1, 2, 3)// 1// 2// 3 正常模式下，arguments对象可以在运行时修改。 1234567var f = function(a, b) &#123; arguments[0] = 3; arguments[1] = 2; return a + b;&#125;f(1, 1) // 5 上面代码中，函数f调用时传入的参数，在函数内部被修改成3和2。 严格模式下，arguments对象是一个只读对象，修改它是无效的，但不会报错。 12345678var f = function(a, b) &#123; &apos;use strict&apos;; // 开启严格模式 arguments[0] = 3; // 无效 arguments[1] = 2; // 无效 return a + b;&#125;f(1, 1) // 2 上面代码中，函数体内是严格模式，这时修改arguments对象就是无效的。 通过arguments对象的length属性，可以判断函数调用时到底带几个参数。 1234567function f() &#123; return arguments.length;&#125;f(1, 2, 3) // 3f(1) // 1f() // 0 （2）与数组的关系 需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。 如果要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。 1234567var args = Array.prototype.slice.call(arguments);// 或者var args = [];for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]);&#125; （3）callee 属性 arguments对象带有一个callee属性，返回它所对应的原函数。 12345var f = function () &#123; console.log(arguments.callee === f);&#125;f() // true 可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。 函数的其他知识点闭包闭包（closure）是 Javascript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。 123456var n = 999;function f1() &#123; console.log(n);&#125;f1() // 999 上面代码中，函数f1可以读取全局变量n。 但是，函数外部无法读取函数内部声明的变量。 123456function f1() &#123; var n = 999;&#125;console.log(n)// Uncaught ReferenceError: n is not defined( 上面代码中，函数f1内部声明的变量n，函数外是无法读取的。 如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。 123456function f1() &#123; var n = 999; function f2() &#123; console.log(n); // 999 &#125;&#125; 上面代码中，函数f2就在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！ 12345678910function f1() &#123; var n = 999; function f2() &#123; console.log(n); &#125; return f2;&#125;var result = f1();result(); // 999 上面代码中，函数f1的返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1的内部变量了。 闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。 1234567891011function createIncrementor(start) &#123; return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);inc() // 5inc() // 6inc() // 7 上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。 为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。 闭包的另一个用处，是封装对象的私有属性和私有方法。 12345678910111213141516171819function Person(name) &#123; var _age; function setAge(n) &#123; _age = n; &#125; function getAge() &#123; return _age; &#125; return &#123; name: name, getAge: getAge, setAge: setAge &#125;;&#125;var p1 = Person(&apos;张三&apos;);p1.setAge(25);p1.getAge() // 25 上面代码中，函数Person的内部变量_age，通过闭包getAge和setAge，变成了返回对象p1的私有变量。 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。 立即调用的函数表达式（IIFE）在 Javascript 中，圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。 有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。 12function()&#123; /* code */ &#125;();// SyntaxError: Unexpected token ( 产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。 12345// 语句function f() &#123;&#125;// 表达式var f = function f() &#123;&#125; 为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。因此，JavaScript 引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。 解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。 123(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)(); 上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。 注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。 123// 报错(function()&#123; /* code */ &#125;())(function()&#123; /* code */ &#125;()) 上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，将第二行解释为第一行的参数。 推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。 123var i = function()&#123; return 10; &#125;();true &amp;&amp; function()&#123; /* code */ &#125;();0, function()&#123; /* code */ &#125;(); 甚至像下面这样写，也是可以的。 1234!function () &#123; /* code */ &#125;();~function () &#123; /* code */ &#125;();-function () &#123; /* code */ &#125;();+function () &#123; /* code */ &#125;(); 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 1234567891011// 写法一var tmp = newData;processData(tmp);storeData(tmp);// 写法二(function () &#123; var tmp = newData; processData(tmp); storeData(tmp);&#125;()); 上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。 eval 命令基本用法eval命令接受一个字符串作为参数，并将这个字符串当作语句执行。 12eval(&apos;var a = 1;&apos;);a // 1 上面代码将字符串当作语句运行，生成了变量a。 如果参数字符串无法当作语句运行，那么就会报错。 1eval(&apos;3x&apos;) // Uncaught SyntaxError: Invalid or unexpected token 放在eval中的字符串，应该有独自存在的意义，不能用来与eval以外的命令配合使用。举例来说，下面的代码将会报错。 1eval(&apos;return;&apos;); // Uncaught SyntaxError: Illegal return statement 上面代码会报错，因为return不能单独使用，必须在函数中使用。 如果eval的参数不是字符串，那么会原样返回。 1eval(123) // 123 eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。 1234var a = 1;eval(&apos;a = 2&apos;);a // 2 上面代码中，eval命令修改了外部变量a的值。由于这个原因，eval有安全风险。 为了防止这种风险，JavaScript 规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。 12345(function f() &#123; &apos;use strict&apos;; eval(&apos;var foo = 123&apos;); console.log(foo); // ReferenceError: foo is not defined&#125;)() 上面代码中，函数f内部是严格模式，这时eval内部声明的foo变量，就不会影响到外部。 不过，即使在严格模式下，eval依然可以读写当前作用域的变量。 123456(function f() &#123; &apos;use strict&apos;; var foo = 1; eval(&apos;foo = 2&apos;); console.log(foo); // 2&#125;)() 上面代码中，严格模式下，eval内部还是改写了外部变量，可见安全风险依然存在。 总之，eval的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，所以一般不推荐使用。通常情况下，eval最常见的场合是解析 JSON 数据的字符串，不过正确的做法应该是使用原生的JSON.parse方法。 eval 的别名调用前面说过eval不利于引擎优化执行速度。更麻烦的是，还有下面这种情况，引擎在静态代码分析的阶段，根本无法分辨执行的是eval。 123var m = eval;m(&apos;var x = 1&apos;);x // 1 上面代码中，变量m是eval的别名。静态代码分析阶段，引擎分辨不出m(&#39;var x = 1&#39;)执行的是eval命令。 为了保证eval的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行eval，eval内部一律是全局作用域。 123456789var a = 1;function f() &#123; var a = 2; var e = eval; e(&apos;console.log(a)&apos;);&#125;f() // 1 上面代码中，eval是别名调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的a为全局变量。这样的话，引擎就能确认e()不会对当前的函数作用域产生影响，优化的时候就可以把这一行排除掉。 eval的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨eval()这一种形式是直接调用。 1234eval.call(null, &apos;...&apos;)window.eval(&apos;...&apos;)(1, eval)(&apos;...&apos;)(eval, eval)(&apos;...&apos;) 上面这些形式都是eval的别名调用，作用域都是全局作用域。 数组定义数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。 1var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]; 上面代码中的a、b、c就构成一个数组，两端的方括号是数组的标志。a是0号位置，b是1号位置，c是2号位置。 除了在定义时赋值，数组也可以先定义后赋值。 12345var arr = [];arr[0] = &apos;a&apos;;arr[1] = &apos;b&apos;;arr[2] = &apos;c&apos;; 任何类型的数据，都可以放入数组。 123456789var arr = [ &#123;a: 1&#125;, [1, 2, 3], function() &#123;return true;&#125;];arr[0] // Object &#123;a: 1&#125;arr[1] // [1, 2, 3]arr[2] // function ()&#123;return true;&#125; 上面数组arr的3个成员依次是对象、数组、函数。 如果数组的元素还是数组，就形成了多维数组。 123var a = [[1, 2], [3, 4]];a[0][1] // 2a[1][1] // 4 数组的本质本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。 1typeof [1, 2, 3] // &quot;object&quot; 上面代码表明，typeof运算符认为数组的类型就是对象。 数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。 1234var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];Object.keys(arr)// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;] 上面代码中，Object.keys方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。 由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。 1234var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];arr[&apos;0&apos;] // &apos;a&apos;arr[0] // &apos;a&apos; 上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串。 注意，这点在赋值时也成立。如果一个值总是先转成字符串，再进行赋值。 1234var a = [];a[1.00] = 6;a[1] // 6 上面代码中，由于1.00转成字符串是1，所以通过数字键1可以读取值。 上一章说过，对象有两种读取成员的方法：点结构（object.key）和方括号结构（object[key]）。但是，对于数值的键名，不能使用点结构。 12var arr = [1, 2, 3];arr.0 // SyntaxError 上面代码中，arr.0的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号arr[0]表示（方括号是运算符，可以接受数值）。 length 属性数组的length属性，返回数组的成员数量。 1[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].length // 3 JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（232 - 1）个，也就是说length属性的最大值就是 4294967295。 只要是数组，就一定有length属性。该属性是一个动态的值，等于键名中的最大整数加上1。 1234567891011var arr = [&apos;a&apos;, &apos;b&apos;];arr.length // 2arr[2] = &apos;c&apos;;arr.length // 3arr[9] = &apos;d&apos;;arr.length // 10arr[1000] = &apos;e&apos;;arr.length // 1001 上面代码表示，数组的数字键不需要连续，length属性的值总是比最大的那个整数键大1。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。 length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。 12345var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];arr.length // 3arr.length = 2;arr // [&quot;a&quot;, &quot;b&quot;] 上面代码表示，当数组的length属性设为2（即最大的整数键只能是1）那么整数键2（值为c）就已经不在数组中了，被自动删除了。 清空数组的一个有效方法，就是将length属性设为0。 1234var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];arr.length = 0;arr // [] 如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。 1234var a = [&apos;a&apos;];a.length = 3;a[1] // undefined 上面代码表示，当length属性设为大于数组个数时，读取新增的位置都会返回undefined。 如果人为设置length为不合法的值，JavaScript 会报错。 1234567891011// 设置负值[].length = -1// RangeError: Invalid array length// 数组元素个数大于等于2的32次方[].length = Math.pow(2, 32)// RangeError: Invalid array length// 设置字符串[].length = &apos;abc&apos;// RangeError: Invalid array length 值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值。 1234567var a = [];a[&apos;p&apos;] = &apos;abc&apos;;a.length // 0a[2.1] = &apos;abc&apos;;a.length // 0 上面代码将数组的键分别设为字符串和小数，结果都不影响length属性。因为，length属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以length属性保持为0。 如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。 1234567var arr = [];arr[-1] = &apos;a&apos;;arr[Math.pow(2, 32)] = &apos;b&apos;;arr.length // 0arr[-1] // &quot;a&quot;arr[4294967296] // &quot;b&quot; 上面代码中，我们为数组arr添加了两个不合法的数字键，结果length属性没有发生变化。这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串。 in 运算符检查某个键名是否存在的运算符in，适用于对象，也适用于数组。 1234var arr = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ];2 in arr // true&apos;2&apos; in arr // true4 in arr // false 上面代码表明，数组存在键名为2的键。由于键名都是字符串，所以数值2会自动转成字符串。 注意，如果数组的某个位置是空位，in运算符返回false。 12345var arr = [];arr[100] = &apos;a&apos;;100 in arr // true1 in arr // false 上面代码中，数组arr只有一个成员arr[100]，其他位置的键名都会返回false。 for…in 循环和数组的遍历for...in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。 12345678var a = [1, 2, 3];for (var i in a) &#123; console.log(a[i]);&#125;// 1// 2// 3 但是，for...in不仅会遍历数组所有的数字键，还会遍历非数字键。 12345678910var a = [1, 2, 3];a.foo = true;for (var key in a) &#123; console.log(key);&#125;// 0// 1// 2// foo 上面代码在遍历数组时，也遍历到了非整数键foo。所以，不推荐使用for...in遍历数组。 数组的遍历可以考虑使用for循环或while循环。 123456789101112131415161718var a = [1, 2, 3];// for循环for(var i = 0; i &lt; a.length; i++) &#123; console.log(a[i]);&#125;// while循环var i = 0;while (i &lt; a.length) &#123; console.log(a[i]); i++;&#125;var l = a.length;while (l--) &#123; console.log(a[l]);&#125; 上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历。 数组的forEach方法，也可以用来遍历数组，详见《标准库》的 Array 对象一章。 1234567var colors = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];colors.forEach(function (color) &#123; console.log(color);&#125;);// red// green// blue 数组的空位当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。 12var a = [1, , 1];a.length // 3 上面代码表明，数组的空位不影响length属性。 需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。 1234var a = [1, 2, 3,];a.length // 3a // [1, 2, 3] 上面代码中，数组最后一个成员后面有一个逗号，这不影响length属性的值，与没有这个逗号时效果一样。 数组的空位是可以读取的，返回undefined。 12var a = [, , ,];a[1] // undefined 使用delete命令删除一个数组成员，会形成空位，并且不会影响length属性。 12345var a = [1, 2, 3];delete a[1];a[1] // undefineda.length // 3 上面代码用delete命令删除了数组的第二个元素，这个位置就形成了空位，但是对length属性没有影响。也就是说，length属性不过滤空位。所以，使用length属性进行数组遍历，一定要非常小心。 数组的某个位置是空位，与某个位置是undefined，是不一样的。如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过。 1234567891011121314var a = [, , ,];a.forEach(function (x, i) &#123; console.log(i + &apos;. &apos; + x);&#125;)// 不产生任何输出for (var i in a) &#123; console.log(i);&#125;// 不产生任何输出Object.keys(a)// [] 如果某个位置是undefined，遍历的时候就不会被跳过。 123456789101112131415161718var a = [undefined, undefined, undefined];a.forEach(function (x, i) &#123; console.log(i + &apos;. &apos; + x);&#125;);// 0. undefined// 1. undefined// 2. undefinedfor (var i in a) &#123; console.log(i);&#125;// 0// 1// 2Object.keys(a)// [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;] 这就是说，空位就是数组没有这个元素，所以不会被遍历到，而undefined则表示数组有这个元素，值是undefined，所以遍历不会跳过。 类似数组的对象如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。 1234567891011var obj = &#123; 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos;, length: 3&#125;;obj[0] // &apos;a&apos;obj[1] // &apos;b&apos;obj.length // 3obj.push(&apos;d&apos;) // TypeError: obj.push is not a function 上面代码中，对象obj就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象obj没有数组的push方法，使用该方法就会报错。 “类似数组的对象”的根本特征，就是具有length属性。只要有length属性，就可以认为这个对象类似于数组。但是有一个问题，这种length属性不是动态值，不会随着成员的变化而变化。 12345var obj = &#123; length: 0&#125;;obj[3] = &apos;d&apos;;obj.length // 0 上面代码为对象obj添加了一个数字键，但是length属性没变。这就说明了obj不是数组。 典型的“类似数组的对象”是函数的arguments对象，以及大多数 DOM 元素集，还有字符串。 1234567891011121314151617// arguments对象function args() &#123; return arguments &#125;var arrayLike = args(&apos;a&apos;, &apos;b&apos;);arrayLike[0] // &apos;a&apos;arrayLike.length // 2arrayLike instanceof Array // false// DOM元素集var elts = document.getElementsByTagName(&apos;h3&apos;);elts.length // 3elts instanceof Array // false// 字符串&apos;abc&apos;[1] // &apos;b&apos;&apos;abc&apos;.length // 3&apos;abc&apos; instanceof Array // false 上面代码包含三个例子，它们都不是数组（instanceof运算符返回false），但是看上去都非常像数组。 数组的slice方法可以将“类似数组的对象”变成真正的数组。 1var arr = Array.prototype.slice.call(arrayLike); 除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过call()把数组的方法放到对象上面。 12345function print(value, index) &#123; console.log(index + &apos; : &apos; + value);&#125;Array.prototype.forEach.call(arrayLike, print); 上面代码中，arrayLike代表一个类似数组的对象，本来是不可以使用数组的forEach()方法的，但是通过call()，可以把forEach()嫁接到arrayLike上面调用。 下面的例子就是通过这种方法，在arguments对象上面调用forEach方法。 12345678910111213// forEach 方法function logArgs() &#123; Array.prototype.forEach.call(arguments, function (elem, i) &#123; console.log(i + &apos;. &apos; + elem); &#125;);&#125;// 等同于 for 循环function logArgs() &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; console.log(i + &apos;. &apos; + arguments[i]); &#125;&#125; 字符串也是类似数组的对象，所以也可以用Array.prototype.forEach.call遍历。 123456Array.prototype.forEach.call(&apos;abc&apos;, function (chr) &#123; console.log(chr);&#125;);// a// b// c 注意，这种方法比直接使用数组原生的forEach要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的forEach方法。 1234567var arr = Array.prototype.slice.call(&apos;abc&apos;);arr.forEach(function (chr) &#123; console.log(chr);&#125;);// a// b// c 本文截取阮一峰老师JavaScript入门教程，原文请查看JavaScript 教程。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记（一）入门篇]]></title>
    <url>%2F2018%2F11%2F19%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[导论什么是 JavaScript 语言？JavaScript 是一门动态类型，面向对象的脚本语言，同时也是一种嵌入式（embedded）语言。主要依靠嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。目前，已经嵌入 JavaScript 的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。JavaScript 的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（就是一系列具有各种功能的对象比如Array、Date、Math等）。除此之外，各种宿主环境提供额外的 API（即只能在该环境使用的接口），以便 JavaScript 调用。以浏览器为例，它提供的额外 API 可以分成三大类。 浏览器控制类：操作浏览器 DOM 类：操作网页的各种元素 Web 类：实现互联网的各种功能 如果宿主环境是服务器，则会提供各种操作系统的 API，比如文件操作 API、网络通信 API等等。这些你都可以在 Node 环境中找到。 为什么学习 JavaScript？ 操控浏览器的能力 广泛的使用领域 易学性 强大的性能 开放性 社区支持和就业机会 JavaScript 与 Java 的关系?它们是两种不一样的语言，但是彼此存在联系。JavaScript 语法要比 Java 自由得多。另外，Java 语言需要编译，而 JavaScript 语言则是运行时由解释器直接执行。 JavaScript 与 ECMAScript 的关系?1996年11月，Netscape 公司决定将 JavaScript 提交给国际标准化组织 ECMA（European Computer Manufacturers Association），希望 JavaScript 能够成为国际标准，以此抵抗微软。 1997年7月，ECMA 组织发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript。 ECMAScript 只用来标准化 JavaScript 这种语言的基本语法结构，与部署环境相关的标准都由其他标准规定，比如 DOM 的标准就是由 W3C组织（World Wide Web Consortium）制定的。 基本语法语句JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。 语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。 1var a = 1 + 3; 这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。 1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。 语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。 1var a = 1 + 3 ; var b = &apos;abc&apos;; 分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。 1;;; 上面的代码就表示3个空语句。 表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。 121 + 3;&apos;abc&apos;; 上面两行语句只是单纯地产生一个值，并没有任何实际的意义。 变量概念变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。 1var a = 1; 上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，称为将数值1“赋值”给变量a。以后，引用变量名a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。 注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量。 变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。 12var a;a = 1; 如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个特殊的值，表示“无定义”。 12var a;a // undefined 如果变量赋值的时候，忘了写var命令，这条语句也是有效的。 123var a = 1;// 基本等同a = 1; 但是，不写var的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用var命令声明变量。 如果一个变量没有声明就直接使用，JavaScript 会报错，告诉你变量未定义。 12x// ReferenceError: x is not defined 上面代码直接使用变量x，系统就报错，告诉你变量x没有声明。 可以在同一条var命令中声明多个变量。 1var a, b; JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。 12var a = 1;a = &apos;hello&apos;; 上面代码中，变量a起先被赋值为一个数值，后来又被重新赋值为一个字符串。第二次赋值的时候，因为变量a已经存在，所以不需要使用var命令。 如果使用var重新声明一个已经存在的变量，是无效的。 123var x = 1;var x;x // 1 上面代码中，变量x声明了两次，第二次声明是无效的。 但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。 12345678var x = 1;var x = 2;// 等同于var x = 1;var x;x = 2; 变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。 12console.log(a);var a = 1; 上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。 123var a;console.log(a);a = 1; 最后的结果是显示undefined，表示变量a已声明，但还未赋值。 标识符标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。 标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。 简单说，标识符命名规则如下。 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。 下面这些都是合法的标识符。 1234arg0_tmp$elemπ 下面这些则是不合法的标识符。 123451a // 第一个字符不能是数字23 // 同上*** // 标识符不能包含星号a+b // 标识符不能包含加号-d // 标识符不能包含减号或连词线 中文是合法的标识符，可以用作变量名。 1var 临时变量 = 1; JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 注释源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。Javascript 提供两种注释的写法：一种是单行注释，用//起头；另一种是多行注释，放在/*和*/之间。 1234567// 这是单行注释/* 这是 多行 注释*/ 此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以&lt;!--和--&gt;也被视为合法的单行注释。 12x = 1; &lt;!-- x = 2;--&gt; x = 3; 上面代码中，只有x = 1会执行，其他的部分都被注释掉了。 需要注意的是，--&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。 1234567function countdown(n) &#123; while (n --&gt; 0) console.log(n);&#125;countdown(3)// 2// 1// 0 上面代码中，n --&gt; 0实际上会当作n-- &gt; 0，因此输出2、1、0。 区块JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。 对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。 12345&#123; var a = 1;&#125;a // 1 上面代码在区块内部，使用var命令声明并赋值了变量a，然后在区块外部，变量a依然有效，区块对于var命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 JavaScript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如for、if、while、function等。 条件语句JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。 if 结构if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，true表示真，false表示伪。 12345if (布尔值) 语句;// 或者if (布尔值) 语句; 上面是if结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为true，就执行紧跟在后面的语句；如果结果为false，则跳过紧跟在后面的语句。 12if (m === 3) m = m + 1; 上面代码表示，只有在m等于3时，才会将其值加上1。 这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在if的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。 123if (m === 3) &#123; m += 1;&#125; 建议总是在if语句中使用大括号，因为这样方便插入语句。 注意，if后面的表达式之中，不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。 123456var x = 1;var y = 2;if (x = y) &#123; console.log(x);&#125;// &quot;2&quot; 上面代码的原意是，当x等于y的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将y赋值给变量x，再判断变量x的值（等于2）的布尔值（结果为true）。 这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。 12if (x = 2) &#123; // 不报错if (2 = x) &#123; // 报错 至于为什么优先采用“严格相等运算符”（===），而不是“相等运算符”（==），请参考《运算符》章节。 if…else 结构if代码块后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。 12345if (m === 3) &#123; // 满足条件时，执行的语句&#125; else &#123; // 不满足条件时，执行的语句&#125; 上面代码判断变量m是否等于3，如果等于就执行if代码块，否则执行else代码块。 对同一个变量进行多次判断时，多个if...else语句可以连写在一起。 123456789if (m === 0) &#123; // ...&#125; else if (m === 1) &#123; // ...&#125; else if (m === 2) &#123; // ...&#125; else &#123; // ...&#125; else代码块总是与离自己最近的那个if语句配对。 123456var m = 1;var n = 2;if (m !== 1)if (n === 2) console.log(&apos;hello&apos;);else console.log(&apos;world&apos;); 上面代码不会有任何输出，else代码块不会得到执行，因为它跟着的是最近的那个if语句，相当于下面这样。 1234567if (m !== 1) &#123; if (n === 2) &#123; console.log(&apos;hello&apos;); &#125; else &#123; console.log(&apos;world&apos;); &#125;&#125; 如果想让else代码块跟随最上面的那个if语句，就要改变大括号的位置。 12345678if (m !== 1) &#123; if (n === 2) &#123; console.log(&apos;hello&apos;); &#125;&#125; else &#123; console.log(&apos;world&apos;);&#125;// world switch 结构多个if...else连在一起使用的时候，可以转为使用更方便的switch结构。 12345678910switch (fruit) &#123; case &quot;banana&quot;: // ... break; case &quot;apple&quot;: // ... break; default: // ...&#125; 上面代码根据变量fruit的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分。需要注意的是，每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。 12345678910111213var x = 1;switch (x) &#123; case 1: console.log(&apos;x 等于1&apos;); case 2: console.log(&apos;x 等于2&apos;); default: console.log(&apos;x 等于其他值&apos;);&#125;// x等于1// x等于2// x等于其他值 上面代码中，case代码块之中没有break语句，导致不会跳出switch结构，而会一直执行下去。正确的写法是像下面这样。 12345678910switch (x) &#123; case 1: console.log(&apos;x 等于1&apos;); break; case 2: console.log(&apos;x 等于2&apos;); break; default: console.log(&apos;x 等于其他值&apos;);&#125; switch语句部分和case语句部分，都可以使用表达式。 1234567switch (1 + 3) &#123; case 2 + 2: f(); break; default: neverHappens();&#125; 上面代码的default部分，是永远不会执行到的。 需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。 12345678910var x = 1;switch (x) &#123; case true: console.log(&apos;x 发生类型转换&apos;); break; default: console.log(&apos;x 没有发生类型转换&apos;);&#125;// x 没有发生类型转换 上面代码中，由于变量x没有发生类型转换，所以不会执行case true的情况。这表明，switch语句内部采用的是“严格相等运算符”，详细解释请参考《运算符》一节。 三元运算符 ?:JavaScript 还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断。 1(条件) ? 表达式1 : 表达式2 上面代码中，如果“条件”为true，则返回“表达式1”的值，否则返回“表达式2”的值。 1var even = (n % 2 === 0) ? true : false; 上面代码中，如果n可以被2整除，则even等于true，否则等于false。它等同于下面的形式。 123456var even;if (n % 2 === 0) &#123; even = true;&#125; else &#123; even = false;&#125; 这个三元运算符可以被视为if...else...的简写形式，因此可以用于多种场合。 1234567var myVar;console.log( myVar ? &apos;myVar has a value&apos; : &apos;myVar does not have a value&apos;)// myVar does not have a value 上面代码利用三元运算符，输出相应的提示。 1var msg = &apos;数字&apos; + n + &apos;是&apos; + (n % 2 === 0 ? &apos;偶数&apos; : &apos;奇数&apos;); 上面代码利用三元运算符，在字符串之中插入不同的值。 循环语句循环语句用于重复执行某个操作，它有多种形式。 while 循环While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。 12345while (条件) 语句;// 或者while (条件) 语句; while语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。 123while (条件) &#123; 语句;&#125; 下面是while语句的一个例子。 123456var i = 0;while (i &lt; 100) &#123; console.log(&apos;i 当前为：&apos; + i); i = i + 1;&#125; 上面的代码将循环100次，直到i等于100为止。 下面的例子是一个无限循环，因为循环条件总是为真。 123while (true) &#123; console.log(&apos;Hello, world&apos;);&#125; for 循环for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。 12345678for (初始化表达式; 条件; 递增表达式) 语句// 或者for (初始化表达式; 条件; 递增表达式) &#123; 语句&#125; for语句后面的括号里面，有三个表达式。 初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。 条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。 递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。 下面是一个例子。 1234567var x = 3;for (var i = 0; i &lt; x; i++) &#123; console.log(i);&#125;// 0// 1// 2 上面代码中，初始化表达式是var i = 0，即初始化一个变量i；测试表达式是i &lt; x，即只要i小于x，就会执行循环；递增表达式是i++，即每次循环结束后，i增大1。 所有for循环，都可以改写成while循环。上面的例子改为while循环，代码如下。 1234567var x = 3;var i = 0;while (i &lt; x) &#123; console.log(i); i++;&#125; for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。 123for ( ; ; )&#123; console.log(&apos;Hello World&apos;);&#125; 上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。 do…while 循环do...while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。 12345678do 语句while (条件);// 或者do &#123; 语句&#125; while (条件); 不管条件是否为真，do...while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号注意不要省略。 下面是一个例子。 1234567var x = 3;var i = 0;do &#123; console.log(i); i++;&#125; while(i &lt; x); break 语句和 continue 语句break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。 break语句用于跳出代码块或循环。 1234567var i = 0;while(i &lt; 100) &#123; console.log(&apos;i 当前为：&apos; + i); i++; if (i === 10) break;&#125; 上面代码只会执行10次循环，一旦i等于10，就会跳出循环。 for循环也可以使用break语句跳出循环。 123456789for (var i = 0; i &lt; 5; i++) &#123; console.log(i); if (i === 3) break;&#125;// 0// 1// 2// 3 上面代码执行到i等于3，就会跳出循环。 continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 1234567var i = 0;while (i &lt; 100)&#123; i++; if (i % 2 === 0) continue; console.log(&apos;i 当前为：&apos; + i);&#125; 上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。 如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。 标签（label）JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。 12label: 语句 标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。 标签通常与break语句和continue语句配合使用，跳出特定的循环。 1234567891011top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) break top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0 上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。 标签也可以用于跳出代码块。 12345678foo: &#123; console.log(1); break foo; console.log(&apos;本行不会输出&apos;);&#125;console.log(2);// 1// 2 上面代码执行到break foo，就会跳出区块。 continue语句也可以与标签配合使用。 1234567891011121314top: for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (i === 1 &amp;&amp; j === 1) continue top; console.log(&apos;i=&apos; + i + &apos;, j=&apos; + j); &#125; &#125;// i=0, j=0// i=0, j=1// i=0, j=2// i=1, j=0// i=2, j=0// i=2, j=1// i=2, j=2 上面代码中，continue命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。 本文截取阮一峰老师JavaScript入门教程，原文请查看JavaScript 教程。]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构入门]]></title>
    <url>%2F2018%2F11%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[本文简要介绍各种数据结构，算是入门吧： 哈希表 队列 栈 链表 树 堆排序 1.哈希表（Hash Table） 符合键值对关系都是哈希，数组，对象都是哈希 计数排序中的桶（复杂度 O(n+max)，比快排（复杂度 nlogn）还快，缺点：计数排序无法负数和小数 桶排序 与计数排序的区别， 桶排序是计数排序的改良版 一个桶放一个范围内的数字，范围自定义，第一个桶永远不会与其他的桶内数字进行比较，桶内的数字可以使用快排或者再使用桶排序。。 桶排序相对节约空间，但桶里面的数据需要二次排序，浪费时间 基数排序 与计数排序的区别 计数数组适合10以内的排序，大于10的用基数排序 十进制的基数为10，拿出十个桶，每次从个位数开始入桶，到十位，百位，千位，循环完所有数字，之后每次通过先进先出从桶里拿出来完成排序。 基数排序可以适应特别大的数字，且比桶排序节约桶 排序的原则 要么浪费空间，要么浪费时间，只能选一个进行优化 2.队列（Queue） 先进先出 可以用数组实现， push与shift 举例：排队 3.栈（Stack） 先进后出 可以用数组实现，push与pop 举例：盗梦空间 4.链表（Linked List） 数组无法直接删除中间的一项，链表（多个哈希连起来的）可以改变指向，进行数据的删除 用哈希（JS里面用对象表示哈希）实现链表 链表头称为head、链节称为node 5.树（tree） 由链表构成的树，层级结构、DOM 层数、深度、节点数 二叉树（每次最多分两个叉）第i层有2^i个节点，总共有2^(i+1)-1个节点 满二叉树（每次都是两个分支） 完全二叉树（右边连续的没有长叶子） 数组可以表示完全二叉树和满二叉树，不能表示三叉树，四叉树，。。。其他树可以用哈希（对象）实现 操作：增删改查 堆排序用到了 tree 其他：B树、红黑树、AVL树 6.堆排序：头狼之争（复杂度 nlogn） 堆是一种特殊的树，父节点永远大于子节点 最大堆：最大元素在根节点 最大堆调整：图下的 4 不符合最大堆概念，找他的子节点中最大的替换，再去检查替换后位置的子节点，发现8&gt;4,将4 与 8 替换，由于替换后的4没有子节点，此时这个堆是最大堆 堆排序：将数组表示成完全二叉树，从他的叶子开始最大堆调整，使所有的树苗都是最大堆，只要整个二叉树是一个绝对最大堆，拿到当前堆里面的最大数（顶端head），把这个数放在数组最右边隐藏掉，然后把树最右下方的叶子放在最顶端位置，然后进行调整得到第二个最大堆，拿到最大值放在数组右边隐藏掉，然后把树最右下方的叶子放在最顶端位置，。。。。。直到只剩一个数为止。 堆排序查看 ：排序算法入门（二）堆排序 计数排序，桶排序查看：排序算法入门(三) 计数排序，桶排序]]></content>
      <categories>
        <category>基础知识</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法入门(三) 计数排序，桶排序]]></title>
    <url>%2F2018%2F11%2F17%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%A1%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[计数排序：原理：与比较排序注重于元素之间的比较不同，计数排序专注于找准自己的位置，而不关心自己比谁小，比谁大。其核心在于，对于任意一个属于数组array的元素number，统计其在array内出现的次数，将其以键值对的形式保存在hash，如果hash没有number，使hash[nmber] = 1,并且与max做对比是否需要重置max（max是hash的最大键，也可以理解为共有多少的桶。。），否则hash[number]++,形成hash后，将其按顺序push到新数组newArr。 计数排序可视化：https://visualgo.net/zh/sorting 点击COU 流程图：计数排序伪代码：12345678910111213141516171819202122232425262728293031323334353637a &lt;- &#123;&apos;0&apos;:0,&apos;1&apos;:2,&apos;2&apos;:1,&apos;3&apos;:56,&apos;4&apos;:4,&apos;5&apos;:67,&apos;6&apos;:3,&apos;length:7&apos;&#125; //构建数组ahash &lt;- &#123;&#125; //构建哈希index &lt;- 0 //初始值底标while index &lt; a[&apos;length&apos;] //遍历数组anumber &lt;- a[index] //将数组a的每个值记下来if hash[number] == undefined //该值在 hash[number] 中还不存在hash[number] = 1 //将该值记入hash中，并标记出现了1次elsehash[number] &lt;- hash[number] + 1 //每多出现一次加次1endindex &lt;- index + 1 //遍历所有底标endindex2 &lt;- 0 //定义一个新的底标max &lt;- findMax(a) //最大值67newArr &lt;- &#123;&#125; //定义一个新数组while index2 &lt;= max //遍历原数组的所有值 count &lt;- hash[index2] //将hash的每个底标所对应的数提取出来if count != undefined //如果该数（count） 存在countIndex &lt;- 0 //给该值初始一个新底标值0while countIndex &lt; count //遍历该值所对应的个数newArr.push(index2) //将所有该值输入到新数组中countIndex &lt;- countIndex + 1 endendindex2 &lt;- index2 + 1 //对应 while index2 &lt;= max，遍历数组所有底标endprint newArr 1、先将数组a，用”值：值出现的次数“的形式，写入hash表； 遍历数组a，提取键名， 提取键名出现的次数， 2、再将hash表中的值展开放到一个新数组中； 找出hash中的最大值，从零开始，0-max， 依次确认是否出现过和出现的次数，出现几次就依次加入到新数组中几次， 3、打印该数组。 javascript代码： 12345678910111213141516171819202122232425262728293031/* * @i 原数组索引 * @hashIndex hash内键值对的键 * @countIndex hash内键值对的值 */function CountingSort(array) &#123; let hash = &#123;&#125;, max = array[0], newArr = []; for (let i = 0; i &lt; array.length; i++) &#123; let number = array[i]; if (hash[number]) &#123; hash[number]++ &#125; else &#123; hash[number] = 1; if (number &gt; max) &#123; max = number &#125; &#125; &#125; for (let hashIndex = 0; hashIndex &lt; max + 1; hashIndex++) &#123; let count = hash[hashIndex]; if (count) &#123; for (let countIndex = 0; countIndex &lt; count; countIndex++) &#123; newArr.push(hashIndex); &#125; &#125; &#125; return newArr;&#125;console.log(CountingSort([3, 0,4, 1, 5, 6, 8, 1, 5, 4, 9, 5])); 桶排序：原理：将数组按照步长放在不同的桶里，桶的数量根据数组长度和步长确定，数组全部入桶之后，每个桶内进行排序，按顺序将所有桶的数据合并。 难点：桶的数量，左右边缘的计算 桶排序可视化：Bucket Sort Visualization 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * @array 原始数组 * @step 每个桶的步长：比如step = 3;表示一个桶放连续的3个数字，比如 0,1,2 | 3,4,5 |6,7,8 * @bucket 二维数组保存数组 * @bucketCount 桶的数量 * @bucketL 每个桶的长度 * @max 数组最大值 * @min 数组最小值 * @ i 原数组索引 * @ j 桶的索引 * @ z bucket的索引 * @temp 临时保存每一项 * @newArr 新数组 */function BucketSort(array, step) &#123; let temp, bucketL = 0, bucket = [], l = array.length, max = Math.max(...array), min = Math.min(...array), bucketCount = Math.ceil((max - min + 1) / step), newArr = []; // 入桶 for (let i = 0; i &lt; l; i++) &#123; temp = array[i]; for (let j = 0; j &lt; bucketCount; j++) &#123; // 初始化 if (!bucket[j]) &#123; bucket[j] = []; &#125; bucketL = bucket[j].length; if (temp &gt;= min + j * step &amp;&amp; temp &lt;= min + j * step + step - 1) &#123; bucket[j].push(temp); if (bucketL &gt; 0) &#123; // 桶内排序 插入排序 for (let k = bucketL - 1; k &gt;= 0; k--) &#123; if (temp &lt; bucket[j][k]) &#123; bucket[j].splice(k, 0, temp); bucket[j].splice(k + 2, 1) &#125; &#125; &#125; &#125; &#125; &#125; // 出桶 for(let z = 0 ; z&lt;bucket.length;z++)&#123; if(bucket[z])&#123; newArr.push(...bucket[z]) &#125; &#125; return newArr;&#125;console.log(BucketSort([ 12, 26, 20, 17, 2,0,2, 7], 4)); 参考：常见排序算法 - 桶排序 (Bucket Sort)]]></content>
      <categories>
        <category>基础知识</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法入门（二）堆排序]]></title>
    <url>%2F2018%2F11%2F16%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[原理：将数组表示成完全二叉树，从他的叶子开始最大堆调整，使所有的树苗都是最大堆，只要整个二叉树是一个绝对最大堆，拿到当前堆里面的最大数（顶端head），把这个数放在数组最右边隐藏掉，然后把树最右下方的叶子放在最顶端位置，然后进行调整得到第二个最大堆，拿到最大值放在数组右边隐藏掉，然后把树最右下方的叶子放在最顶端位置，。。。。。直到只剩一个数为止。堆排序可视化：https://www.cs.usfca.edu/~galles/visualization/HeapSort.html：务必打开。array = [804,264,825,175,282,910,914,920,928,179,339,347,161,999,993] ;将数组表示为完全二叉树： 第一轮 ：从二叉树倒数第一层和第二层构成的小堆开始进行最大堆调整，就是图中框里的堆 maxHeapify 最大堆调整函数： 将堆的末端子节点作调整，使得子节点永远小于父节点 array 为 需要排序的原始数组 index ：第一轮里面传入的index ，第一次调整时 最后一个框的 347的索引6就是传入的index， heapsize：当前数组长度，第一轮就是原始数组array的长度，之后依次减一 iMax : 保存当前堆内最大值索引，初始化为 index， 左边节点索引iLeft小于heapsize，意思就是计算出来的索引务必在数组的长度范围内，如果左节点值（993）大于当前节点值（347），说明这不是一个最大堆，将最大值索引重置为index 如果计算出来的右节点索引在长度范围内，且值（999）大于当前堆内最大值（347）就替换，框1不替换 如果计算出来的最大值索引不是index，替换iMax与index的值，重置iMax为index，向下递归 反之，退出循环，如框1中 993与347替换后index重置为13，但是13下面没有节点,iMax == index,退出。 12345678910111213141516171819202122232425262728293031323334353637/ ** * 从 index 开始检查并保持最大堆性质 * * @array * * @index 检查的起始下标 * * @heapSize 堆大小 * **/function maxHeapify(array, index, heapSize) &#123; var iMax, iLeft, iRight; while (true) &#123; iMax = index; //index下 左边节点 iLeft = 2 * index + 1; //index下 右边节点 iRight = 2 * (index + 1); //左节点存在且大于父节点 if (iLeft &lt; heapSize &amp;&amp; array[index] &lt; array[iLeft]) &#123; iMax = iLeft; &#125; //右节点存在且大于当前最大值 if (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123; iMax = iRight; &#125; if (iMax != index) &#123; //如果最大值不是自己，那么将自己与最大值替换 [array[iMax],array[index]] = [array[index],array[iMax]] //重置当前节点为最大值的索引，递归向下调整，使父节点永远大于子节点 index = iMax; &#125; else &#123; //如果最大值是自己，说明已经是最大堆或者该节点下没有子节点 break; &#125; &#125;&#125; 上面仅叙述了堆1的最大堆调整，接着还需要依次向左，再向上，如图 从堆1&gt;2&gt;3&gt;4&gt;5&gt;6&gt;7 一个一个调整 buildMaxHeap函数用来创建整个二叉树的最大堆， iParent就是需要传入maxHeapify的index，用来与两个子节点比较，依次是 6 5 4 3 2 1 0 i 从 6 递减到 0 的过程中，就是堆1 到 堆7的最大堆调整 1234567function buildMaxHeap(array) &#123; var i, iParent = Math.floor(array.length / 2) - 1; for (i = iParent; i &gt;= 0; i--) &#123; maxHeapify(array, i, array.length); &#125; &#125; 注意，堆6，堆5的二级又分别包含三级节点，这里就用到maxHeapify的递归，向下继续调整，直到子节点永远小于父节点，如下，堆6的调整过程，不仅179与347替换，替换后的179影响的堆1原来的秩序，所以还要调整第二轮到最后一轮：第一轮调整到堆7时，二叉树顶端产生最大值，需要将其与最后一个值替换，然后取出， 将剩余的堆继续调整为最大堆， 再次将堆顶的最大数替换取出，这个过程持续到剩余数只有一个时结束 sort函数 ：移除根节点的最大值，并做最大堆调整的递归运算 每次从最后一个堆开始调整，形成最大堆后，移除最大值，循环数组长度减一 12345678function sort(array) &#123; buildMaxHeap(array); for (var i = array.length - 1; i &gt; 0; i--) &#123; swap(array, 0, i); maxHeapify(array, 0, i); &#125; return array; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152完整javascript： function heapSort(array) &#123; function maxHeapify(array, index, heapSize) &#123; var iMax, iLeft, iRight; while (true) &#123; iMax = index; //index下 左边节点, 这规律真是千奇百怪！！！才疏学浅见识少啊。。 iLeft = 2 * index + 1; //index下 右边节点 iRight = 2 * (index + 1); // 左节点存在且大于父节点 if (iLeft &lt; heapSize &amp;&amp; array[index] &lt; array[iLeft]) &#123; iMax = iLeft; &#125; // 右节点存在且大于当前最大值 if (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123; iMax = iRight; &#125; if (iMax != index) &#123; // 如果最大值不是自己，那么将自己与最大值替换 [array[iMax], array[index]] = [array[index], array[iMax]] // 重置当前节点为最大值的索引，递归向下调整，使父节点永远大于子节点 index = iMax; &#125; else &#123; // 如果最大值是自己，说明已经是最大堆或者该节点下没有子节点 break; &#125; &#125; &#125; function buildMaxHeap(array) &#123; var i, iParent = Math.floor(array.length / 2) - 1; for (i = iParent; i &gt;= 0; i--) &#123; maxHeapify(array, i, array.length); &#125; &#125; function sort(array) &#123; buildMaxHeap(array); //第一轮 for (var i = array.length - 1; i &gt; 0; i--) &#123; [array[0], array[i]] = [array[i], array[0]] maxHeapify(array, 0, i); &#125; return array; &#125; return sort(array); &#125; console.log(heapSort([804,264,825,175,282,910,914,920,928,179,339,347,161,999,993] )); 难点： 查找左右节点的索引规律 函数递归思想保证每次子节点小于父节点 创建最大堆函数 buildMaxHeap函数的设计，for循环里iParent的循环递减 sort函数取出最大值，重置heapSize的思路 全是难点！。。。。。。 参考：http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort]]></content>
      <categories>
        <category>基础知识</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法入门（一） 冒泡排序，选择排序，插入排序]]></title>
    <url>%2F2018%2F11%2F15%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%8C%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[本文简要记录常用排序算法的原理及如何用javascript实现排序功能，具体排序动画效果查看Sorting (Bubble, Selection, Insertion, Merge, Quick, Counting, Radix)，看完后思路会非常清晰（请问还有什么比算法动态演变更让人理解？？）。计算机计算是非常机械的，不同于人脑快速找出最值快速排序，必须放慢思路，理清逻辑，关于实现算法的代码，建议反复分析，不同的for循环有不同的结果，每位程序员都有不同的思路，但基本原理都是一致的 冒泡排序 选择排序 插入排序 冒泡排序（Bubble sort） 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 冒泡排序流程图 伪代码12345678910111213141516171819202122232425a &lt;- &#123;&apos;0&apos;:4,&apos;1&apos;:6,&apos;2&apos;:3,&apos;3&apos;:2,&apos;4&apos;:1,&apos;length&apos;: 5&#125;轮数 = 1左手指向的下标 while(轮数 &lt; a[&apos;length&apos;]) 左标 = 0 while(左标 &lt;= a[&apos;length&apos;] - 1 - 轮数) if a[左下标] &lt; a[左下标+1] else t &lt;- a[左标] a[左标] &lt;- a[左标+1] a[左标+1] &lt;- t end 左标 &lt;- 左标+1 end 轮数 &lt;- 轮数 + 1endprint a javascript实现 1234567891011function BubbleSort(arr)&#123; for(let i = 0 ;i&lt; arr.length;i++)&#123; //轮数 for(let j = 0 ;j &lt; arr.length - i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; [arr[j],arr[j+1]] = [arr[j+1],arr[j]] //es6语法交换元素 &#125; &#125; &#125; return arr;&#125;console.log(BubbleSort([21,5,10])) 选择排序（Selection sort）工作原理: 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 选择排序流程图 伪代码1234567891011121314151617181920212223242526 a&lt;-&#123; &apos;0&apos;=4, &apos;1&apos;=6, &apos;2&apos;=3, &apos;3&apos;=2, &apos;4&apos;=1, &apos;length&apos;=5&#125;轮数=1 while(轮数&lt;a[&apos;length&apos;]) min左标&lt;-轮数-1;左标&lt;-min左标+1 while(左标&lt;a[&apos;length&apos;]) if a[左标]&lt;a[min左标] a[min左标]&lt;-a[左标] else 什么也不做 end 左标&lt;-左标+1 end t&lt;-a[轮数-1] a[轮数-1]&lt;-a[min左标] a[min左标]&lt;-t 轮数&lt;-轮数+1 end print a javascript实现12345678910111213function SelectionSort(arr) &#123; let minIndex; for (let i = 0; i &lt; arr.length; i++) &#123; //轮数 minIndex = i; for (let j = i+1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]]; &#125; return arr;&#125; 插入排序（Insection Sort）原理：将第一个元素标记为已排序，遍历每个没有排序过的元素，提出当前第一个位置的元素X，将X与排序过的元素从length-1 到 0 进行遍历，如果某个元素大于X，将排序过的元素向右移一格，否则插入这个元素后面。 选择排序流程图 javascript实现123456789101112function InsectionSort(arr) &#123; for (let i = 1; i &lt; arr.length; i++) &#123; //轮数 let num = arr[i] for (let j = i - 1; j &gt;= 0; j--) &#123; if(num &lt; arr[j])&#123; arr.splice(j,0,num); arr.splice(j+2,1) &#125; &#125; &#125; return arr;&#125;]]></content>
      <categories>
        <category>基础知识</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（九）：伪类和伪元素]]></title>
    <url>%2F2018%2F11%2F14%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[文档阅读：总结伪类与伪元素 | AlloyTeamwww.alloyteam.com! 前文回顾： 一、伪类：1、定义伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化 2、类型 3、应用场景用伪类元素进行效果展示（1）link visited hover active 顺序 123456789/* 未访问的链接 */ a:link&#123; color: blue; &#125; a:visited&#123; color: green; &#125; /* 点击后鼠标脱离，获得焦点的链接 */ a:focus&#123; color: grey; &#125; /*鼠标悬停时，内容颜色获得红色 */ a:hover&#123; color: red; &#125; /*选择活动链接*/ a:active&#123; color: pink; &#125; （2）first-child VS first-of-type h1:first-child :选择是h1并且它是长子的元素 h1:first-of-type:选择是h1并且它是它父亲里h1类型中的长子的元素 关于first-childVSfirst-of-type的使用在之前的css系列博客文章中有详细解释：#00你认真学了css？ 二、伪元素1、定义伪元素用于创建一些不在文档树中的元素，并为其添加样式 2、类型如： 3、:before 和 :after（也可以写::before和 ::after）1234567891011&lt;div class=&quot;box&quot;&gt; &lt;p&gt;这是第一段&lt;/p&gt; &lt;/div&gt; &lt;style&gt; .box:before&#123; content: &apos;start&apos; &#125; .box:after&#123; content: &apos;end&apos; &#125; &lt;/style&gt; 使用伪元素before和after的好处： 可以在后台发现，p的前后分别出现::before和::after。html的dom树中原本没有::before和::after，现通过css样式添加，使其在dom树中添加这两个元素。 用添加::before和::after的目的是为了省标签。::before生成的效果，所在的位置位于父元素（如box）的第一个子元素，::after则位于父元素（如box）的最后一个子元素，即在html的dom树上多了两个子元素，这两个子元素无需在html中体现，只需在css中表示即可。 ::before和::after所展示的效果相当于一个行内元素（注意行内元素的一些特性） 其中content是必不可少 4、伪类选择器的应用场景（1）伪类选择器应用于清除浮动 12345.clearfix:after &#123; content:&apos;&apos;; display:block; clear:both;&#125; 详细解释请回看之前我写得关于浮动的副作用和解决办法：#03你认真学了css？（基本样式3：浮动+定位） （2）伪类选择器可作为替代标签用代码替代图片，如使用css3实现一个带边框的三角符。思路：边框+三角符号的组合，先确认边框样式： 12345678910111213.bubble&#123; position: relative; padding: 10px; border-radius: 3px; /*可填可不填*/ background: #fff; border: 1px solid #000; display: inline-block; &#125;&lt;body&gt; &lt;div class=&quot;bubble&quot;&gt; hello world &lt;/div&gt;&lt;/body&gt; 再确认三角样式： 1234567891011121314151617.bubble:before&#123; content:&apos;&apos;; width: 10px; height: 10px; border-left: 1px solid #000; border-top: 1px solid #000; background: #fff; display: inline-block; position: absolute; transform: rotateZ(45deg); top: -6px; &#125;&lt;body&gt; &lt;div class=&quot;bubble&quot;&gt; hello world &lt;/div&gt;&lt;/body&gt; 这里基础的三角样式我们在之前已经有涉及过怎么使用：请戳🔽#01你认真学了css？（基本样式1） 使用伪元素怎么实现三角符号(css3)：基础代码：（关于三角形的位置参数可以使用页面后台进行调试） 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .bubble&#123; position: relative; padding: 10px; border-radius: 3px; /*可填可不填*/ background: #fff; border: 1px solid #000; display: inline-block; &#125; .bubble:before&#123; content:&apos;&apos;; width: 10px; height: 10px; border-left: 1px solid #000; border-top: 1px solid #000; background: #fff; display: inline-block; transform: rotateZ(45deg); position: absolute; top: -6px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;bubble&quot;&gt; hello world &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 结果：运用以上知识举一反三，实现以下效果： 代码请戳：我的代码 （3）伪类选择器应用于element：checked;（勾选住的一个状态）即input元素的自定义重要属性checkbox或者radio，实现一个自定义的样式。如：笑脸切换 12345678910111213141516171819202122/*今天的心情:*/ &lt;input type=&quot;checkbox&quot;&gt;&lt;style&gt;input[type=checkbox]&#123; -webkit-appearance: none; /*去掉未勾选的方框默认样式*/ appearance: none; background: url(http://7xpvnv.com2.z0.glb.qiniucdn.com/b6dcd011-23cc-4d95-9e51-9f10100103bd.png) 0 0 no-repeat; display: inline-block; width: 20px; height: 20px; background-size: contain; /*背景图片的大小*/ vertical-align: middle; outline: none; &#125; /*勾选之后的状态*/ input[type=checkbox]:checked&#123; -webkit-appearance: none; appearance: none; background: url(http://7xpvnv.com2.z0.glb.qiniucdn.com/538f26f0-6f3e-48d5-91e6-5b5bb730dd19.png) 0 0 no-repeat; display: inline-block; width: 20px; height: 20px; background-size: contain; vertical-align: middle; &#125; &lt;/style&gt; 好处： 没有加js 使用该属性样式，对于input来说已经实现勾选状态，自定义加一些自己的图片，自动加载信息 （4）伪类选择器应用于字体图标A、为什么针对字体库而来的字体，我们可以调整它的字体大小和颜色？B、完整代码如下： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//at.alicdn.com/t/font_nyta5x5h650cnmi.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;span class=&quot;iconfont icon-jirengulogojichu2&quot;&gt;&lt;/span&gt; &lt;style&gt; .iconfont&#123; font-size: 100px; color: red; &#125; &lt;/style&gt;&lt;/body&gt;&lt;/html&gt; 在css中添加这个: 12/* \e605为字体库中的特有的一种编码形式：unicode码 */.icon-jirengulogojichu2：before&#123;content:&apos;\e605&apos;;&#125; 即：]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（八）：布局套路]]></title>
    <url>%2F2018%2F11%2F13%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%B8%83%E5%B1%80%E5%A5%97%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[一、两种布局使用分析 float布局（定宽布局） flex布局（弹性布局） 二、原则 不到万不得已，不要写死width 和 height 尽量用高级语法，如 calc、flex 如果是 IE，就全部写死 三、布局套路口诀（上） 👉PC端布局1、导航条布局——float布局（适用于ie5） a.儿子全加 float: left （right）;b.老子加 .clearfix 代码如下：Float布局 12345678910111213141516171819202122232425262728293031&lt;style&gt; .parent&#123; border:1px solid green;&#125; .child&#123; /* border:1px solid red; */&#125;.child:nth-child(1)&#123; width:30%; background-color:red;&#125;.child:nth-child(2)&#123; width:69%; background-color:yellow;&#125;.clearfix::after&#123; content:&apos;&apos;; display:block; clear:both; &#125;.content&#123; border:1px solid black; margin-right:10px;&#125;&lt;/style&gt;&lt;div class=&quot;parent clearfix&quot; &gt; &lt;div class=&quot;child&quot; style=&quot;float:left;&quot;&gt;儿子1&lt;/div&gt; &lt;div class=&quot;child&quot; style=&quot;float:left;&quot;&gt;儿子2&lt;/div&gt; &lt;/div&gt; 如图：该页面展示上其实是弹性布局定死宽度，水平居中则在老子这边动手，添加以下代码： 123456789101112131415 .parent&#123; border:1px solid green; width:1000px margin-left:auto margin-right:auto&#125;.child:nth-child(1)&#123; width:30%; background-color:red;&#125;.child:nth-child(2)&#123; width:69%; background-color:yellow;&#125; 如图：定宽之后，页面宽度仍有剩余优化之后的导航条，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;style&gt; .parent&#123; margin-left:auto; margin-right:auto; background: #ddd; /*定死宽度则不会影响页面 */ min-width:600px; &#125; .child&#123; &#125; .child:nth-child(1)&#123; width:100px; background-color:#333; color: white; text-align:center; line-height:36px; height:36px; &#125; .child:nth-child(2)&#123; &#125; /* 清除浮动 */ .clearfix::after&#123; content:&apos;&apos;; display:block; clear:both; &#125; .clearfix&#123; zoom: 1; &#125;/*IE6*/ .content&#123; border:1px solid black; margin-right:10px; &#125; .nav&#123; line-height:24px; padding:6px 0; &#125; .navItem&#123; margin-left:20px; &#125; &lt;/style&gt; &lt;div class=&quot;parent clearfix&quot; &gt; &lt;div class=&quot;child&quot; style=&quot;float:left;&quot;&gt;logo&lt;/div&gt; &lt;div class=&quot;child&quot; style=&quot;float:right;&quot;&gt; &lt;div class=&quot;nav clearfix&quot;&gt; &lt;div style=&quot;float:left&quot; class=&quot;navItem&quot;&gt;导航1&lt;/div&gt; &lt;div style=&quot;float:left&quot; class=&quot;navItem&quot;&gt;导航2&lt;/div&gt; &lt;div style=&quot;float:left&quot; class=&quot;navItem&quot;&gt;导航3&lt;/div&gt; &lt;div style=&quot;float:left&quot; class=&quot;navItem&quot;&gt;导航4&lt;/div&gt; &lt;div style=&quot;float:left&quot; class=&quot;navItem&quot;&gt;导航5&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 2、图片位布局——flex布局 a.给老子加 display: flexb.给老子加justify-content: space-between; 先看看第1种场景：实现方式：先不用flex布局，用浮动元素+margin+clearfix清除浮动 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;style&gt;/* 图片主要部分 */.banner&#123; width:800px; height:300px; background:#888; margin-left:auto; margin-right:auto; margin-top:10px; &#125;.pictures&#123; width:800px; margin:0 auto;/*不能删1：居中*//* background: black;最底层的颜色 */&#125;.picture&#123; width:194px; height:194px; background:#ddd; margin:4px; float:left;&#125;.pictures &gt;.xxx&#123; /*为什么不能只用两层div*//* background: rgba(255,0,0,0.8);倒数第二层颜色 */ margin-left:-4px; margin-right:-4px;/*不能删2：扩大范围*/&#125;/* .picture:nth-child(1)&#123; margin-left: 0;&#125;.picture:nth-child(4)&#123; margin-right: 0;&#125; */&lt;style&gt; &lt;div class=&quot;banner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pictures&quot;&gt; &lt;div class=&quot;xxx clearfix&quot;&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 如图：这种方式可以兼容IE6，且即使减少一个板块也不会影响其它板块，如图： 再看第2种场景：实现方式：flex布局 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt;.banner&#123; width:800px; height:300px; background:#888; margin-left:auto; margin-right:auto; margin-top:10px;&#125;.pictures&#123; width: 800px; /* 定宽不够弹性 */ margin: 0 auto; display: flex; /* 弹性布局 */ flex-wrap: wrap; /* 换行*/ justify-content: space-between;/* 多余空间放在空间或水平居中 */ /* align-items: center; 垂直居中 */&#125;.picture&#123; width: 194px; height: 194px; background: #ddd; margin-top: 4px; margin-bottom: 4px;&#125;&lt;/style&gt; &lt;div class=&quot;banner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pictures&quot;&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;/div&gt; 不过如果不是等份的图片板块，就会出现下方bug： 如何解决?代码如下：flex布局至bug修复 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style&gt;*&#123;box-sizing: border-box;&#125;.banner&#123; width:800px; height:300px; background:#888; margin-left:auto; margin-right:auto; margin-top:10px;&#125;.pictures&#123; width: 800px; /* 定宽不够弹性 */ margin: 0 auto; &#125;.pictures &gt; .xxx&#123; display: flex; /* 弹性布局 */ flex-wrap: wrap; /* 换行 */ margin: 0 -4px;&#125;.picture&#123; width: 194px; height: 194px;/* 或者 width: calc(25% - 8px); height: 194px; */ background: #ddd; /* 边框可去掉border: 1px solid red; */ margin: 4px;&#125;&lt;/style&gt; &lt;div class=&quot;banner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pictures&quot;&gt; &lt;div class=&quot;xxx&quot;&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;div class=&quot;picture&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 如图： 3、广告位布局——浮动+margin+clearfix清除浮动代码如下： 1234567891011121314151617181920212223242526272829&lt;style&gt;.art&#123; background: #ddd; width:800px; margin:0 auto;&#125;.art &gt; .sider&#123; float:left; border: 1px solid black; width:33.333333%; height:300px&#125;.art &gt; .main&#123; float:left; border: 1px solid black; width:66.333333%; height:300px&#125;&lt;/style&gt; &lt;div class=&quot;art clearfix&quot;&gt; &lt;div class=&quot;sider&quot;&gt; &lt;div&gt;广告1&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;div&gt;广告2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 如图： 广告位之间的间距如何处理：方法1： 采用内嵌一个div，定宽，float+margin-right进行间隙（这种方法似乎要兼容啊，做了很久弄不出，不弄了）方法2： calc计算法+margin 1234567891011121314151617181920212223242526272829&lt;style&gt;.art&#123; background: #ddd; width:800px; margin:0 auto;&#125;.art &gt; .sider&#123; float:left; width:calc( 33.333333% - 20px);/* calc计算法，此时右侧多出20px */ border: 1px solid black; height: 300px; margin-right: 20px; /* 用多出的20px，弥补上那块间隙 */&#125;.art &gt; .main&#123; float:left; border: 1px solid black; width:66.666666%; height:300px&#125;&lt;/style&gt; &lt;div class=&quot;art clearfix&quot;&gt; &lt;div class=&quot;sider&quot;&gt; &lt;div&gt;广告1&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;div&gt;广告2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 如图： 方法3： flex布局（IE不支持） a.父元素：display:flex+justify-content:space-betweenb.父元素+子元素：display:flex+margin-right:auto 123456789101112131415161718192021&lt;style&gt;.art&#123; background: #ddd; width:800px; margin:0 auto; display: flex; /* flex直接左右布局 */ justify-content: space-between;/* 第2种方法：将空隙放中间 */&#125;.art &gt; .sider&#123; width:calc( 33.333333% - 20px); /* calc计算法，此时右侧多出20px */ border: 1px solid black; height: 300px; /* margin-right:auto; 第1种方法 */&#125;.art &gt; .main&#123; border: 1px solid black; width:66.666666%; height:300px&#125;&lt;/style&gt; 如图也是： 三、布局套路口诀（下） 👉移动端布局 添加：meta:vp (tab键): 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; 收起pc端导航：删除定宽+{margin:0; padding:0;} 导航 PC和手机适配的问题 123456789101112/* 导航PC和手机适配的问题 */.parent .nav2&#123; display:none;&#125;@media (max-width:420px)&#123; .parent .nav2&#123; display:block; &#125; .parent .nav&#123; display:none; &#125;&#125; banner适配移动端 123456789101112/*banner适配移动端*/.banner&#123; width:800px; /*万恶的定宽 PC端必备*/ height:300px; background: #888; margin-left: auto; margin-right: auto; margin-top: 10px; &#125;@media (max-width:420px)&#123; .banner&#123;width:auto;&#125;&#125; 图片板块适配移动端 12345678910111213141516171819202122232425262728/*图片板块适配移动端*/.pictures&#123; width: 800px; /* 万恶的定宽PC端必备;定宽布局不够弹性 */ margin: 0 auto; /*不能删1：居中*/ overflow:hidden; /* 避免溢出 */ &#125;@media (max-width:420px)&#123; .pictures&#123;width:auto;&#125; &#125;.pictures &gt; .xxx&#123; display: flex; /* 弹性布局 */ flex-wrap: wrap; /* 换行*/ margin: 0 -4px;&#125;/*图片板块适配移动端2*/.picture&#123; width: calc(25% - 8px); height: 194px; background: #ddd; margin: 4px;&#125;@media (max-width:420px)&#123; .picture&#123; width: calc(50% - 8px); &#125;&#125; 广告位适配移动端 123456789101112131415161718192021222324252627282930313233343536373839/*广告位适配移动端*/.art&#123; background: #ddd; width:800px; /*万恶的定宽 PC端必备*/ margin:0 auto; display: flex; /* flex直接左右布局 */ justify-content: space-between;/* 第2种方法：将空隙放中间 */&#125;@media (max-width:420px)&#123; .art&#123; width: auto; flex-direction:column; &#125;&#125;.art &gt; .sider&#123; width:calc( 33.333333% - 20px); /* calc计算法，此时右侧多出20px */ border: 1px solid black; height: 300px; /* margin-right:auto; 第1种方法 */&#125;@media (max-width:420px)&#123; .art &gt; .sider&#123; width: auto; height: auto; &#125;&#125;.art &gt; .main&#123; border: 1px solid black; width:66.666666%; height:300px&#125;@media (max-width:420px)&#123; .art &gt; .main&#123; width: auto; height: auto; &#125;&#125; 关于图片添加：（注：变形问题减少使用img） 12background:transparent url(https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=292576901,2272109431&amp;fm=27&amp;gp=0.jpg) no-repeat center; background-size: cover; /*尽量全地显示图片*/ 注： 代码总链接：布局套路固定比例div：图片1：1显示或者2：1显示CSS渐变方法：解决背景样式渐变问题]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（七）：布局基础]]></title>
    <url>%2F2018%2F11%2F12%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、什么是布局1、现有的布局满足不了人们的需求文档流、浮动、定位 2、用户中所需要的： 导航栏+内容 导航栏+内容+广告栏 从上到下、从左到右、定宽、自适应… 二、几种布局介绍1、单列布局 一栏布局 一栏布局（通栏） 实现方式： 定宽 + 水平居中 123width: 1000px; /*或 max-width: 1000px;*/margin-left: auto;margin-right: auto; 范例：单列布局——一栏布局关键代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style&gt; .layout&#123; /* width: 960px; */ max-width: 960px; margin: 0 auto; &#125; //给 body 设置min-width 去掉滚动背景色 bug body&#123; min-width: 960px; &#125; #header&#123; height: 60px; background: red; &#125; #content&#123; height: 400px; background: blue; &#125; #footer&#123; height: 50px; background: yellow; &#125;&lt;/style&gt;/* 如图1：此时的定宽是width:560px */&lt;div class=&quot;layout&quot;&gt; &lt;div id=&quot;header&quot;&gt;头部&lt;/div&gt; &lt;div id=&quot;content&quot;&gt;内容&lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;尾部&lt;/div&gt;&lt;/div&gt;/* 或通栏的单列布局,此时```.layout&#123;border:1px solid&#125;``` */ &lt;div id=&quot;header&quot;&gt; &lt;div class=&quot;layout&quot;&gt;头部&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;context&quot; class=&quot;layout&quot;&gt;内容&lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; &lt;div class=&quot;layout&quot;&gt;尾部&lt;/div&gt; &lt;/div&gt;//或省标签，便于控制局部 如图2：&lt;div id=&quot;header&quot; class=&quot;layout&quot;&gt;头部&lt;/div&gt;&lt;div id=&quot;content&quot; class=&quot;layout&quot;&gt;内容&lt;/div&gt;&lt;div id=&quot;footer&quot; class=&quot;layout&quot;&gt;尾部&lt;/div&gt; 如图： 2、双列布局一列固定宽度，另一列自适应宽度实现方式：浮动元素 + 普通元素margin+老子清除浮动注： 布局时，考虑到渲染顺序，浮动元素代码优先写在其他元素前面，优先渲染第1种场景：两列布局范例：双列布局 12345678910111213141516171819202122232425262728&lt;style&gt; #content:after&#123; //第3步：添加一个伪元素清除浮动 content: &apos;&apos;; display: block; clear: both; &#125; .aside&#123; width: 200px; height: 500px; background: yellow; float: left; //第1步：浮动元素 &#125; .main&#123; margin-left: 210px; //第2步：margin-left（right） height: 400px; background: red; &#125; #footer&#123; background: #ccc; &#125; &lt;/style&gt; &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;aside&quot;&gt;aside&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt; 如图： 第2种场景：两列布局侧边栏aside在右侧：范例：双栏布局——侧边栏（aside）在右侧 1234567891011121314151617181920212223242526272829&lt;style&gt; #content:after&#123; //第3步：清除浮动 content: &apos;&apos;; display: block; clear: both; &#125; .aside&#123; width: 200px; height: 500px; background: yellow; float: right; //第1步：浮动 &#125; .main&#123; margin-right: 210px; //第2步：margin height: 400px; background: red; &#125; #footer&#123; background: #ccc; &#125; &lt;/style&gt; &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;aside&quot;&gt;aside&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;content&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt; 如图： 3、三列布局两侧两列固定宽度，中间列自适应宽度实现方式：浮动元素+margin+伪类元素清除浮动 1234567891011121314151617181920212223242526272829303132333435#content:after&#123; ////第3步：伪类元素 content: &apos;&apos;; display: block; clear: both; &#125; .menu&#123; width: 100px; height: 500px; background: pink; float: left; //第1步：浮动 &#125; .aside&#123; width: 200px; height: 500px; background: yellow; float: right; //第1步：浮动 &#125; .main&#123; margin-left: 110px; /*为什么要加margin-left*/ //第2步：margin margin-right: 210px; //第2步：margin height: 400px; background: red; &#125; #footer&#123; background: #ccc; &#125; &lt;div id=&quot;content&quot;&gt; &lt;!-- 为什么不是main在前面： 渲染顺序--&gt; &lt;div class=&quot;menu&quot;&gt;menu左&lt;/div&gt; &lt;div class=&quot;aside&quot;&gt;aside右&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;content中&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt; 如图： 4、水平等距布局实现方式：处理老子（居中、防溢出）+浮动+ margin 1234567891011121314151617181920212223242526272829303132333435363738&lt;style&gt;ul,li&#123; margin: 0; padding: 0; list-style: none; //取消列表的实心小黑点&#125;.ct&#123; overflow:hidden; //溢出隐藏 width: 640px; border:dashed 1px orange; margin: 0 auto; //相对于页面的居中&#125;.ct .item&#123; float:left; //第1步：浮动 margin-left: 20px; //第0步：提前设置 margin-top: 20px; //第0步：提前设置 width:200px; height:200px; background: red;&#125;.ct&gt;ul&#123; margin-left: -20px; //第2步：补充不够的20px&#125;&lt;/style&gt;&lt;div class=&quot;ct&quot;&gt; &lt;ul&gt; &lt;li class=&quot;item&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;3&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;4&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;5&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;6&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;7&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;8&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 如图： 三、其他布局 圣杯布局 双飞翼布局 流式布局 Grid布局 Flex布局 移动端布局（meta、媒体查询、动态rem）]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（六）：元素居中]]></title>
    <url>%2F2018%2F11%2F11%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[一、元素水平居中1、text-align实现水平居中text-align:center; 行内元素（图片或文字）居中在父元素上设置text-align: center 使文字/图片在整个页面上水平居中 123 .container&#123; text-align:center;&#125; 如一小选项按钮居中，可以使用： 1234 .container&#123; display:inline-block; text-align:center;&#125; 2、margin实现水平居中margin: 0 auto; 用于块级元素的居中 123456.container &#123; width: 80%; /*块级元素充满页面 定宽必备 */ margin-left: auto; margin-right: auto; /*或者 margin：0 auto;*/&#125; 如：块级元素居中代码如下： 1234567891011121314 &lt;style&gt; .wrap&#123; max-width:600px; background: #ccc; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;p&gt;world&lt;/p&gt; &lt;/div&gt; 二、元素垂直居中1、居中 VS 不居中注： 高度由里面的内容撑开，一般不设置高度代码如下： 123456789101112 &lt;style&gt;.ct&#123; padding: 40px 0; text-align: center; background: #eee;&#125; &lt;/style&gt;&lt;div class=&quot;ct&quot;&gt; &lt;p&gt;你好世界&lt;/p&gt; &lt;p&gt;helloworld&lt;/p&gt; &lt;/div&gt; 2、vertical-align实现垂直居中vertical-align: middle; 让行内元素或表格元素相对于基线对齐并居中案例：如图片进行水平、垂直居中代码如下：图片在容器内水平、垂直居中 12345678910111213141516171819202122232425&lt;style&gt;.box&#123; width: 300px; height: 200px; border: 1px solid ; text-align: center;&#125;/*注：子元素和父元素分别设置 vertical-align:middle; ，均无法实现垂直居中*//*使用一个伪元素，设置一个虚拟的基准线*/.box:before&#123; content: &apos;&apos;; display: inline-block; height: 100%; vertical-align: middle; ✔️&#125;.box img&#123; vertical-align: middle; ✔️ background: blue;&#125;&lt;/style&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;http://cdn.jirengu.com/public/logo-tiny.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; 如图： 3、table-cell 实现垂直居中display: table-cell;水平垂直居中代码如下： 1234567891011121314&lt;style&gt;.box&#123; width: 300px; /*由于是行内元素，宽度必备*/ height: 200px; border: 1px solid ; display: table-cell; ✔️ vertical-align: middle; ✔️ text-align: center;&#125;&lt;/style&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;http://cdn.jirengu.com/public/logo-tiny.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; 4、绝对定位实现居中案例：如弹出框 弹出框水平垂直居中情况1： 固定宽高块在浏览器窗口水平垂直居中，代码如下： 123456789101112131415161718192021222324252627282930&lt;style&gt;html,body &#123; height: 100%;&#125;.dialog &#123; position: absolute; /*绝对定位*/ left: 50%; top: 50%; margin-left: -200px; margin-top: -150px; width: 400px; height: 300px; box-shadow: 0px 0px 3px #000;&#125;.dialog .header&#123; padding: 10px; background: #000; color: #fff;&#125;.dialog .content&#123; padding: 10px;&#125;&lt;/style&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;div class=&quot;header&quot;&gt;我是标题&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;我是内容&lt;/div&gt; &lt;/div&gt; 情况2： 去掉宽高的块在浏览器窗口水平垂直居中，代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;style&gt;html,body &#123; height: 100%;&#125;.dialog &#123; position: absolute; left: 50%; top: 50%; /* margin-left: -200px; margin-top: -150px; */ /*CSS3属性 相对于自己的偏移*/ transform:translate(-50%,-50%); box-shadow: 0px 0px 3px #000;&#125;.dialog .header&#123; padding: 10px; background: #000; color: #fff;&#125;.dialog .content&#123; padding: 10px;&#125;&lt;/style&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;div class=&quot;header&quot;&gt;我是标题&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;我是内容&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;我是内容&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;我是内容&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;我是内容&lt;/div&gt; &lt;/div&gt; 5、table自带功能实现垂直居中参考demo：table自带功能实现垂直居中 6、100% 高度的 afrer before 加上 inline block实现垂直居中参考demo：100% 高度的 afrer before 加上 inline block实现垂直居中 7、margin-top: -50%实现垂直居中参考demo：margin-top: -50%实现垂直居中 8、flex布局实现垂直居中参考demo：flex布局实现垂直居中]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（五）：BFC和边距合并]]></title>
    <url>%2F2018%2F11%2F10%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9ABFC%E5%92%8C%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[一、BFC1、定义：先给一个官方的定义：（说的什么东西反正我没看懂） Formatting context(格式化上下文)是W3CCSS2.1规范中的一个概念。每个渲染区域用formattingContext表示，它是页面中的一块渲染区域，并且有一套渲染规则。它决定了其子元素将如何定位，以及和其他元素的关系和相互作用 再看下面这个定义：（有一点点懂） BFC（Block FormattingContext），块级格式化上下文。相当于制定一种如BFC这样的规则，在普通流中按照该规则进行布局。 在正常流中的盒子要么属于块级格式化上下文（BFC），要么属于内联格式化上下文，即块级元素在页面渲染的时候遵循怎么样的规则，它们之间有怎么样的作用。 再看这个：（还是一点点懂） 具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性。通俗一点来讲，可以把 BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 总结：BFC没有定义，只有功能或特性 2、BFC会在哪里产生（官方的）只要元素满足下面任一条件即可触发 BFC 特性（1）body根元素html里的根元素产生相应的“块级格式化上下文”这类的规则，如某些规则：块级容器可以充满父容器，父容器可以被子元素撑开，外边距产生合并，渲染顺序是从上到下（同一个块级格式化上下文中相邻块级盒之间的竖直margin会合并）（2）浮动元素：float除了none以外的值；如float:left;该元素属性本身也产生了相应的块级格式化上下文。该元素产生的BFC与所在的根元素的BFC互不影响，此元素的作用域，则为该元素服务，与根元素产生一个隐形的边界（3）绝对定位元素：position为absolute或fixed；（4）display为inline-block（非块盒的块容器）, flex, 或inline-flex；（5）overflow除了visible以外的值（hidden、auto、scroll） 3、应用这里的例子截取自该文章：10 分钟理解 BFC 原理（1）功能1让两个相邻的元素界限分明（同一个 BFC 下外边距会发生重叠或合并）代码如下： 1234567891011&lt;head&gt;div&#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125;&lt;/head&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; 从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div的下边距和第二个div的上边距发生了重叠，所以两个盒子之间距离只有100px，而不是 200px。如图：首先这不是 CSS 的bug，我们可以理解为一种规范。如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 123456789101112131415161718 &lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;style&gt;.container &#123; overflow: hidden; ✔️&#125;p &#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125;&lt;/style&gt; 这时候，两个盒子边距就变成了 200px ，如图： （2）功能2子元素被父元素包裹起来（BFC可以包含浮动的元素）（可代替clearfix来清除浮动） display:flow-root; 让当前元素触发BFC（正交，考虑浏览器兼容） 1overflow:hidden; 将溢出隐藏浮动的元素会脱离普通文档流， 来看下下面一个例子，代码如下： 123456789101112131415&lt;style&gt; .father&#123; border: 1px solid #000; &#125; .son&#123; width: 100px; height: 100px; background: #eee; float: left; &#125;&lt;/style&gt; &lt;div class=father&gt; &lt;div class=son&gt;&lt;/div&gt; &lt;/div&gt; 由于父元素（father）内子元素（son）进行浮动，脱离了“父亲”的文档流，所以容器只剩下 2px 的边距高度。此时可以触发容器的 BFC，那么“father”就可以包裹住“son”出去的浮动元素。 12345678910111213141516&lt;style&gt; .father&#123; border: 1px solid #000; overflow:hidden; ✔️ &#125; .son&#123; width: 100px; height: 100px; background: #eee; float: left; ✔️ &#125;&lt;/style&gt; &lt;div class=father&gt; &lt;div class=son&gt;&lt;/div&gt; &lt;/div&gt; （3）功能3BFC 可以阻止元素被浮动元素覆盖。先来看一个文字环绕效果，代码如下： 12345678910111213141516&lt;style&gt;.box1&#123; height: 100px; width: 100px; float: left; background: lightblue;&#125;.box2&#123; width: 200px; height: 200px; background: #eee;&#125;&lt;/style&gt;&lt;div class=box1&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div class=box2&gt;我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt; 此时，浮动元素浮在第二个元素上，第二个元素有部分区域被浮动元素所覆盖(但文本信息不会被浮动元素所覆盖) 。如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入overflow:hidden；或者display:flow-root; 1234567891011121314151617181920212223&lt;style&gt;.box1&#123; height: 100px; width: 100px; float: left; ✔️ background: lightblue;&#125;.box2&#123; width: 200px; height: 200px; background: #eee; overflow:hidden; ✔️ /*或 display: flow-root; */ ✔️&#125;&lt;/style&gt;&lt;div class=box1&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div class=box2&gt;我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt; 就会变成：BFC 浮动处理用来实现两列自适应布局：即左边宽度固定，如果想右边的内容自适应宽度，可以去掉上面右边内容的宽度（如果右边定宽，窄页面时，则会自动换到下一行排列） 二、边距合并1、讲例子案例1：当实际中希望#header和h1之间产生一点缝隙（或间距），即使将h1设置 margin:50px;，作为块级元素的h1，margin左右生效，而上下则是#header+h1整体向下移动50px这便是，外边距合并 案例2：看案例似乎是&lt;h1&gt;和&lt;p&gt;标签所设置的外边距各30px，两者之间的间距理论来讲应该是60px，但事实上这是两个相邻元素的外边距产生合并，下边距&lt;margiin-bottom&gt;和上边距&lt;margin-top&gt;合并之后取较大值，这里为30px这也是，外边距合并 2、合并场景（1）相邻元素合并同案例2（2）父子合并h1和header，或者再嵌套元素或者与其的祖先元素嵌套，均能产生外边距合并，这些都能称之为“父子合并” ,如图：（3）自己合并如图，块级元素合并，无默认样式即靠在一起；含有p标签（含内容）的块级元素，则有默认上下margin，所以detail和footer则会产生缝隙（或间距） .footer元素为空内容，设置 margin:30px; ，即说明上边距和下边距合并后的外边距总值是60px，不过.footer元素为空内容，所以页面效果仍然呈现30px，说明css元素中外边距合并的另一种情况： 自己和自己合并： 如图： 三、取消合并（如何去解决外边距合并？）1、边框、padding 存在于父子合并 为何#header和h1能够产生合并？即#header没有border和padding（即一个可与外界隔离的边界线），导致h1自带的一个margin，冲出该边界，与#header合并 尝试在#header里添加边框（图1）或者加padding（内边距）（图2），让#header和h1的margin-top，内外分开，即能做到不让外边距合并，如图： 2、BFC如何让一个元素生成bfc？bfc可认为是拥有一片独立的空间，和其他的空间（或其他的文档流）区别开。注：添加bfc元素属性，可以取消合并有可能产生副作用（1）父子元素不产生合并A、添加：overflow:hidden；B、添加 ：float:left;C、添加： display:inline-block;D、添加： position:absolute; （2）相邻元素不产生合并A、添加：浮动元素B、添加：overflow:hidden；生成BFC，相当于生成了一个边界，即边框作为一个边界，有了边界之后，#header+h1父子元素便不能冲破该边界，自然与#detail元素的不产生合并. 【重点】： 而相邻元素之间的margin，可以认为不是该父子元素边界内，同样会产生合并。通常处理相邻元素之间的间距合并问题（除浮动外，浮动时不会被合并），即不考虑合并问题，直接设置为：margin-top:___px;]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（四）：浮动和定位]]></title>
    <url>%2F2018%2F11%2F09%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%B5%AE%E5%8A%A8%E5%92%8C%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[自我总结： 浮动是实现布局的一种常见方式 浮动脱离普通文档流，即页面渲染时，盒模型按标准会将父元素所设置的属性将页面撑开；加入浮动后，父元素不会发现浮动元素，父元素则不会被浮动元素撑开页面）。 块级元素默认样式可以撑满父容器，加入浮动后，块级元素浮动则会收缩到内容本身的宽度。 加入浮动后，在父元素中看不见浮动元素，在行内元素看得见浮动，如文本或其他行内元素都会环绕浮动元素。 加入浮动后，浮动盒会向左或向右移动，直到其外边挨到包含块边沿或者另一个浮动盒的外边。 当同一个方向的浮动元素：当一个浮动元素在浮动过程中碰到同一个方向的浮动元素时，它会紧跟在它们后面； 当反方向的浮动元素：互不影响，位于同一条水平线上，当空间不够时会被挤下。 当浮动盒的宽度不一样时，紧跟后面的另一浮动盒则会出现卡住的现象。 加入浮动后，块级元素内容宽度会缩短，呈现inline-block的特性，放不下会换行；行内元素则以块级元素特性呈现，可以设置width、height、margin。 一、浮动：1、从实践尝试到理论定义（1）例子1：放不下会换行一个浮动盒会向左或向右移动，直到其外边（outerEdge）挨到包含块边沿或者另一个浮动盒的外边。如果没有足够的水平空间来浮动，它会向下移动，直到空间合适或者不会再出现其它浮动了（2）例子2：被卡住高度不一样，即出现一个卡住的问题（3）例子3：文本被缩短下移注： 未设置样式的块级元素，即有默认样式，margin-top(or bottom);因为浮动（盒）不在普通流内，在浮动盒之前或者之后创建的未定位的块盒会竖直排列，就像浮动不存在一样。接着，浮动（盒）创建的当前及后续行盒会进行必要的缩短，为了给浮动（盒）的 margin box 让出空间。 例子：如一个普通元素（如p）遇到浮动元素之后，普通元素（如p）看不见这个浮动元素，但这个普通元素里的行盒（文字生成的行盒特性）能看到该浮动元素。当浮动盒宽度变化，文字行盒也会相应地被挤下去换行。 2、从理论到实现效果（1）浮动元素脱离普通流？A、普通流是什么？页面渲染时，遵循“块级元素占据一行，行内元素一行水平排列占据它自身宽度，再来块级元素素依次向下排列”规律，并且这些元素从上到下，从左到右会将父元素所展示的页面撑开。B、脱离普通流：父元素计算宽高的时候，发现不了浮动元素。一旦有浮动元素，块级元素不会按照“从上到下，从左到右”的顺序去展示页面，块级元素会收缩内容宽度（呈现inline-block的特性），那么，父容器不会被里面的浮动元素撑开；行内元素则会能看见浮动元素，如文本或其他行内元素则会环绕浮动元素。例子：脱离普通流？！ （2）小结： 块级元素浮动，宽度会收缩（width:100%;的用武之地）； 行内元素浮动，以块级特性呈现（不用再写display: inline-block;）块级元素浮动宽度收缩，行内元素浮动以块级特性呈现 注： 块级元素默认样式可以撑满父容器，块级元素浮动则会收缩到内容的本身的宽度。如： 1234.box&#123; float: left; background: red; &#125; 注： 行内元素能发现浮动元素，如设置float或者position元素属性，便有了块级元素的特性，可以设置宽高。 1234567span&#123; float: left; background: blue; width: 100px; height: 50px; margin: 10px; &#125;; （3）注： 脱离普通流？！VS abosolute 3、浮动的使用场景（1）两栏布局特指一侧是固定宽度，另一侧是自适应（用margin间隔来表示自适应的作用，是因为普通的块级元素会充满整个页面）左侧固定宽度，右侧自适应 （反之，也可以） （2）三栏布局指两侧宽度固定，中间内容区块自适应简单的三栏布局注： 注意html结构顺序，即按照class为menu——aside——main的div元素顺序写法当一个浮动盒按照设置实现左浮动时，另一个浮动元素设置为右浮，此时这个右浮，即相对于同级元素的高度进行右浮（除非页面放不下被挤下移除外）。 （3）导航条list-style:none; float：left(or right); margin-left:XXpx; 左浮导航 右浮导航 4、清除浮动（1）为什么要清除浮动？虽然浮动是一种实现布局的方式，但是浮动在父元素中看不见。一旦在元素标签内加入了浮动，浮动脱离了普通流，在页面渲染时并不会按照html结构的计算规则，浮动元素会导致父元素所设置的页面无法撑开，浮动甚至会让浮动的效果叠放在页面某些元素效果上。所以必要时，需要清除浮动，这也是浮动实现布局的重要一环。从浮动具有副作用说起：问题A：对后续元素位置产生影响问题B：父容器告诉计算出现问题（2）clear:left;?例子：clear:left? clear:left;：要求该盒的topborder边位于源文档中在此之前的元素形成的所有左浮动盒的bottom外边下方 clear: right;:要求该盒的topborder边位于源文档中在此之前的元素形成的所有右浮动盒的bottom外边下方 即：box2设置clear:right有效吗?有 （3）清除浮动的两大副作用对应问题B：父容器告诉计算出现问题 【重点】由于浮动在父容器中不能被发现，但要解决父容器（或页面）撑开的问题，我们必须在浮动和父容器（或者浮动元素）共存时寻找到一种解决方法。即在带有浮动属性的父元素标签中添加class为clearfix，关于伪元素属性::after （或::before）的固定代码样式，伪元素清除浮动法（IE8以上使用）： 123456789.clearfix::after &#123; content:&apos;&apos;; display: block; clear: both;&#125;/*或触发ie6的属性*/.clearfix &#123; *zoom:1;&#125; 设置一个普通元素内不具有浮动的属性参数，即float：none;和clear: left; 即可将完成clear:left;的效果【注意：应注重css元素的权重，以免报错】或【解决方法：】 方法1：父容器与浮动共存问题的解决 方法2：#1采用伪元素（一个替代标签）解决行内浮动问题#2采用伪元素（一个替代标签）解决块级浮动问题 （4）总结实现一个水平布局 方法1：设置display：inline-block;，注意缝隙和上对其的问题 方法2：加入浮动，用clearfix的固定代码包裹解决父元素撑开页面的问题 二、定位1、什么是定位？（1）先了解正常/文档流（Normal Flow）是什么Normal Flow即浏览器默认的文档布局方式。一旦添加了浮动和定位，脱离文档流之后，页面布局的规则发生变化。 （2）定位通过设置position属性来覆盖默认的布局样式。即元素添加position和对应的属性值，它则会脱离了文档流。position，让一个元素的位置在以前的基础上产生变动。（考虑：相对于谁和属性值） 2、定位的类型（1）静态定位 ：position: static;:默认值 默认的布局方式。（2）相对定位：相对于自身的位置position: relative;:相对默认的布局位置进行定位。注： left和top只对position:absolution/relative/fixed;生效所谓的相对定位，是针对移动的元素自身，相对于它本身原先位置做了对应位置的偏移。但它所占用的文档流位置大小是没有变的。 （3）绝对定位：相对于父元素位置position: absolute; 绝对定位元素脱离正常文档流，相对其定位上下文（Positioning Context）进行定位。 即页面上的正常元素看不见该绝对定位元素。但页面上绝对定位常覆盖其他元素。多个绝对定位元素存在页面，它们之间的绝对定位也相互看不见，产生重叠现象。 寻找页面中一个元素绝对位置，可以先设置该元素绝对定位：position: absolute; 然后先从它的父元素中进行相对定位：position: relative; 中确定该元素的绝对定位；如果没有此绝对定位，再从它的父元素的父元素（如body）里的位置找；如果没有，则根据html的根节点作为参考。 总结： 使用绝对定位时，设置好参考点，一般，绝对定位的参考点为元素父容器如一个元素设置了position：absolute；，那么它的父容器则设置position：relative； 注： 元素中使用了position：absolute;，就像浮动一样有了一些特性： A、加入绝对定位后，宽度收缩B、加入绝对定位后，行内元素呈现快接的特性，可以添加宽高（4）z-index由于使用绝对定位之后，产生元素覆盖的问题，z-index可以解决元素之间覆盖顺序的问题,，设置它的层叠顺序。如：（5）固定定位position: fixed; 相对浏览器窗口进行定位。如“回到顶部”、“内容变固定窗口不变”等效果。因此当滚动产生时，固定定位元素依然处于窗口的某个固定位置。 12345.feedback &#123; right: 30px; bottom: 30px; position: fixed;&#125; （6）粘性定位（兼容性差）position: sticky;是相对定位和固定定位的结合。默认情况下表现为相对定位，当浏览器窗口顶端与元素的距离等于 top 属性的值时，转变为固定定位。如： 三、浮动和定位——解决的一些问题1、BFC和浮动2、浮动和负边距两个浮动元素，如果因放不下导致其中一个下移，对下移的元素设置负 margin值大于自身的宽度可将其上移如： 3、用inline-block;还是浮动（1）inline-block; 优势: 不需要清除浮动，简单，在设置居中时更方便,适合子内容不多的元素水平排列 劣势: 需要注意缝隙，注意对齐，ie8以下不能用 （2）float 优势: 兼容性好，没缝隙问题 劣势: 需要清除浮动，适合稍大的布局 4、用定位还是浮动？大布局、自适应用浮动；小元素、固定宽高用定位。具体要结合实际情况是关键。如：]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（三）:基本样式（下）]]></title>
    <url>%2F2018%2F11%2F08%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、背景 属性 描述 background 简写属性，将背景属性设置在一个生命中 background-attachment 背景图像是否固定或者随着页面的其余部分滚动 background-color 可设置元素的背景颜色 background-image 可把图像设置为背景 background-position 设置背景图像的起始位置（常用于图标在页面上的设置） background-repeat 设置背景图像是否重复，以及如何重复 background-size 设置背景的大小（兼容性）（css3） 1、background-position ：默认图片主要从左上角方向偏移 x y x% y% [top | center | bottom] [left | center | right] 2、background-repeat：背景图像是否重复或如何重复 no-repeat：背景图片在规定位置 repeat-x：图片横向重复 repeat-y：图片纵向重复 repeat：全部重复 3、background-size：背景图片大小的设置，用来拉伸、缩放 100px 100px contain cover 4、关于background相关元素的属性，代码如下：12345/*背景色和背景图片使用场景 */场景1：两元素适用于页面大、背景图片小场景2：背景图为.png格式的图片*/background-color: #f00; background-image: url(background.gif); background-repeat: no-repeat; background-attachment: fixed; background-position: 0 0;/*背景位置与页面窗口的宽、高成正相关*/ 可缩写为一句：background: #f00 url(background.gif) no-repeat fixed 0 0;如图： 注：使用background-color和background-image，需要注意：（1）将该页面撑开（2）注意background-size使用 二、CSS Sprite1、俗称“雪碧图”或“精灵图”指将不同的图片、图标合并在一张图上。2、作用：使用CSS Sprite 可以减少网络请求（如每一张小icon图片都会产生加载时间），提高网页加载性能。3、使用：利用background-position，对图标进行位置偏移三、隐藏or透明 opacity: 0; ：透明度为0，整体（透明度0-1，0.5为半透明） visibility: hidden; : 即元素看不见，但存在。 和opacity：0；类似 display：none； : 消失，不占位置（页面上渲染的其他元素都察觉不到） background-color ：rgba（0，0，0，0.2） 只是背景色透明 四、inline-block1、定义：既呈现inline特性（不占据一整行，宽度由内容宽度决定），又呈现block特性（可设置宽高，内外边距）注： display:block;的布局下，块级元素的宽度是一个可忽视的问题 2、缝隙问题：如图： 3、行内元素对齐问题：如图：在inline-block的布局下，可以看成文字对齐。默认情况下，行内元素对齐是以里面内容的底部为基线对齐（至少两个元素进行对比），其他则设置vertical-align：top(bottom、middle)等）进行基线对齐（在表格中使用尤为明显） 五、line-height1、定义：用于设置单行文本的行高。 2、几个问题：（1）了解line-height和margin、padding在使用上的一个区别 line-height: 2，所占据的行高是本身文字高度的2倍。 margin是外边距， padding则是内边距 （2）line-height的用法，数字和百分比的区别 12&gt; line-height：2`VS `line-height： 100%&gt; line-height具有继承性。 line-height:2，所占据的行高是本身文字高度的2倍。想要页面每个元素都拥有几倍的行高，则设置为数字。 line-height: 200% ，是其父元素文字高度的2倍。（注：百分比有一定的相对性，如本身无设置和设置百分比，便可看出差别） 3、height=line-heihgt设置垂直居中单行文本，如图： 六、盒模型1、IE 盒模型IE 盒模型的width包括：content尺寸+padding+border（如IE678怪异模式，不添加doctype，使用ie盒模型，宽度=边框+padding+内容宽度），如图： 2、W3C标准下的盒模型W3C标准下的盒模型padding、border所占的空间不在width、height范围内，content宽度即是width（如chrome，ie9+,ie678，添加doctype，使用标准盒模型，宽度=内容宽度），如图： 3、box-sizing（css3新样式）为了使用方便，可以用IE盒模型计算宽度的方法，将width=border+padding+内容宽度A、W3C标准的盒模型：box-sizing： content-boxB、IE盒模型：box-sizing：border-box 12&lt;div style=&quot;height:200px; width:200px; border:solid 10px #333; padding:100px&gt;&lt;/div&gt; 七、字体图标的实现1、字体图标的原理：当你写完带有字体的html文件时，在浏览器打开页面时，浏览器会读取 HTML 文件进行解析渲染。当读到「饥饿」两个字时会转换成对应的 unicode码（一种识别字体的特定编号）。再根据HTML里设置的font-family（如果没设置则使用浏览器默认设置）去查找电脑里（如果有自定义字体@font-face ，则加载对应字体文件）对应字体的字体文件。找到文件后根据 unicode 码去查找绘制外形，找到后绘制到页面上。 所以对于第二个范例， 「&amp;#9965」是「饥」的unicede码，所以用户最终也能看到serf字体样式的「饥」字。 2、实现步骤：第一步：进入Iconfont-阿里巴巴矢量图标库——选一个喜欢的图标——添加至购物车——添加至项目——复制Unicode码第二步：进入代码——并未展示图标（说明系统中没有能体现字体图标的该Unicode码，浏览器也未能识别Unicode码）——复制该图标自动生成的css代码（用@font-face来定义一个字体，该字体名可以随便取，这里为：XXX）——定义该字体图标，并设置它css样式如font-family：XXX；等样式 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; @font-face &#123; font-family: &apos;iconfont&apos;; /* project id 645342 */ src: url(&apos;//at.alicdn.com/t/font_645342_wae7ml0d77am7vi.eot&apos;); src: url(&apos;//at.alicdn.com/t/font_645342_wae7ml0d77am7vi.eot?#iefix&apos;) format(&apos;embedded- opentype&apos;), url(&apos;//at.alicdn.com/t/font_645342_wae7ml0d77am7vi.woff&apos;) format(&apos;woff&apos;), url(&apos;//at.alicdn.com/t/font_645342_wae7ml0d77am7vi.ttf&apos;) format(&apos;truetype&apos;), url(&apos;//at.alicdn.com/t/font_645342_wae7ml0d77am7vi.svg#iconfont&apos;) format(&apos;svg&apos;); &#125; p&#123; font-family: iconfont; font-size: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;&amp;#xe618;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 让一个元素”看不见”有几种方式？有什么区别? 1、display: none;给元素设置display:none;后，元素会从页面中彻底消失，它原本占据的空间会被其他元素占有，会造成浏览器的回流与重绘。 2、visibility: hidden;给元素设置visibility:hidden;后，元素会从页面中消失，它原本占据的空间会被保留，会造成浏览器的重绘，适用于希望元素隐藏又不影响页面布局的场景。 3、opacity: 0;给元素设置opacity:0;后，元素变成透明的我们肉眼就看不到了，所以原本占据的空间还在。 4、设置盒模型属性为0将height、width、padding、border、margin等盒模型属性的值全设为0，如果元素內还有子元素或内容，还应overflow: hidden;来隐藏子元素。 123456789.box1&#123; width: 0; height: 0; padding: 0; border: 0; margin: 0; overflow: hidden;&#125; 5、设置元素绝对定位与top、right、bottom、left等将元素移出屏幕如： 123456789.box1&#123; position: absolute; left: 100%;&#125;/*或*/.box1&#123; position: absolute; top: 100px;&#125; 6、设置元素的绝对定位与z-index，将z-index设置成尽量小的负数。但z-index是相对而言的，用z-index就要设置其他元素的z-index值，且如果元素本身占据空间很大就不一定会被z-index值比它大的元素完全覆盖，所以不推荐这种方法。 如： 12345678.box1 &#123; position: absolute; z-index: -100;&#125;.box2&#123; position: absolute; z-index: 1;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shadowsocks入坑不完全指南]]></title>
    <url>%2F2018%2F11%2F07%2Fshadowsocks%E5%85%A5%E5%9D%91%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[​ 国内的网络环境我不说相信大家都懂。虽然墙内的世界很丰富，但是墙外的世界还有着更加精彩的内容。以前上大学时候搜过免费fq教程，体验 Google 搜索、体验 Youtube、查阅学习资料，还有玩的部分游戏，然而大多数免费的不说麻烦而且不稳定，在别人的介绍下跳入了 Shadowsocks 的坑。已经用了快一年，最近又续了1年，访问速度也很快，强烈推荐给大家使用！！！ 购买服务 点击进入 Shadowsocks，进入首页后选择 订购服务。 之后选择你想要购买的服务，点击现在订购。我选择的是 Shadowsocks.com 入门版。需要注意的是，虽然显示的价格是美元，但是在后面支付的时候会自动转化为人民币。 界面上选择你想要购买的类型，然后点击订购。 在结账页面，你需要填写各种信息，需要认真填写，这也是在创建账号。 Shadowsocks 支持 Alipay 支付宝国际版。之后付款就可以了，前两天续费的时候是99.25人民币，平均8块多一个月，还是可以接受的（每个月少喝两瓶肥宅快乐水少抽包烟就是了）。 之后进入 客户中心，用第4步创建的账号登陆。 点击产品服务，可以看到你刚刚购买的服务，状态为有效。 点击刚刚购买的服务，会看到产品详情。下面有配置文件下载，选择 Windows 版下载。下载下来是 gui-config.json。 ​ 客户端安装使用支持的客户端：OS X， Windows， Linux， iOS， Android， OpenWRT 路由器等。详情请参考：客户端 - Shadowsocks，客户端都在 Github 上。 Windows 客户端 直接去 Github - Shadowsocks Windows 上下载吧，我的版本有点旧了也没更新。 解压后有一个 Shadowsocks.exe 文件。最好把这个文件放到一个目录下，比如新建一个 Shadowsocks 文件夹。 把刚刚下载的 gui-config.json 文件放到与 Shadowsocks.exe 相同的目录下。 双击 Shadowsocks.exe，会出现一个 GUI 界面，自动读取了 gui-config.json 文件中的内容。 在右下角托盘图标上会有一个好像纸飞机的 Shadowsocks 图标，右键-&gt;启动系统代理，就可以越过墙壁，浏览更多丰富多彩的内容啦~ 另外建议设置成 右键-&gt;开机启动，这样不用每次开机手动启动了。还可以在 右键-&gt;服务器 中选择不同的服务器。 Linux 客户端 首先你需要下载 Chrome 浏览器 【不需要翻墙】，已经有的小伙伴就不用重新下载了。 使用如下命令安装你下载下来的 Chrome 安装包： 1sudo dpkg -i xxx-chrome-xxx.deb 通过 PPA 源安装 Shadowsocks-qt5，仅支持 Ubuntu 14.04 或更高版本。 123sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5 之后就可以在应用列表里搜索到 Shadowsocks-qt5 了 打开图形化界面，点击 文件 -&gt; 从 gui-config.json 导入链接，接着就会像下图一样。 上图的 jp01 和 us01 都是后来配置好的，导入 gui-config.json 后还是有些需要自己配置。双击某一条连接，像我如下这样配置【默认有的配置就不要改了】： 配置完成后点击 OK，再点击界面上面的 连接，测试下延迟，看看是否能连接上。可以多配置几个，方便切换~ 接下来就是配置 Chrome，让 Chrome 可以使用代理。我们需要安装SwitchyOmega插件。请参考 Chrome 配置 SwitchyOmega快乐上网教程。有需要补充的小伙伴也可以交 ♂ 流下~ IOS 客户端没有苹果设备。。。老哥们自己研究吧！去 客户端 - Shadowsocks 可以找到相关的客户端。 注意 要是偶尔发现网络不稳定，切换线路试一下。 不要同时在多台设备上使用，也不要把配置文件分享给其他人，可能会遭到封号行为。不过手机和 PC 同时使用时没事的。 参考资料 中文文档 - Shadowsocks-qt5]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（二）:基本样式（上）]]></title>
    <url>%2F2018%2F11%2F07%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、块级元素、行内元素 块级（block-level）；行内（内联inline-level） 块级可以包含块级和行内；行内只能包含文本和行内 块级占据一整行空间；行内占据自身宽度空间， 宽高设置、内外边距的差异 1、block-level123div h1 h2 h3 h4 h5 h6 p hr（线）form ul dl ol pre tableli dd dt tr td th 2、inline-level123em strong span a br imgbutton input label select textareacode script 如图： 二、宽高-width、height只对块级元素设置生效，对行内元素设置无效 三、边框-border1、涉及边框的几个元素粗细、颜色、类型（实线、虚线、点线）border-width、border-color、border-style 1234/*简写：*/p,span&#123;border:2px blue solid;&#125; 如图：第一个：第二个：第三个：第四个：第五个： 2、如何使用边框做三角形？第一个：第二个：第三个： 四、边距1、盒模型 2、padding-内边距代表内边距，有四个方向的值，可以合写，值可以是数值、百分比（相对于父容器，不是自身） padding-top padding-right padding-bottom padding-left 3、margin-外边距代表外边距，有四个方向的值，可以合写，值可以是数值、百分比（相对于父容器，不是自身），还可以是负值 外边距合并问题在行内元素中，使用margin和padding左右生效，上下不生效，如图： 12&gt; margin-top`、`margin-right`、`margin-bottom`、`margin-left&gt; 3.1 margin:0 auto 块级元素居中12345.box&#123;/* margin: 0 auto; 实际上是下面两个起了作用 */margin-left:auto;margin-right:auto;&#125; 对于块级元素设置margin:0 auto（即：margin:0 auto 0 auto;）可以达到居中目的 4、* 去除元素默认样式的margin 和padding1234*&#123;margin:0;padding:0;&#125; 由于页面元素在浏览器会有自身的默认样式：如图:用于清除浏览器的固定样式，重新设置宽高,如图可加：注： 默认样式1em=16px 五、display1、块级和行内的display： 块级：block,list-item,table 行内：inline，inline-table，inline-block注： 一个元素在默认情况下是一个display：inline display Value: inline block list-item inline-block table inline-t able table-row table-cell none inherit Initial: inline Applies to: all elements Inherited: no 注：display：inline-block的布局，有相关资料可以了解一下：CSS之使用display:inline-block来布局 2、CSS继承和不继承继承： 每一个元素都是文档树的一部分，每个元素都有其对应的父级元素，每一个父级元素的CSS属性值都可以被应用到它的子元素中。可继承属性一般为：font-size、font-family、color 。反之，CSS不继承通常为页面的细节元素，如border、padding、margin、background-color 、width、height等 六、font font-size：字体大小如：12px（较小）、14px（正常）、16px（浏览器默认）、20px（标题大小）、22、28、60px（大标题大小） font-family：字体，有宋体、微软雅黑、Arial等 font-weight：文字粗度，常用的就是默认值regular和粗体bold line-height：行高，即文字大小，可以用百分比、倍数或者固定尺寸。 font-size*line-height: 垂直高度（行+文字占据的垂直空间）注： 以上属性为可继承给子元素 1、如何使用：12345678910body&#123;font: 12px/1.5 tahoma,arial,&apos;Hiragino Sans GB&apos;,&apos;\5b8b\4f53&apos;,sans-serif;&#125;/*或者*/p &#123;line-height: 1.5;font-size: 14px;font-family: &apos;Helvetica Neue&apos;,Helvetica,Arial,sans-serif;font-weight: bold;&#125; 2、font-family（1）字体原理 使用浏览器打开页面时，浏览器会读取HTML文件进行解析渲染。当读到文字时会转换成对应的unicode码（可以认为是世界上任意一种文字的特定编号）。再根据HTML 里设置的font-family（如果没设置则使用浏览器默认设置）去查找电脑里（如果有自定义字体@font-face，则加载对应字体文件）对应字体的字体文件。找到文件后根据unicode码去查找绘制外形，找到后绘制到页面上。 （2）了解这里有一篇老师写的关于字体方面的实现原理，以前学过一点设计看了，以后如何配合设计师进行字体需求上还是蛮受用的，可以看看：若愚：「每日一题」聊一聊字体图标的实现原理 （3）font-family写法 在 CSS 中设置字体时，直接写字体中文或英文名称浏览器都能识别，直接写中文的情况下编码（GB2312、UTF-8等）不匹配时会产生乱码。保险的方式是将字体名称用Unicode来表示 宋体 SimSun \5B8B\4F53 （Unicode码） 黑体 SimHei \9ED1\4F53 微软雅黑 Microsoft YaHei \5FAE\8F6F\96C5\9ED1 可打开控制台 escape(&#39;微软雅黑&#39;)，将 %u替换成\ 3、chrome最小字体chrome 默认字体大小16px, 最小字体 12px若需要小于12px的字体，可参考以下解决方案：islittle/Web-Developer 七、文本1、类型 text-align：文本对其方式。left、center、right、justify（≈两端对齐） text-indent：文案第一行缩进距离 text-decoration：none（去掉下划线）、underline、line-through（删除线）、overline（顶部线） color：文字颜色 text-transform：改变文字大小写。none（不改写）、uppercase（小写展示大写）、lowercase（大写展示小写）、capitalize（单词的首字母变大写展示） word-spacing：可以改变字（单词）之间的标准间隔（对于中文，每字就是一单词） letter-spacing：字母间隔修改的是字符或字母之间的间隔演示如图所示： 2、几种情况：（1）行内元素居中，如： 123456789&lt;style&gt;.box&#123;text-align: center;&#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;img src=&quot;http://7xpvnv.com2.z0.glb.qiniucdn.com/6673909a-098c-4202-8b80-f4aad64e0262.png&quot;&gt;&lt;/div&gt; （2）display：inline-block元素居中，如： 123&lt;div style=&quot;text-align: center;&quot;&gt;&lt;img style=&quot;margin: 0 auto&quot; src=&quot;XXX.png&quot;&gt;&lt;/div&gt; （3）单行文本溢出，关键代码如： 12345.card &gt; h3&#123;white-space: nowrap;overflow: hidden;text-overflow: ellipsis;&#125; 如图： 八、颜色1、单词：1red`、`blue`、`pink`、`yellow`、`white`、`black 2、十六进制： #ff0000 红色 #0000ff蓝色 #008000 绿色 #000000（黑色）= #000 #ffffff（白色）= #fff #eeeeee（淡灰色）=#eee #cccccc（灰色）=#ccc #666666（深灰色）=#666 #333333（深黑色）=#333 #f00（红色） #0f0（绿色） #00f（蓝色） rgb: rgb(255,255,255)，rgb(0,255,0) rgba: rgba(0,0,0,0.5)（css3中涉及） 九、单位1、px：固定单位2、em：相对长度单位，相对于当前元素的字体大小。如图： 3、rem：相对单位，相对于根元素（html）字体大小，即1rem = html设置的font-size，移动端较常用。关于rem的好处我查了资料这个我比较理解，分享出来：css3的字体大小单位[rem]到底好在哪？ 4、vw vh：相对单位，1vw为屏幕宽度的1% 兼容性较差 5、百分比：（涉及宽高？文字大小？line-height、position）十、其他1、a链接设置颜色注： 当鼠标放置a链接，本身就会出现“手”指针的形状效果 1a 有默认颜色和样式，会覆盖继承的样式 1234a&#123;color：red；text-decoration: none;&#125; 2、列表去掉点123456789/* 设定列表样式为：无 ,即没有顺序数字、圆点出现*/ul&#123;list-style: none;&#125;/*也可这样*/li&#123;list-style: none;&#125; 如图：]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome 配置 SwitchyOmega快乐上网教程]]></title>
    <url>%2F2018%2F11%2F07%2FChrome%20%E9%85%8D%E7%BD%AE%20SwitchyOmega%E5%BF%AB%E4%B9%90%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[此文章是以 Shadowsocks 代理为例，若想使用 Shadowsocks 请先安装对应系统的客户端并启动。详情请参考我的另一篇文章shadowsocks入坑不完全指南。 Chrome 浏览器无论是用户体验、强大的功能还是丰富的扩展程序都完爆国内的各种浏览器好不好。目前已经可以在不翻墙的情况下去 下载 Chrome（桌面版）了，账号数据同步方面也不需要翻墙了。 SwitchyOmegaGoogle Chrome 浏览器上的一个代理扩展程序，可以轻松快捷地管理和切换多个代理设置。比如我们接下来要介绍的 自动切换模式。 下载安装直接打开Chrome应用商店搜索SwitchyOmega然后安装插件就可以了。 配置 Shadowsocks 情景模式 打开 Chrome， 点击右上角的 图标，再点击 选项。 点击左侧的 新建情景模式 输入情景模式名称 ss【自己任意设置名称】，类型选择第一个代理服务器。创建完成后做如下配置： 配置自动切换模式配置好 Shadowsocks 情景模式后虽然可以使用 Chrome 浏览器科学上网了，但是这样的话无论你访问什么网站都会走代理，有时候访问国内的一些网站反而会很慢，这时候自动切换模式就解决了这个问题。下面介绍一下如何配置自动切换模式。 点击左侧的 自动切换，或者自己新建情景模式，类型选择第二个 自动切换模式。然后做如下配置： 切换规则 是在访问 条件设置 的域名时候使用后面设置的 情景模式。比如图中我设置 *.google.com 和 *.twitter.com 使用 ss 情景模式【刚刚创建的那个情景模式】。我们可以点击 添加条件 来添加自己的规则。 将图中 1规则列表规则 前面的框打√，再将后面的 1情景模式 设置为 1ss ，意思是规则列表中的内容，我们使用 1ss 情景模式。然后 1规则列表设置 中： 规则列表格式： AutoProxy； 规则列表网址： https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt ps:如果需要更新直接更新就可以了 这样设置完成 规则列表规则 后就不需要在切换规则中一个一个添加条件了。 切换规则 最后一行的 默认情景模式 代表不在规则列表中网址我们使用 直接连接 情景模式，也就是说不走代理。 参考资料 Github-SwitchyOmega]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记（一）:初识CSS]]></title>
    <url>%2F2018%2F11%2F06%2FCSS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%88%9D%E8%AF%86CSS%2F</url>
    <content type="text"><![CDATA[前言刚接触css的时候，总觉得一个元素对应着它相应的属性，并且与对应的html文件结合，大概就能出现你想要的漂亮页面把。但在CSS身上，“事与愿违”简直就是新手对它的代名词。 在css的世界里，不管是前端老司机，还是资质尚浅的前端小白，都一定会犯“只知其一不知其二”这样的错误。因此，CSS也常被戏称为“不是科学，是艺术”。要知道，“只知其一不知其二”这种错误真的是致命的，因为你永远不知道你明明检查了几万遍的正确的元素属性，到底是哪里出错了。所以在学习CSS之前，请先看一下方方大佬的这篇文章，你就会对接下来学习CSS语法有更多的心理准备。 CSS那么难学竟然是因为它“不正交”：为什么 CSS 这么难学？ 这里先搞清楚几个基本概念：标签、元素、属性，有很多人会搞不清出哪个是指着哪个，一图释所有： 一、CSS介绍1、什么是css？CSS（英文全称：Cascading Style sheets）层叠样式表，是用来为网页添加样式的代码 2、盒模型：（1）内边距（padding）：围绕着内容的空间，比如围绕段落的空间（2）边框（border）：紧接着内边距的实体线段（3）外边距（margin）：围绕元素外部的空间（4）宽度（width）：这个涉及了IE盒模型和标准盒模型（5）高度（height） 二、应用1、简单示例：123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;css&lt;/title&gt;&lt;style&gt;h1&#123;padding:10px;background-color: orange;border:1px solid black;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello css!&lt;/h1&gt;&lt;p&gt;小白学css&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2、CSS的工作原理三阶段： 浏览器输入url ——浏览器向服务器发送请求 —— 服务器将相关数据处理返返至浏览器 —— 浏览器拿到并加载页面 —— 解析html的字符串，词法分析解析成树状结构 —— create Dom tree解析html时，加载css，文件被下载——解析css文件对其分析—— attach style to Dom nodes，加入 create Dom tree两树状结构对应起 来—— 新的dom树（节点相关的元素、参数）—— 渲染、绘制页面 3、css应用方式（1）外部样式表（推荐）A、链接方式：通过&lt;link&gt;引入css，如： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;css&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello css!&lt;/h1&gt;&lt;p&gt;小白学css&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; B、导入方式：通过@import引入样式，放入css中，不要忘记分号可选择以下几种方式：如 12345@import &apos;style2.css&apos;;@import &quot;style2.css&quot;;@import url(&quot;style2.css&quot;);@import url(&apos;style2.css&apos;);@import url(style2.css); 12/*加入条件限制，如媒体查询属性 */@import url(&apos;landscape.css&apos;) screen and (orientation:landscape); （2）内部样式（内嵌方式）即将CSS放在页面的&lt;style&gt;元素中，如： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;css&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;style&gt;@import &quot;style2.css&quot;;p&#123;font-size: 50px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello css!&lt;/h1&gt;&lt;p&gt;你好&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 题外话： 注意文件路径 右键——检查——查看源代码——点击显示错误链接： 1failed to load resource：net：ERR_FILE_NOT_FOUND 即提示有可能是以下错误可能： 文件不存在 文件路径写错了 （3）内联样式（行内方式）（不推荐）即直接在html的标记中使用style属性，将css元素属性的代码直接写在其中，如： 1&lt;p style=&quot;background:orange; font-size:24pax;&quot;&gt;css很棒&lt;/p&gt; （4）属性样式（废弃）如：&lt;img src=&quot;a.png&quot; width=100 height=200&gt; 三、css选择器1、选择器类型A、基础选择器（1）*：通用元素选择器，匹配页面任何元素（比较少用）（2）#id：id选择器，匹配特定id的元素（3）.class：类选择器，匹配class包含（不是等于）特定类的元素（4）element：标签选择器 B、组合选择器（1）E,F多元选择器，相当于并列选择器。用, 分隔，同时匹配元素E或者元素F（2）E F后代选择器。用空格分隔，匹配E元素所有的后代（不只是子元素，子元素向下递归），元素F（3）E&gt;F子元素选择器。用 &gt; 分隔，匹配E元素的所有直接子元素（再嵌套的子元素就没有用）（4）E+F直接相邻选择器。匹配E元素之后的相邻的同级元素F（5）E~F普通相邻选择器（弟弟选择器），匹配E元素之后的同级元素F （无论直接相邻与否）（6）.class1.class2 （既、又）id和class选择器和选择器连写的时候中间没有分隔符，.和#本身充当分隔符的元素（7）element#idid和class选择器和选择器连写的时候中间没有分隔符，.和#本身充当分隔符的元素C、属性选择器D、伪类选择器E、伪元素选择器 2、基础选择器（1）* ：通用元素选择器，匹配页面任何元素（比较少用）（2）#id：id选择器，匹配特定id的元素（3）.class：类选择器，匹配class包含（不是等于）特定类的元素（4）element：标签选择器 演示图： 3、组合选择器（1）E,F多元选择器，相当于并列选择器。用,分隔，同时匹配元素E或者元素F（2）E F后代选择器。选择它所有的后代子元素。用空格分隔，匹配E元素所有的后代（不只是子元素，子元素向下递归），元素F（3）E&gt;F子元素选择器。（普遍）选择它第一子元素，对再嵌套的子元素没用。用&gt;分隔，匹配E元素的所有直接子元素（4）E+F直接相邻选择器。匹配E元素之后的相邻同级所有元素F（5）E~F普通相邻选择器（弟弟选择器），匹配E元素之后的同级元素F （无论直接相邻与否）（6）.class1.class2 既、又，直接靠在一起，同时拥有这两个类选择器特性的一个元素。id和class选择器和选择器连写的时候中间没有分隔符，.和#本身充当分隔符的元素（7）element#idid和class选择器和选择器连写的时候中间没有分隔符，.和 #本身充当分隔符的元素 4、属性选择器（1）E[attr]匹配所有具有属性attr的元素，如div[id] 就能取到所有有id属性的div（2）E[attr=value] 匹配属性attr值为value的元素，如div[id=test]，匹配id=test的div 5、伪类选择器（1）定义：代表一个元素的另一种状态（2）类型：A、第一类： E: first-child匹配元素E的第一个子元素 E：link 匹配所有未被点击的链接 E: visited匹配所有已被点击的链接 E：active匹配鼠标已经其上按下，还没被释放的E元素 E：hover 匹配鼠标悬停器上的E元素 E：focus匹配获得当前焦点的E元素 E：lang(c)匹配lang属性等于c的E元素 E：enabled 匹配表单中可用的元素 E：disabled 匹配表单中禁用的元素 E：checke 匹配表单中被选中的radio或checkbox元素 E：selection 匹配用户当前选中的元素 例子1：如设置E：hover时，鼠标悬停元素时字体颜色就会变成蓝色。选择器权重会使得a:hover{color:blue;}大于a{color：red;}的权重，所以样式产生了覆盖，如图： 例子2:a链接上常用的css属性选择器： E：link 匹配所有未被点击的链接 E: visited匹配所有已被点击的链接 E：hover 匹配鼠标悬停器上的E元素 E：active 匹配鼠标已经其上按下，还没被释放的E元素由于css元素按顺序填写，依次展现元素属性，这里涉及到：a这个元素下的伪类选择器权重，从而造成样式覆盖，如图演示： 例子3：(1) E：enabled 匹配表单中可用的元素(2) E：disabled 匹配表单中禁用的元素如输入框被禁用，如何设置css里的元素属性，如图： B、第二类：(1) E：root匹配文档的根元素，对于html文档，实际上就是html元素(2) E：nth-child（n） 匹配其父元素的第n个子元素，第一个编号为1注： E:nth-of-type(n)与:nth-child()作用类似，但仅匹配使用同种标签的元素如图当n=1时如图当n=？（1除外的任意数）n的取值 1231，2，3，4，52n+1，2n，4n-1odd，even： 如何运用： 做一个表格上，分别可以做两色相间的表格效果，那么就可以运用odd，even 12345/* nth-child(odd) 与 :nth-child(even) 分别匹配序号为奇数与偶数的元素 */.h-table tr:nth-child(even)&#123;background-color: #f1f1f1;&#125; 例子： 6、伪元素选择器（1）E::first-line 匹配E元素内容的第一行（2）E::first-letter 匹配E元素内容的第一个字母（3）E::before 在E元素之前插入生成的内容（4）E::after 在E元素之后插入生成的内容 举例如图： 7、选择器的优先级（1）定义如果多条规则作用于同一个元素上，且定义的相同属性的不同值。 （2）代码如下： 12345&lt;style&gt;#test&#123;color:#666;&#125;p &#123;color:#333;&#125;&lt;/style&gt;&lt;p id=&quot;text&quot;&gt;Text&lt;/p&gt; （3）CSS优先级从高到低分别是：A、在属性后面使用 ：！important 即会覆盖页面内任何位置定义的元素样式B、作为style属性写在元素标签上的内联样式C、id选择器D、类选择器E、伪类选择器F、属性选择器G、标签选择器H、通配符选择器I、浏览器自定义 （4）复杂场景(按顺序） a、行内样式&lt;div style=&quot;XXX&quot;&gt;&lt;div&gt;b、ID选择器c、类、属性选择器、伪类选择器d、标签选择器、伪元素 注： 选择器的优先级是如何计算的？ A、按顺序来计算的：假设： a等级：行内样式&lt;div style=&quot;XXX&quot;&gt;&lt;div&gt;b等级：ID选择器c等级：类、属性选择器、伪类选择器d等级：标签选择器、伪元素 即a-d等级权值依次为5、4、3、2，按照a-d等级的属性顺序依次得分，若取到相应等级的权值，最高的则为最优先级别。 B、参考：当不同类别的多个选择器混合使用个怎么计算优先级？有一个简单的算法，设 a.内联样式表的权值为1000b.ID选择器的权值为100c.class类选择器的权值为10d.HTML标签选择器的权值为1 （5）样式覆盖后面的样式会覆盖到前面的样式 （6）选择器使用经验 遵守css书写规范 使用合适的命名空间 合理地复用class- 四、习题练习1、CSS 加载方式有几种？答：（1）外部样式表（链接+导入）（推荐） 通过&lt;link&gt;引入css 通过@import导入样式，放入css中，不要忘记分号。在html或者css文件中都可以导入@import（2）内部样式（内嵌方式），即将CSS放在页面的&lt;style&gt;元素中（3）内联样式（行内方式）（不推荐），即直接在html的标记中使用style属性，将css元素属性的代码直接写在其中（4）属性样式（废弃） 2、@charset有什么作用？在外部样式表文件内使用，指定该样式表使用的字符编码。该规则后面的分号是必需的，如果省略了此分号，会生成错误信息。如在外部css文件中写： 123@charset &quot;utf-8&quot;;* &#123;sRules&#125;.class&#123;sRules&#125; 3、@import有什么作用？如何使用？答：作用：通过@import引入样式或者css文件，可以减少文件的容量，加快文件加载速度。用法： 12345@import &apos;style2.css&apos;;@import &quot;style2.css&quot;;@import url(&quot;style2.css&quot;);@import url(&apos;style2.css&apos;);@import url(style2.css); 4、id 选择器和 class 选择器的使用场景分别是什么？答：（1）id选择器，用于匹配特定id的元素，具有独一无二不可代替性（2）class选择器，用于匹配class包含（不是等于）特定类的元素，描述一组元素的样式，你可以多次使用class赋值，来命名元素名 5、CSS选择器常见的有几种？答：基础选择器、组合选择器、属性选择器、伪类选择器、伪元素选择器 6、伪类选择器有哪些？伪元素有哪些？答：（1）伪类选择器： E: first-child匹配元素E的第一个子元素 E：link 匹配所有未被点击的链接 E: visited 匹配所有已被点击的链接 E：active 匹配鼠标已经其上按下，还没被释放的E元素 E：hover 匹配鼠标悬停器上的E元素 E：focus匹配获得当前焦点的E元素 E：lang(c) 匹配lang属性等于c的E元素 E：enabled 匹配表单中可用的元素 E：disabled 匹配表单中禁用的元素 E：checked 匹配表单中被选中的radio或checkbox元素 E：selection 匹配用户当前选中的元素 E：root 匹配文档的根元素，对于html文档，实际上就是html元素 E：nth-child（n） 匹配其父元素的第n个子元素，第一个编号为1 E:nth-of-type(n)与：nth-child()作用类似，但仅匹配使用同种标签的元素 （2）伪元素： E::first-line 匹配E元素内容的第一行 E::first-letter 匹配E元素内容的第一个字母 E::before 在E元素之前插入生成的内容 E::after 在E元素之后插入生成的内容 7、以下选择器分别是什么意思?（1） 12#header&#123;&#125; 答：id选择器，匹配id为header的元素 （2） 12.header&#123;&#125; 答：类选择器，匹配class为header元素 （3） 12.header .logo&#123;&#125; 答：后代选择器，匹配class为header的元素logo （4） 12.header.mobile&#123;&#125; 答：即又关系的并列元素，同时匹配这两个类选择器特性的一个元素 （5） 12.header p, .header h3&#123;&#125; 答：多元选择器，同时匹配.header p 和 .header h3两个元素 （6） 12#header a:hover&#123;&#125; 答：在id为header元素下匹配a元素鼠标悬停属性 （7） 12#header .logo~p&#123;&#125; 答：在id为header元素下匹配logo元素之后的同级所有元素p （无论直接相邻与否） （8） 12#header .logo+p&#123;&#125; 答：在class为header元素下匹配logo元素之后的相邻同级元素p （9） 12#header .logo p&#123;&#125; 答：在id为header元素下匹配class为logo的后代元素p （10） 12#header .logo&gt;p&#123;&#125; 答：在id为header元素下匹配class为logo元素的所有直接子元素，即第一子元素p （11） 12#header p.logo&#123;&#125; 答：在id为header元素下同时匹配p元素和class为logo元素这类既又关系（并列）的元素的特性 （12） 12#header .logo.p&#123;&#125; 答：在id为header元素下同时匹配class为logo和p的元素 （13） 12#header input[checked]&#123;&#125; 答：在id为header元素下匹配checked值的input的元素 8、运行如下代码，并对结果做出解释 123456789101112131415161718192021222324&lt;style&gt;.box:first-child &#123;color: red;&#125;.box:first-of-type &#123;background: blue;&#125;.box :first-child &#123;font-size: 30px;&#125;.box :first-of-type &#123;font-weight: bold;&#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt;&lt;div class=&quot;box&quot;&gt;div.box&lt;/div&gt;&lt;p class=&quot;box&quot;&gt;p.box&lt;/p&gt;&lt;div class=&quot;box&quot;&gt;div.box&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;div class=&quot;item&quot;&gt;div.item&lt;/div&gt;&lt;p class=&quot;item&quot;&gt;p.item&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;box&quot;&gt;&lt;/p&gt;&lt;/div&gt; （1）效果图展示：（2）对其结果作出解释：运行1： 123.box:first-child &#123;color: red;&#125; 选择同级第一个元素,并且这个元素class是 box,显示该标签元素的内容颜色为红色 运行2： 123.box:first-of-type &#123;background: blue;&#125; 选择同级第一个标签元素,并且这个元素是这个同级中的第一个标签，显示背景色为蓝色 运行3：（.box : :.box和:之间要有空格） 123.box :first-child &#123;font-size: 30px;&#125; 表示.box 里面（父元素）的第一个元素，显示字体大小为30px的结果 运行4： 123.box :first-of-type &#123;font-weight: bold;&#125; 选择 .box里（父元素）第一个同类型的元素，字体粗细为粗体 五、在线小游戏​ CSS Diner一个可以练习CSS选择器的小游戏。123456789101112131415161718192021222324252627282930313233参考答案（不唯一）01. plate02. bento 03. #fancy 04. plate apple 05. #fancy pickle 06. apple.small 07. orange.small 08. bento orange.small 09. plate , bento 10. * 11. plate * 12. plate + apple 13. bento ~ pickle 14. plate &gt; apple 15. plate orange:first-child 16. plate *:only-child 17. #fancy *:last-child , plate + pickle 18. plate:nth-child(3) 19. bento:nth-last-child(3) 20. apple:first-of-type 21. plate:nth-of-type(2n) 22. plate:nth-of-type(2n+3) 23. plate apple.small:only-of-type 24. orange:last-of-type , apple:last-of-type 25. bento:empty 26. apple:not(.small) 27.［for]28.plate[for]29.[for=&quot;Vitaly&quot;]30.[for^=&quot;Sam&quot;],[for^=&quot;Sarah&quot;]31.[for$=&quot;Hayato&quot;],[for$=&quot;Minato&quot;]32.[for*=&quot;Robbie&quot;],[for*=&quot;Bobby&quot;]]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS入门]]></title>
    <url>%2F2018%2F11%2F05%2FCSS%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1.CSS的全称是什么?CSS 指层叠样式表（Cascading Style Sheets）。通过CSS和HTML的结合可以实现表现与结构分离。从而提升工作效率，降低维护难度。 2.CSS有几种引入方式? link 和@import 有什么区别?css有四种引入方式： 1.内联方式 内联方式指的是直接在 HTML 标签中的 style 属性中添加 CSS。 这通常是个很糟糕的书写方式，它只能改变当前标签的样式，如果想要多个 拥有相同的样式，你不得不重复地为每个 添加相同的样式，如果想要修改一种样式，又不得不修改所有的 style 中的代码。很显然，内联方式引入 CSS 代码会导致 HTML 代码变得冗长，且使得网页难以维护。 2.嵌入方式 嵌入方式指的是在 HTML 头部中的 标签下书写 CSS 代码。 .content { background: red; } 嵌入方式的 CSS 只对当前的网页有效。因为 CSS 代码是在 HTML 文件中，所以会使得代码比较集中，当我们写模板网页时这通常比较有利。因为查看模板代码的人可以一目了然地查看 HTML 结构和 CSS 样式。因为嵌入的 CSS 只对当前页面有效，所以当多个页面需要引入相同的 CSS 代码时，这样写会导致代码冗余，也不利于维护。 3.链接方式 链接方式指的是使用 HTML 头部的 标签引入外部的 CSS 文件。 这是最常见的也是最推荐的引入 CSS 的方式。使用这种方式，所有的 CSS 代码只存在于单独的 CSS 文件中，所以具有良好的可维护性。并且所有的 CSS 代码只存在于 CSS 文件中，CSS 文件会在第一次加载时引入，以后切换页面时只需加载 HTML 文件即可。 4.导入方式 导入方式指的是使用 CSS 规则引入外部 CSS 文件。 @import url(style.css); link和@import两者都是外部引用CSS的方式，但是存在一定的区别： 区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。 区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载 区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 区别4：ink支持使用Javascript控制DOM去改变样式；而@import不支持。 3.以下这几种文件路径分别用在什么地方，代表什么意思? 4.如果我想在js.jirengu.com上展示一个图片，需要怎么操作?可以直接将图片上传到服务器，在页面使用这张图片；或者将图片存在本地服务器，然后打开本地服务，然后在网站上上引用图片 如果这个图片本来就存在网络上其他的服务器上，可以直接使用图片的网络路径链接的方式在页面上添加url引用这张图片，说白了就是把图片的引用地址改成网络路径就行了。 5.列出5条以上html和 css 的书写规范1.统一使用小写 2.不使用内联的style属性定义样式 3.id和class语义化，分隔符建议使用- 4.有可能就用缩写 5.属性值是0，省略单位，比如不要写成0px，直接是0 6.块内容缩进 7.禁止 img的 src取值为空。延迟加载的图片也要增加默认的 src 6.介绍 Chrome 开发者工具的功能区 1是元素区，在这可以看到整个网页的结构 2和12 都是控制台，录开发者开发过程中的日志信息，且可以作为与JS进行交互的命令行Shell 3 是资源，这里可以看到各种你引入的js，主要就是用于调试js 4 从发起网页页面请求Request后分析HTTP请求后得到的各个请求资源信息（包括状态、资源类型、大小、所用时间等），可以根据这个进行网络性能优化 5.时间线记录并分析在网站的生命周期内所发生的各类事件，以此可以提高网页的运行时间的性能。 6.记录JS CPU执行时间细节、显示JS对象和相关的DOM节点的内存消耗、记录内存的分配细节。 7.记录网站加载的所有资源信息，包括存储数据（Local Storage、Session Storage、IndexedDB、Web SQL、Cookies）、缓存数据、字体、图片、脚本、样式表 8.安全：判断当前网页是否安全 9.对当前网页进行网络利用情况、网页性能方面的诊断，并给出一些优化建议。比如列出所有没有用到的CSS文件等 10.样式区域，可以直观的看到css 11.适配区域，可以适配各种屏幕大小，一般用于调试页面自适应。]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈HTML（三）：表单元素]]></title>
    <url>%2F2018%2F11%2F04%2F%E6%B5%85%E8%B0%88HTML%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[一、实践1、贴上完整的代码图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/a123&quot; method=&quot;get&quot;&gt;&lt;div class=&quot;username&quot;&gt;&lt;label for=&quot;username&quot;&gt;姓名&lt;/label&gt;&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username1&quot; placeholder=&quot;用户名&quot;&gt;&lt;/div&gt;&lt;div class=&quot;password&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;input id=&quot;password&quot; type=&quot;password&quot; name=&quot;password1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;sex&quot;&gt;&lt;label for=&quot;sex&quot;&gt;性别&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女&lt;/div&gt;&lt;div class=&quot;hobby&quot;&gt;&lt;label&gt;爱好&lt;/label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;wangzhe&quot;&gt;王者荣耀&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;travl&quot;&gt;旅游&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;pet&quot;&gt;宠物&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;music&quot;&gt;音乐&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;running&quot;&gt;跑步&lt;/div&gt;&lt;div class=&quot;textarea&quot;&gt;&lt;label for=&quot;textarea&quot;&gt;评论&lt;/label&gt;&lt;textarea name=&quot;article&quot;&gt;哈哈哈哈&lt;/textarea&gt;&lt;input type=&quot;hidden&quot; name=&quot;abcd&quot; value=&quot;12345&quot;&gt;&lt;/div&gt;&lt;div class=&quot;file&quot;&gt;&lt;input type=&quot;file&quot; name=&quot;myfile&quot; accept=&quot;image/png&quot;&gt;&lt;/div&gt;&lt;div class=&quot;choose&quot;&gt;&lt;label for=&quot;pet&quot;&gt;我的宠物&lt;/label&gt;&lt;select name=&quot;city&quot;&gt;&lt;option value=&quot;cat&quot;&gt;猫&lt;/option&gt;&lt;option value=&quot;dog&quot; selected&gt;狗&lt;/option&gt;&lt;option value=&quot;fish&quot;&gt;鱼&lt;/option&gt;&lt;/select&gt;&lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、效果图： 二、具体标签：1、form代码结构如： 1&lt;form action=&quot;/a123&quot; method=&quot;get&quot;&gt; form标签是表单的外壳，有4个主要属性： （1）action：表单提交的地址 （2）method：提交表单的方法 （3）target：在何处打开action （4）enctype： application／x-www-form-urlencoded：在发送前编码所有字符（默认） text／plain：空格转换为“+”加号，但不对特殊字符编码 multipart／form-data：使用包含文件上传控件的表单是，必须使用该值 2、type代码结构如： 1&lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt; （1）type=&quot;text&quot;普通的文本输入框，单行输入（不行回车换行）。可输入文字展示 （2）type=&quot;password&quot;输入密码是以圆点展示，不被人知道 （3）type=&quot;checkbox&quot; 呈现带有阴影的勾选方框代码如下： 123456&lt;div class=&quot;hobby&quot;&gt;&lt;label for=&quot;hobby&quot;&gt;爱好&lt;/label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;read&quot;&gt;读书&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;music&quot;&gt;听歌&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;swim&quot;&gt;游泳&lt;/div&gt; 如图： 注： A、如果是分组，name写成不同，表示多选，如针对hobby这个关键字的搜索，value值需要设置，否则后台提交的用户信息将显示为on（无信息展示）。 B、value的作用：让后台来识别该字段的信息 （4）type=&quot;radio&quot; 呈现带有阴影的点选圆框代码结构如下： 12345&lt;div class=&quot;hobby&quot;&gt;&lt;label for=&quot;sex&quot;&gt;性别&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女&lt;/div&gt; 图： 注：radio 如何分组？举例说明，只需要在&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;中的name值设置另一个意义值，就可以分组显示，如： 第1组： 12&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女 第2组： 12&lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;女&quot;&gt;女 即： 1234567&lt;div class=&quot;hobby&quot;&gt;&lt;label for=&quot;sex&quot;&gt;性别&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女&lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;女&quot;&gt;女&lt;/div&gt; 如图： （5）type=&quot;file&quot; 用于文件上传，呈现“选择文件”按钮，点击即可上传文件 1&lt;input type=&quot;file&quot; name=&quot;myfile&quot; accept=&quot;image/png，image/jp&gt; 注： accept该参数使用，即用于接收所限制的文件格式 （6）type=&quot;hidden&quot;作用： 暂存信息。 如在type=&quot;hidden&quot;埋下一个值，后台定位获取相应的值，可安全存值，用户什么都看不见，只能在后台看到； 保障安全。 当打开一个页面，实际上该页面是后端写的模板并在里面填充数据，填充好数据后，安全策略时使用 1type=&quot;hidden&quot; ，即： 1&lt;input type=&quot;hidden&quot; name=&quot;abc&quot; value=&quot;123456&quot;&gt; 当用户提交用户信息至后台，同时该安全点type=&quot;hidden&quot;的值也会提交后台，后台进行校验——确认过安全，相当于埋在后台与用户信息相匹配的一个安全校验值，即该用户为一个合法用户。 （7）type=&quot;button&quot;，不能点击提交 （8）type=&quot;submit&quot;，可以点击提交 （9）type=&quot;reset&quot;，用于清空所有用户信息 注： A、以下input有何作用？ 1&lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;提交按钮&quot;&gt; B、type=&quot;submit&quot; ， 提示input作用为“提交”按钮 C、value=&quot;提交&quot;， 显示提交作用，意义在于“点击提交”的交互作用 D、input里name 作用？ 即用于传递数据给后台都形成有意义的识别值，如用value和name赋值，如果不写的话，该输入标签将不会有任何意义，就等于无实际操作表单的意义。 3、type=hidden隐藏域作用type=hidden隐藏域，作为校验该用户信息的一个隐藏值（判断标准）。当用户打开页面后是看不见type=hidden相应的值，填写用户信息之后点击提交时，用户信息的数据（包括type=hidden值）随即提交后台，打开后台则会展示代码type=hidden所写的相应元素属性值。后台校验type=hidden相应值如果是正确，即用户提交为安全。 埋点（保护的参数）——浏览器提交后台有该参数作为校验标准参考——若显示错值或无值，服务器也将不承认所提交的数据；若为正确值，则说明该用户获取权限，即为合法用户，可防止CSRF攻击 4、label输入框前的文字标注代码如下： 1234&lt;div class=&quot;username&quot;&gt;&lt;label for=&quot;username&quot;&gt;姓名&lt;/label&gt;&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username1&quot;&gt;&lt;/div&gt; 注：for，用于点击文字或输入框时，是文字显示一种focus状态，可直接输入对应信息 5、select下拉菜单代码结构如下： 12345678&lt;div class=&quot;choose&quot;&gt;&lt;select name=&quot;city&quot;&gt;&lt;label for=&quot;pet&quot;&gt;我的宠物&lt;/label&gt;&lt;option value=&quot;cat&quot;&gt;猫&lt;/option&gt;&lt;option value=&quot;dog&quot;&gt;狗&lt;/option&gt;&lt;option value=&quot;fish&quot;&gt;鱼&lt;/option&gt;&lt;/select&gt;&lt;/div&gt; option中，设置默认选择的初始值，即 &lt;option value=&quot;cat&quot; selected&gt;猫&lt;/option&gt; 6、extarea实现多行文本，展示较大的输入框。即常见的评论框。代码结构如下： 123456&lt;div class=&quot;textarea&quot;&gt;&lt;label for=&quot;textarea&quot;&gt;评论&lt;/label&gt;&lt;textarea name=&quot;article&quot;&gt;123&lt;/textarea&gt;&lt;/div&gt; 注：若在&lt;textarea&gt;...&lt;/textarea&gt;中输入任意值，即相当于value赋值的意义，也就是说在&lt;textarea&gt;...&lt;/textarea&gt;输入的值都能显示其输出的意义。 7、placeholder用于输入什么用户信息的提示代码结构如下： 1234&lt;div class=&quot;username&quot;&gt;&lt;label for=&quot;username&quot;&gt;姓名&lt;/label&gt;&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username1&quot; placeholder=&quot;用户名&quot;&gt;&lt;/div&gt; 图：]]></content>
      <categories>
        <category>前端</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈HTML（二）：表单提交原理]]></title>
    <url>%2F2018%2F11%2F03%2F%E6%B5%85%E8%B0%88HTML%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、html表单1、什么是表单能够去输入用户信息的一个单子。和我们平时填写的纸质表单一样，在HTML页面上，也有表单是用于搜集不同类型的用户信息输入。 2、作用用于收集已收集的信息，提交你网站的后台（或者服务器）。HTML表单是一个包含表单元素的区域，表单元素是允许用户在表单中（表单元素包含如：文本域、下拉列表、单选框、复选框等）输入信息的元素。 二、写表单1、表单提交原理一般表单有登录名、密码，form、input，表单所有信息用form元素包裹。用包裹所有input元素输入框，当点击提交后，将会把form所包裹得所有input输入框的信息提交给后台的一个地址上。 2、写表单（1）表单内的主要标签属性：A、&lt;form&gt;...&lt;/form&gt;B、&lt;form action=&quot;/a123&quot; method=&quot;get&quot;&gt; action : 把数据提交到后台的地址，如action=&quot;/a123&quot;，即提交到当前域名下的/a123 method：提交数据的方式 （2）demo： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;login&quot;&gt;&lt;form action=&quot;/a123&quot; method=&quot;get&quot;&gt;&lt;div class=&quot;sex&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;sex1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;username&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;password&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;submit&quot;&gt;&lt;button&gt;提交&lt;/button&gt;&lt;/div&gt;&lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; （3）html文件用浏览器打开页面当写出登录名、密码、提交代码后（之后加上性别），以get形式点击提交，页面url显示input输入的相应的内容： 注：点击提交代表向服务器发送了一个请求，这个文件是通过get方式进行表单收集 假如，将以下代码放置在&lt;form&gt;&lt;/form&gt;标签之外， 12345678&lt;div&gt;&lt;div class=&quot;sex&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;sex1&quot;&gt;&lt;/div&gt;&lt;form&gt;.....&lt;/form&gt;&lt;/div&gt; 以get形式提交的页面url也不会显示相应的内容： 3、终端上操作即本地终端开启服务器，以服务端的方式打开页面（1）命令行开启静态服务器，并打开页面：因为之前我已经安装nodejs，用npm安装了http-server这个服务器，所以可以执行以下代码直接打开这个静态服务器： 1$ http-server 代码执行之后，输入相应的url出现的页面，两步骤之后的示意图：注：以下情况给没有安装nodejs 的人看的（安装了就可以不看） 假如有人之前没安装nodejs，就不能用npm命令去开启一个静态服务器，所以可以先看看我这篇：浅谈命令行（二）：安装静态服务器（涉及nodejs和npm的使用）​看完之后可以下载nodejs，在终端执行以下代码：​​$ sudo npm install -g http-server$ http-server这样之后就开启了一个静态服务器，就可以用里面的url打开相应的html文件​（2）输入相应信息之后，出现：​（3）页面右键——检查，重新输入表单信息，点击提交出现页面相对应的html文件——demo.html的请求，先贴上我操作后出现的页面：​ 请求的地址：http://127.0.0.1:8080/a123?username1=neil&amp;password1=123456 请求的类型：Request Method: GET 请求的参数：username1: neilpassword1: 123456​（4）两种请求类型：get和postA、get请求即当demo.html中method=&quot;get&quot;时，页面上点击“提交”时，就会将demo.html展现的信息进行组装，以view的形式去组合成这个url地址：http://127.0.0.1:8080/a123?username1=neil&amp;password1=123456，向这个地址发送请求。​get请求，本质上就是url的拼接，把你的参数拼接在一起组成一个新的url:标签中的name属性​B、post请求关于post类型发送请求：由于我的服务器http-server，是个静态文件服务器，不支持post请求。可以看老司机的演示： post的请求类型得到的url地址更干净，更安全。​​ 三、post和get的区别1、method提供两种提交方式：一种是get方式向后台发送请求，提交数据；另一种是post方式向后台发送请求，提交数据 2、区别（1）从安全性上，二者表象不同，get把提交的数据url可以看到，会展现在浏览器历史记录中，安全性不好；但是post看不到，安全性好。​（2）从提交数据量上，get最多提交1k数据，浏览器上的url地址框有字符长度限制；post理论上无限制，受服务器限制。​（3）从原理上，get 是拼接 url，post是放入http 请求体中。 3、应用场景（怎么合理两种方式传递数据？）注： 在实际应用上，get 重在 “得到”, post 重在”传递”​​即假如向后台查询一篇论文，请求数据，请求为“得到”，用get方式请求数据；向后台“传递”数据，写了文章之后传递至后台，通常是“传递完成”的状态进行提示，用post方式请求数据。​​ 四、表单元素普通用户点上面一个，能FQ的点第二个，轻戳：HTML 表单元素HTML 表单指南]]></content>
      <categories>
        <category>前端</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈HTML（一）：部分标签]]></title>
    <url>%2F2018%2F11%2F03%2F%E6%B5%85%E8%B0%88HTML%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%83%A8%E5%88%86%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[本文主要讲述以下内容： &lt;iframe&gt; &lt;a&gt;及伪协议 &lt;form&gt; &lt;input&gt; &lt;table&gt; 及 &lt;colgroup&gt; 可替换元素 空元素 其他 一.iframe iframe 标签 用于嵌套页面,新开一个窗口（沙箱隔离，引用第三方内容）1src指定：&lt;iframe src=&quot;[https://www.baidu.com](http://link.zhihu.com/?target=https%3A//www.baidu.com/)&quot; name=&quot;xxx&quot;&gt;&lt;/iframe&gt; 链接打开： QQ baidu iframe可用于所见即所得的网页编辑器。 二. a (anchor) , 伪协议 &lt;a&gt;用于http get 请求 属性download 下载链接指定文件 查看使用&lt;a&gt;来创建可点击图片，如何创建email链接，电话链接 &lt;a&gt;的示范: &lt;a href=&quot;qq.com&quot;&gt;qq&lt;/a&gt;错误示范，表示qq.com文件 &lt;a href=&quot;//qq.com&quot;&gt;qq&lt;/a&gt; 浏览器会根据当前协议，补全无协议链接的协议 如果用 file:// 协议浏览页面，就会访问到 file://http://qq.com，这是一个不存在的路径 应该尽量不使用 file:// 协议预览网页，以免无协议链接出错 link 浏览器发起 GET /?name=li HTTP/1.1 请求 anchor 页面内跳转， &lt;a href=”javascript:alert(“a”) &gt; 伪协议, 阻止页面跳转 伪协议： 可以在用户点击 a 时执行一段 javascript 代码 在地址栏输入 javascript:alert(1) 可以在当前页面执行一段代码 伪协议可以实现「点击之后没有任何动作的 a 标签」，满足一些奇葩需求 滚回顶部 刷新页面 link 浏览器发起 GET / HTTP/1.1 的请求 target属性 _self : 当前页面加载，即当前的响应到同一HTML 4 frame _blank : 新窗口打开，即到一个新的未命名的HTML4窗口或HTML5浏览器上下文 _parent : 加载响应到当前框架的HTML4父框架或当前的HTML5浏览上下文的父浏览上下文。如果没有parent框架或者浏览上下文，此选项的行为方式相同_self。 _top : HTML4中：加载的响应成完整的，原来的窗口，取消所有其它frame。 HTML5中：加载响应进入顶层浏览上下文（即，浏览上下文，它是当前的一个的祖先，并且没有parent）。如果没有parent框架或者浏览上下文，此选项的行为方式相同_self 三. form 必须有提交按钮，一般作为post请求 get 默认会把参数放在查询参数里面 post默认会把参数放在请求header的第四部分里面 form 具有target属性： 如果一个里面只有一个btn ,他会自动升级为提交按钮只有一个或者 依然只是普通按钮只有一个可以提交，是唯一能确定form是否可以提交 四.input如果 input 不加 name，那么在表单提交时，input 的值就不会出现在请求里,checkbox, radio 的 name表示一组。 &lt;label&gt;把input包起来，可以关联，input 属性： require表示该表单必填 ，：输入（表单输入）元素 type部分类型：12345678- submit / reset- range- search- data / datatime /datetime-local- image- file- email- hidden 五.&lt;table&gt; 及&lt;colgroup&gt;123&lt;table&gt;： thead tbody tfoot caption tr td/th&lt;colgroup&gt; : 定义表格内的一组列。 示例: 1234567&lt;table border=1&gt;&lt;colgroup&gt;&lt;col width=100&gt;控制列宽&lt;col width=100&gt;...... 六.可替换元素CSS 里，可替换元素（replaced element）的展现不是由CSS来控制的。这些元素是一类 外观渲染独立于CSS的 外部对象。 典型的可替换元素有&lt;img&gt;、 &lt;object&gt;、 &lt;video&gt; 和 表单元素，如&lt;textarea&gt;、 &lt;input&gt; 。 某些元素只在一些特殊情况下表现为可替换元素，例如 &lt;audio&gt;和 &lt;canvas&gt;。 通过 CSS content 属性来插入的对象 被称作 匿名可替换元素（anonymous replaced elements）。 七.空元素空元素就是不用加闭合标签的标签，也可以叫闭元素。如：1234567891011121314151617&lt;area&gt;&lt;base&gt;&lt;br&gt;&lt;col&gt;&lt;colgroup&gt;&lt;command&gt;&lt;embed&gt;&lt;hr&gt;&lt;img&gt;&lt;input&gt;&lt;keygen&gt;&lt;link&gt;&lt;meta&gt;&lt;param&gt;&lt;source&gt;&lt;track&gt;&lt;wbr&gt; 八.其他123456789101112131415&lt;select&gt; 下拉列表，指定name！ multiple 多选&lt;textarea&gt; resize：none 禁止拖动&lt;aside&gt; 跟文章不相关的内容,旁边经常作为侧边栏或标注框出现全局属性contenteditable 内容可编辑除了div 和 span 其他标签都有默认样式&lt;b&gt; 与 &lt;strong&gt;的区别：&lt;strong&gt;元素表示更重要的内容，而&lt;b&gt;元素用于提醒，dl &gt; dt +dd&lt;meta charset=&quot;utf-8&quot;&gt; 等价于 &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; :http-equiv:http 的等价物]]></content>
      <categories>
        <category>前端</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈命令行（三）：好玩的命令行操作]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%A5%BD%E7%8E%A9%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C%EF%BC%88%E6%9C%89%E5%A5%BD%E7%8E%A9%E5%86%8D%E8%A1%A5%E5%85%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[置顶资料：用来练习命令行，一天一个命令行：一天一个命令行 一、可以开启一个翻译工具第一步：打开终端或者 gitbash，输入： 1$ npm install -g fanyi 或有些人的电脑有管理员权限的，需要前面加上sudo 1$ sudo npm install -g fanyi 这里还需要输入你的开机密码 第二步：然后在终端下输入 1$ fanyi 你好 即可进行及时翻译附上我电脑的终端命令行操作图：]]></content>
      <categories>
        <category>基础知识</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈命令行（二）：安装静态服务器（涉及nodejs和npm的使用）]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E6%B6%89%E5%8F%8Anodejs%E5%92%8Cnpm%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[掌握了终端的一些基本命令，可以做点什么呢？用命令行，可以安装一个静态服务器哦~关键词： Nodejs、npm、全局安装、http-server 一、安装Nodejs1、什么是NodejsNode.js 是一个让 JavaScript 运行在服务端的开发平台。（不懂就算了，不用太在意，反正应该是帮助js更友好地去开发的一个开发平台。。。啊吧） 2、下载链接： nodejs注： nodejs下载完后，你将不会看到它像其他软件那样出现在桌面，需要用命令行去调用它。 3、验证是否安装成功此时，可以开启终端，用命令行验证： 1$ node --version 如图： 二、使用npm安装一个静态服务器1$ npm install -g http-server 1、npm是什么npm是一个node包管理和分发工具，已经成为了非官方的发布node模块（包）的标准。有了npm，可以很快的找到特定服务要使用的包，进行下载、安装以及管理已经安装的包。新版的nodejs已经集成了npm，所以之前npm也一并安装好了。 2、npm的作用npm是随同Nodejs一起安装的包管理工具，能解决Nodejs代码部署上的很多问题。 3、再次打开终端操作以下步骤：（1）开启npm 1$ npm （2）用npm安装http-sever 1$ npm install -g http-server 结论： http-server被安装成功，可以开启一个静态服务器注： 1-g 为全局安装模式，去掉-g之后就是本地模式，如果出错就可以试一下本地模式 题外话： 关于本地模式和全局模式的问题，这里就不展开讲了，比较菜不耽误别人。需要的可以看一下这两篇文章： nodejs本地模式和全局模式 node.js 本地模式与全局模式的区别 划重点： 有些人的电脑如果提示错误（我的就是这样?），不要抓狂，试一下是否需要管理员权限： 1$ sudo npm install -g http-server windows不需要管这个 （3）开启http-server（这个是一个服务器哦） 1$ http-server （4）尝试启动http-server在浏览器打开你的本地文件在命令行假设在桌面（desktop）操作一个名为code文件夹中的from.html文件 123$ ls$ cd code$ http-server 此时，将会出现服务器的url，复制下来在浏览器中打开，在code目录下启动这个静态服务器，用新的url来展示code文件夹下所相对应的html文件夹。结论：这种方式，就不是我们用本地的方式打开html文件 （5）退出http-server在终端上Ctrl+c，便会退出http-server]]></content>
      <categories>
        <category>基础知识</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈命令行（一）：命令行基本操作（包括vim在终端的基本操作）]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%B5%85%E8%B0%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E5%8C%85%E6%8B%ACvim%E5%9C%A8%E7%BB%88%E7%AB%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、命令行1、了解一些关键名词： 图形界面 命令行：在终端窗口下输入一些命令就可以满足一些操作需求 终端：mac下打开终端（terminal），win下打开gitbash shell：执行当前脚本的一个载体，统称shell。如输入命令ls，即展示当前文件下的所有文件（ls本质上是字符串），通过shell底层地接受字符串的操作输入，在底层做一些文件检索，最终展示出ls发出的请求的文件 bash：本质上是一个软件。 2、安装使用 win安装git，打开gitbash linux：打开终端 mac：打开终端、iterm 二、基本命令1、查看当前完整的路径：pwd1~ $ pwd 结论： 就是看看此时我在哪个文件夹下 2、查看当前目录下文件：ls 不包括隐藏文件 1$ ls 查看当前目录下所有文件（包括隐藏文件） 1$ ls -a 查看当前目录下所有文件（包括隐藏文件）的详细信息 1$ ls -al 注：书籍推荐《鸟叔的linux教程》 3、切换目录：cd1$ cd 文件夹名 如： 1234$ cd /c/project$ cd code$ cd ../css$ cd ~/desktop 两点和一点的区别： 返回上一级文件夹: ..（即返回 ~ 家目录） 1$ cd .. 当前文件夹: . （即desktop这个文件夹） 1$ cd ./code 结论： 即切换到当前目录下的code文件夹 1$ cd code 4、文件路径（1）根路径：/ （即整个系统最根本的路径） 1$ cd code 根目录&gt;家目录如错误示范： 1$ cd /code 注： 如果要操作根路径里的其他文件夹，需要管理员权限 根路径不是C盘，根路径就是根路径 （2）家目录：~ 1~ 家目录，即当前的用户下的路径 ：如 1/Users /wxq393 如果是: 1~ /desktop $ 即是 1/Users/wxq393/desktop $ （3）当前目录：. 12$ cd code$ cd ./code （4）上级目录：.. 12$ cd ..$ cd ../code 5、创建文件 : touch1$ touch readme.md 6、删除文件 : rm1$ rm readme.md 强制删除文件夹，不提示 1$ rm -rf helloworld 或者 1$ rm -r helloworld 7、重命名文件 : mv1$ mv readme.md README.md 8、创建文件夹 : mkdir1$ mkdir projects 三、终端中的编辑器vim的使用终端命令行中先创建 1$ touch a.html 第一步： 1$ vim a.html 初始进入编辑器命令模式 第二步：键盘上：i进入编辑模式INSERT 第三步：键盘左上角：escINSERT消失，进入命令模式 第四步： 1：wq 保存退出 或者 1：!q 不保存强制退出 第五步： 1$ cat a.html 查看文件结果]]></content>
      <categories>
        <category>基础知识</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github博客教程：03添加分类，标签]]></title>
    <url>%2F2018%2F11%2F01%2FHexo-Github%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%9A03%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%EF%BC%8C%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[1、创建“分类”选项1.1 生成“分类”页并添加tpye属性打开命令行，进入博客所在文件夹。执行命令 1$ hexo new page categories 成功后会提示： 1INFO Created: ~/Documents/blog/source/categories/index.md 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的： 1234---title: 文章分类date: 2018-10-31 13:47:40--- 添加type: &quot;categories&quot;到内容中，添加后是这样的： 12345---title: 文章分类date: 2018-10-31 13:47:40type: &quot;categories&quot;--- 保存并关闭文件。 1.2 给文章添加“categories”属性打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。 123456---title: Hexo博客+Github博客教程：03添加分类，标签date: 2018-11-01 14:17:46categories: - hexo--- 至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。 2、创建“标签”选项2.1 生成“标签”页并添加tpye属性打开命令行，进入博客所在文件夹。执行命令 1$ hexo new page tags 成功后会提示： 1INFO Created: ~/Documents/blog/source/tags/index.md 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的： 1234---title: 标签date: 2018-10-31 13:47:40--- 添加type: &quot;tags&quot;到内容中，添加后是这样的： 12345---title: 文章分类date: 2018-10-31 13:47:40type: &quot;tags&quot;--- 保存并关闭文件。 2.2 给文章添加“tags”属性打开需要添加标签的文章，为其添加tags属性。下方的tags:下方的- jQuery - 表格- 表单验证就是这篇文章的标签了 1234567891011---title: Hexo博客+Github博客教程：03添加分类，标签date: 2018-11-01 14:17:46categories: - 基础知识- hexotags:- hexo- github- 博客--- 至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了tags: xxx的文章才会被收录到首页的“标签”中。 细心的朋友可能已经发现，这两个的设置几乎一模一样！是的，没错，思路都是一样的。所以我们可以打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，之后执行hexo new 文章名命令生成的文件，页面里就有categories:项了。 scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。 教程结束，赶紧去设置吧！]]></content>
      <categories>
        <category>基础知识</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github博客教程：02主题优化]]></title>
    <url>%2F2018%2F11%2F01%2FHexo-Github%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%9A02%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[这一篇教程将主要介绍个性化博客的配置，并将不定期更新。 在你存放的Hexo文件夹中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。 添加分类模块1、新建一个分类页面 1$ hexo new page categories 2、你会发现你的source文件夹下有了categorcies/index.md，打开index.md文件将title设置为title: 分类 3、打开 主题配置文件 找到menu，将categorcies取消注释 4、把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中 举个栗子： 12title: 分类测试文章标题categories: 分类名 添加多个分类如果你想要把一篇文章设置为两个分类，一个为主分类，第二个为子分类，并且文章在子分类，可以这样写： 1categories: [一级分类名,二级分类名] 也可以这样写： 123categories:- 一级分类名- 二级分类名 这样这篇文章的主分类为“一级分类名”，子分类为“二级分类名”，并且文章显示在“二级分类名下”类别下。 添加标签模块1、新建一个标签页面 1$ hexo new page tags 2、你会发现你的source文件夹下有了tags/index.md，打开index.md文件将title设置为title: 标签 3、打开 主题配置文件 找到menu，将tags取消注释 4、把文章添加标签只需在文章的顶部标题下方添加tags字段，即可自动创建标签名并归入对应的标签中 举个栗子： 12345title: 标签测试文章标题tags: - 标签1 - 标签2 ... 添加关于模块1、新建一个关于页面 1$ hexo new page about 2、你会发现你的source文件夹下有了about/index.md，打开index.md文件即可编辑关于你的信息，可以随便编辑。3、打开 主题配置文件 找到menu，将about取消注释 插入摘要有时文章比较长，或者想首页更简洁一些，希望在首页只显示摘要而不是全文。Hexo是支持摘要的功能的，只要在文章中插入代码： 1&lt;!--more--&gt; 这样在其上的文字即为摘要，在首页中就会出现“阅读更多”的图标，点击则显示全文。 插入图片使用markdown写文章，插入图片的格式为 1![图片名称](链接地址) 对于hexo，链接地址的写法包括以下几种： 使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。 使用微博图床，地址http://weibotuchuang.sinaapp.com/，将图片拖入区域中，会生成图片的URL，这就是链接地址。 七牛云存储，地址http://www.qiniu.com/，同样是将图片拖入区域中，会生成图片的URL，或填入其链接地址。 插入图片的同时，建议开启Fancybox，以next主题为例，打开_config.yml，将fancybox的配置false改成true即可。 12# Fancyboxfancybox: true 居中对齐Markdown语法本身没有居中的，但Markdown中支持基本的HTML语法，可以使用HTML语法。 123&lt;center&gt;居中对齐&lt;/center&gt;&lt;h1 style=&quot;text-align:center&quot;&gt;居中对齐 &lt;h1&gt;&lt;h1 style=&quot;text-align:right&quot;&gt;居右对齐 &lt;h1&gt; 发布照片文章修改\scaffolds\photo.md 1234567layout: &#123; &#123; layout &#125; &#125;title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:photos:- &lt;photo url&gt;--- 要发布照片文章： 1$ hexo new photo &quot;photoPostName&quot; hexo默认会处理全部 markdown 和 html 文件，如果不想让 hexo 解析，可以在文件头中加入 layout: false。 安装RSS在终端执行 1npm install hexo-generator-feed --save 然后在_config.yml中添加 123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 然后打开next主题文件夹里面的_config.yml,在里面配置为如下样子：(就是在rss:的后面加上/atom.xml,注意在冒号后面要加一个空格) 1234# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 配置完之后运行： 1$ hexo g 重新生成一次，你会在./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中。 添加动态背景 注意：如果next主题在5.1.1以上的话就不用我这样设置，直接在主题配置文件中找到canvas_nest: false，把它改为canvas_nest: true就行了（注意分号后面要加一个空格） 修改_layout.swig打开 next/layout/_layout.swig在 &lt; /body&gt;之前添加代码(注意不要放在&lt; /head&gt;的后面) 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 修改配置文件打开 /next/_config.yml,在里面添加如下代码：(可以放在最后面) 123456# --------------------------------------------------------------# background settings# --------------------------------------------------------------# add canvas-nest effect# see detail from https://github.com/hustcc/canvas-nest.jscanvas_nest: true 到此就结束了，运行 hexo clean，然后运行 hexo g,然后运行 hexo s，最后打开浏览器在浏览器的地址栏输入 localhost:4000 就能看到效果了\（￣︶￣）/ 如果你感觉默认的线条太多的话可以这么设置====&gt;在上一步修改 _layout.swig中，把刚才的这些代码： 123&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 改为 1234&#123;% if theme.canvas_nest %&#125;&lt;script type=&quot;text/javascript&quot;color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 配置项说明 color ：线条颜色, 默认: &#39;0,0,0&#39;；三个数字分别为(R,G,B) opacity: 线条透明度（0~1）, 默认: 0.5 count: 线条的总数量, 默认: 150 zIndex: 背景的z-index属性，css属性用于控制所在层的位置, 默认: -1 添加网站图标网站图标即浏览网页时显示在标签页或将网页保存在书签时所显示的图标，图标可以视为网站的Logo，是网站个性化的一部分。 具体方法实现 在EasyIcon中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件： 12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico 404页面直接在根目录下创建自己的404.html。要注意的是，自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也不起作用。 添加百度站点地图 1$ npm install hexo-generator-baidu-sitemap@0.1.1 --save 在_config.yml中添加 12baidusitemap:path: baidusitemap.xml 更改主题下载自己喜欢的主题文件，可以到这里找。放到Hexo目录下的themes文件夹下，然后在_config.yml文件中找到： 1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: landscape //themes文件夹中对应文件夹的名称 将landscape改为所需要的主题文件的名字，如本博客即使用next，然后执行hexo clean(可省略)，再重新hexo g，hexo d，就能看到新主题的效果。 导航栏的定制打开主题的_config.yml文件，在开头找到如下代码： 123456789menu: home: / || home //首页 archives: /archives/ || archive //归档 categories: /categories/ || th //分类 tags: /tags/ || tags //标签 about: /about/ || user //关于 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404 看看你需要哪个菜单就把哪个取消注释打开就行了； 关于后面的格式，以archives: /archives/ || archive为例： || 之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改 ||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自Font Awesome。 添加搜索功能1、安装 hexo-generator-searchdb 插件 1$ npm install hexo-generator-searchdb --save 2、打开 站点配置文件 找到Extensions在下面添加 123456# 搜索search: path: search.xml field: post format: html limit: 10000 3、打开 主题配置文件 找到Local search，将enable设置为true 网站计数站点访问计数有名的就是不蒜子，使用起来非常方便。 1、安装脚本 打开 themes/next/layout/_partial/footer.swig，将下面这段代码添加到里面 12345678910&lt;div&gt;&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot; style=&apos;display:none&apos;&gt; 本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次 &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot; style=&apos;display:none&apos;&gt; 有&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人看过我的博客啦&lt;/span&gt;&lt;/div&gt; 添加的位置如下图，可自行根据个人喜好更换位置 2、以上只是显示站点的访问次数，如果想显示每篇文章的访问次数，打开 themes/next/layout/_macro/post.swig ，在第一行增加 1is_pv 字段 1&#123;% macro render(post, is_index, is_pv, post_extra_class) %&#125; 然后将这段代码插入到里面 1234&#123;% if is_pv %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次阅读&#123;% endif %&#125; 插入的位置 然后再打开 themes/next/layout/post.swig ，这个文件是文章的模板，给render方法传入参数（对应刚才添加的 1is_pv 字段） 最后再打开 themes/next/layout/index.swig ，这个文件是首页的模板，给render方法传入参数（对应刚才添加的is_pv字段） OK！设置完毕。 在右上角或者左上角实现fork me on github实现效果图 具体实现方法 点击这里或者这里挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码：然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址 实现点击出现桃心效果实现效果图 具体实现方法 在网址输入如下 1http://7u2ss1.com1.z0.glb.clouddn.com/love.js 然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout\_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： undefinedundefined 修改文章内链接文本样式实现效果图 具体实现方法 修改文件 themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式，： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 修改文章底部的那个带#号的标签实现效果图 具体实现方法 修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 在每篇文章末尾统一添加“本文结束”标记实现效果图 具体实现方法 在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）： 代码如下： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件（_config.yml),在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。 侧边栏社交小图标设置实现效果图 具体实现方法 打开主题配置文件（_config.yml），搜索social_icons:,在图标库找自己喜欢的小图标，并将名字复制在如下位置，保存即可 侧边栏推荐阅读今天有位网友问推荐阅读是怎么弄，其实挺简单的，打开主题配置文件修改成这样就行了(links里面写你想要的链接): 123456789# Blogrollslinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: 阮一峰: http://www.ruanyifeng.com/ 张鑫旭: http://www.zhangxinxu.com/ 百度前端技术学院: http://ife.baidu.com/ google前端开发基础: http://wf.uisdc.com/cn/ 添加评论系统 目前国内比较有名的多说、网易云跟帖评论系统都已停止服务了，国外的Disqus评论系统还得需要翻墙，所以不推荐使用，剩下的还有搜狐畅言、友言、来必力等。 本来想使用畅言的，结果注册完之后还得要求备案，我只想说F开头的那个单词，果断放弃。 后来选择了友言 1、进入友言官网注册、登录步骤我就不介绍了 2、登录完成之后，点击获取代码，你会发现出来了一段代码，里面有你的uid=1234567 3、打开 主题配置文件 找到youyan_uid将值设置为上面的uid就可以了 主页文章添加阴影效果实现效果图 具体实现方法 打开\themes\next\source\css\_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 网站底部字数统计实现效果图 具体方法实现切换到根目录下，然后运行如下代码 1$ npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上： 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 实现统计功能实现效果图 具体实现方法 在根目录下安装 hexo-wordcount,运行： 1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下： 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 在文章底部增加版权信息实现效果图 在目录 next/layout/_macro/下添加 my-copyright.swig： 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:mm&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:mm&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;wechat-subscriber.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 如下： 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import &quot;my-post-copyright&quot; 保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 小技巧：如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加：这样每次hexo new &quot;你的内容&quot;之后，生成的md文件会自动把copyright:加到里面去(注意：如果解析出来之后，你的原始链接有问题：如：http://yoursite.com/前端小项目：使用canvas绘画哆啦A梦.html,那么在根目录下_config.yml中写成类似这样：）就行了。 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。位置如图： 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如 title: 解决Charles乱码问题 date: 2017-05-22 22:45:48 tags: 技巧 categories: 技巧 copyright: true top: 100 SEO（搜索引擎优化）GoogleWebmasters：站长工具，让博客被Google更好的收录，比如手动让Googlebot抓取、提交Robots、更新Sitemap等。另有百度站长工具。经过测试，发现在Google提交网址并验证网站所有权和手动抓取后，很快就可以直接在Google上搜索到自己的播客网站，而百度则目前仍未能被其搜索引擎所抓取。可以看出Google对个人站长更为友好。 更多1、还有其他更多的主题配置，请查看主题配置 2、还有其他更多的插件，请查看Hexo插件 插件改的越多出错的bug风险就越大，毕竟对于小白来说可能一不小心两个插件冲突了自己不知道怎么办，不要逐本求末把太多精力放在这上面，所以先从基础的开始，网上相似的教程也有很多，大家最好找几篇对比着看，了解原理之后进行二次开发。 本文对网络文章和所使用工具的官方文档多有参考，一并谢过，不一一列举了。]]></content>
      <categories>
        <category>基础知识</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github博客教程：01基本操作]]></title>
    <url>%2F2018%2F11%2F01%2FHexo-Github%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%9A01%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[搭建步骤 GitHub创建个人仓库 安装Git 安装Node.js 安装Hexo 部署Github为我们的博客提供了托管平台。 首先注册一个GitHub帐号，然后建立与你用户名对应的仓库，仓库名必须为 1username.github.io 同时在Pages中开启Github Pages服务。进入刚才创建的仓库,点击右边菜单中的Settings按钮，在跳转到的页面 Update your site 对应处点击“Automatic page generator”按钮，这样就有了一个github自动生成的页面用来测试的时候使用。之后点击继续。选择主题,点击’Publish page’发布。 再次回到仓库,点击Settings按钮，点击链接就可以看到测试地址页面。 在站点配置文件_config.yml中，找到并修改： 1url: http://username.github.io/ 以及 1234deploy: type: git repository: https://github.com/username/username.github.io.git branch: master 每次将写好的文章部署到Github时，会被要求输入Github用户名和密码。 添加SSH Keys什么是SSH Keys简单说，SSH是一种网络协议，用于计算机之间的加密登录。 如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。 检查SSH Keys如果不清楚是否已经添加SSH，先检查： 1ls-al~/.ssh 如果有id_dsa.pub，id_ecdsa.pub，id_ed25519.pub等，说明有SSH keys。 如果未配置，则返回 1bash: ls-al~/.ssh: No such file or directory 如果没有的话,就生成一个SSH keys： 1$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 然后会出现: 12Generating public/private rsa key pair.Enter file in which to save the key (/Users/you/.ssh/id_rsa): 就是让你输入SSH keys要保存在哪里,一般不用改,就直接回车就好了。 然后会出现: 12Enter passphrase (empty for no passphrase): [Type a passphrase]# Enter same passphrase again: [Type passphrase again] 这是要求输入一个密码，记住这个密码。 保存SSH keys 创建成功后,他会提示你SSH keys保存在哪里: 1234Your identification has been saved in /Users/you/.ssh/id_rsa.# Your public key has been saved in /Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 找到SSH keys根据上一步里告诉你的路径,找到保存SSH keys的地方，其中id_rsa.pub 就是SSH keys。如果为了防止以后找不到，可以把他们自己另存到其它地方。 为github仓库添加SSH keysSSH keys创建好了，我们还要把它添加到仓库里去创建的仓库。 点击右侧的Settings，然后在左侧的Deploy keys中选择Add deploy key，点击Add deploy key。 然后把创建的id_rsa.pub里的内容复制到Key里去,Title部分随便填，点击Add key。添加的过程中，还要再输入一次github的密码。 测试连接回到git bash执行: 1$ ssh -T git@github.com 它可能会出现一些乱七八糟的提示，最后是问你yes/no,就输入yes。 如果要求输入密码，那这个密码就是之前设置的那个密码（已用黑体并加粗）。如果之前没有设置密码，没忽略此步骤。 1Enter passphrase for key &apos;/c/Users/2000104591/.ssh/id_rsa&apos;: 最后它提示你: 1Hi, 用户名/用户名.github.io! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 安装Git什么是Git ?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。如果想要了解Git的细节，参看廖雪峰老师的Git教程：Git教程 从Git官网下载：Git - Downloading Package 现在的机子基本都是64位的，选择64位的安装包，下载后安装，在命令行里输入git测试是否安装成功，若安装失败，参看其他详细的Git安装教程。安装成功后，将你的Git与GitHub帐号绑定，鼠标右击打开Git Bash或者在菜单里搜索Git Bash，设置user.name和user.email配置信息： 12git config --global user.name "你的用户名"git config --global user.email "你的邮箱" 安装Node.jsHexo基于Node.js，Node.js下载地址：Download | Node.js 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v : 12$ node -vv8.5.0 检测npm是否安装成功，在命令行中输入npm -v : 12$ npm -v5.3.0 到这了，安装Hexo的环境已经全部搭建完成。 安装 Hexo什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。本博客就是借由Hexo搭建而成。 在上述所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 操作方法是：在一个文件夹中（最好放在一个安全的独立的目录下，尽量不要起中文名作为存放博客的文件夹，我是直接放在桌面的）右键，选择Git Bash Here，即可打开命令窗口。也可以执行如下命令。 123cd ~/Desktop: #进入桌面mkdir hexo #创建文件夹hexo，为了存放你的博客各种内容及设置cd hexo #进入hexo文件夹 在该文件夹中执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件，操作方法同上。 12$ hexo init #初始化$ npm i #安装依赖包 然后安装hexo-deployer-git插件 1npm install hexo-deployer-git --save 本地网页预览执行下列命令，生成本地网页并启动预览。 12hexo g #生成本地网页文件hexo s #启动预览服务 其中，npm i == npm installhexo g == hexo generatehexo s == hexo server 1http-server -c-1 #另一种启动本地预览服务的方法，推荐 当看到INFO Hexo is running at localhost:4000. Press Ctrl+C to stop.时就说明我们已经搭建起本地的Hexo博客，这时到浏览器输入localhost:4000可以看到结果（或者打开http://127.0.0.1:4000/ ），然后按Ctrl+C可以停止预览；如果用后一种办法的在浏览器输入的是： http://127.0.0.1:8080。到此，Hexo的初步使用就告一段落了。]]></content>
      <categories>
        <category>基础知识</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些软件的安装]]></title>
    <url>%2F2018%2F11%2F01%2F%E4%B8%80%E4%BA%9B%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Git Bash 的安装与配置 Node.js 的安装与配置 Git 的安装与配置 VSCode 的安装与配置 Git Bash 的安装与配置安装 从官网下载（算了，太慢了） 百度网盘：链接: https://pan.baidu.com/s/1nu99KWp 密码: jfdf 双击安装，注意每一步的选项要参考下面的图（如果没有对应的图，就直接下一步） 下面的路径可以随便填： 好了，安装完成。 配置安装成功之后，需要设置一下外观： 关闭重启 Git Bash 即可。 使用第一种使用方式找一个目录，在目录上右键点击，然后选中「Git Bash Here」，即可用 Git Bash 打开这个目录。 试试输入 touch 1.txt，回车后看看目录里是不是多了一个文件。 第二种使用方式直接打开 Git Bash，输入 cd ~/Desktop 即可来到桌面所在的目录。 试试输入 touch 1.txt，回车后看看桌面上是不是多了一个文件。 更多命令下节课我们会专门学习命令行，你可以试试下面几个简单的命令： 创建目录：mkdir my-dir 删除目录：rm -r my-dir 创建文件：echo &quot;hello&quot; &gt; newFile.txt 删除文件：rm newFile.txt 链接解决git bash无法复制和黏贴 Node.js 的安装与配置 从官网下载安装包 百度网盘下载：链接: https://pan.baidu.com/s/1cMxJcU 密码: xfyj 安装了之后 千万别 点击 Node.js 的图标 千万别 点击 Node.js 的图标 千万别 点击 Node.js 的图标 别问为什么，别点就是了。 配置打开 Git Bash，依次输入以下命令，按回车： 123npm config set registry https://registry.npm.taobao.org/npm config set loglevel httpnpm config set progress false npm 的配置被存储在 ~/.npmrc，你可以随时改。 使用npm 安装命令行小工具装了 Node.js 之后我们就可以在 Git Bash 里面使用 node 和 npm 这两个命令了，试试看： 1234which nodewhich npmnode -vnpm -v 依次输出看看你得到什么结果。 接下来跟大家展示一下 npm 的威力。我们可以用 npm 的翻译工具做一个随时可用的小字典，这个小工具的名字叫做 fanyi。 运行 npm i -g fanyi 即可安装 fanyi，安装完成之后，输入 fanyi frontend 就可以看到对应的中文释义了！ 是不是很帅呢？！ node 的使用 进入 Git Bash 输入 node，回车，就可以进入 node 运行环境，这个时候我们就可以写 JS 了 试试写最简单的 JS 语句，比如 1+2，回车 2 * 8，回车 这就是 node 的第一种使用方式 node 的另一种使用方式我们可以先创建一个 JS 文件，然后让 node 运行 来到桌面：cd ~/Desktop 新建一个目录用来玩耍：mkdir hello-node 进入这个目录：cd hello-node 新建一个有内容的 JS 文件：echo &quot;console.log(&#39;Hi, Node.js&#39;)&quot; &gt; main.js，那么 main.js 就新建成功了 输入 node main.js，回车，node 就会执行这个 main.js 文件，你会看到「Hi, Node.js」字样 玩完了，删除 hello-node：cd .. ; rm -rf hello-node Git 的安装与配置安装不需要安装，Git Bash 内置了 Git 命令，Git Bash 还内置了以下命令： ls mkdir cp mv 等等，大概有几十个命令，Git Bash 其实是一个 Bash，不是 Git。 Git Bash 给我们提供了一个虚拟的 Linux 环境，这样我们就不用忍受 Windows 里面垃圾一般的命令行体验了。 配置请在命令行运行这五句话！！！一定要运行这五句话，不然 git 就不能用了 12345git config --global user.name 你的英文名字 #方便产品经理找（怼）你git config --global user.email 你的常用邮箱 #方便产品经理找（怼）你git config --global push.default simple # 本来我写的是 matching，不过想了想可能 simple 更好git config --global core.quotepath false #防止文件名变成数字git config --global core.editor &quot;vim&quot; # 使用vim编辑提交信息 另外很重要的一点！你自己运行 git 的时候注意一下：git remote add origin 后面的地址，不允许使用 https 开头的地址，见下图 记得点击 SSH VSCode 的安装与配置从官网下载安装包 安装时把以下选项选中： 使用 找个地方新建一个目录（目录名不要中文），假设目录名为 vs-demo 右键点击该目录，open with code 使用 Ctrl+Shift+E 打开资源管理器，在 vs-demo 目录里新建 HTML 文件，文件名为 index.html 在 index.html 依次输入：英文感叹号、回车 键，即可看到一个完整的 HTML 页面 由于 vscode 时常更新，如果 回车 键不行，就试试 Tab 键 这种快捷写法叫做 Emmet，目前所有的前端编辑器都支持 Emmet。换句话说，如果一个编辑器没有默认支持 Emmet，你就可以卸载这款编辑器了（比如 Sublime Text 括弧笑）。 关于 Emmet 的更多快捷写法，见： 官网的视频介绍 Emmet 作弊表 配置VSCode 的配置方式就写编辑一个配置文件，打开「文件 - 首选项 - 设置」，对应快捷键为 Ctrl + , 左侧为系统默认配置项，右侧为你要覆盖的配置项。把你要修改的项从左边拷贝到右边，然后保存，即可生效。 设置字体与字号在右侧文件中添加一行（注意末尾要有英文逗号） 1&quot;editor.fontSize&quot;: 18, 保存，字号就变大了。 设置字体也是类似，添加 1&quot;editor.fontFamily&quot;: &quot;Consolas, &apos;Courier New&apos;, monospace&quot;, 即可将字体设置为你想要的。这里推荐「10大最适合编程的字体推荐下载」，够你玩一上午了。我用的编程字体一般是 Source Code Pro 和 M Plus 这两款。 其实 VSCode 默认的配置就挺好的。 插件安装VSCode 自带 Emmet、Git 继承和 JS 调试功能（后续会讲到），已经十分完善了，但是还是有一些特殊的需求，这个时候我们就可以安装第三方插件了。由于第三方插件不是微软生产的，所以质量良莠不齐，请注意甄别。 如果你发现 VSCode 没有 Git 功能： 那么你只需要在项目目录运行 git init 来激活 git 功能即可。 安装 open in browser按 Ctrl + Shift + X 打开扩展面板，然后输入 open in browser，点击第一个结果的「安装」按钮，稍等片刻就安装好了（相比之下 Sublime 的插件安装体验就差很多）。 然后你在任意 HTML 文件右键，就可以看到 Open In Default Browser 这个按钮了，点就试试看。]]></content>
      <categories>
        <category>基础知识</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>node</tag>
        <tag>Git Bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP入门]]></title>
    <url>%2F2018%2F10%2F30%2FHTTP%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[什么是HTTP?超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议[1]。HTTP是万维网的数据通信的基础。 设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。 HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。 协议概述HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。 尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。 请求方法HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源： GET 向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法 HEAD 与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。 POST 向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。 PUT 向指定资源位置上传其最新内容。 DELETE 请求服务器删除Request-URI所标识的资源。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 OPTIONS 这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。 方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。 状态码所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。 状态代码的第一个数字代表当前响应的类型： 1xx消息——请求已被服务器接收，继续处理 2xx成功——请求已成功被服务器接收、理解、并接受 3xx重定向——需要后续操作才能完成这一请求 4xx请求错误——请求含有词法错误或者无法被执行 5xx服务器错误——服务器在处理某个正确请求时发生错误 请求与响应下面是一个HTTP客户端与服务器之间会话的例子，运行于www.baidu.com，端口80。我们可以通过Chrome开发者工具查看HTTP的请求与响应内容。 请求首先我们需要打开电脑的命令行工具输入： 1curl -s -v -H "Neil : xxx" -- "https://www.baidu.com" 请求的内容为：12345GET / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.55.1Accept: */*Neil: xxx 我们还可以通过其他的方法来发送请求： 1curl -X POST -d "1234567890" -s -v -H "Neil : xxx" -- "https://www.baidu.com" 请求的内容为：123456789POST / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.55.1Accept: */*Neil: xxxContent-Length: 10Content-Type: application/x-www-form-urlencoded[10 bytes data] 请求的格式：1234567891 动词 路径 协议/版本2 Key1: value12 Key2: value22 Key3: value32 Content-Type: application/x-www-form-urlencoded2 Host: www.baidu.com2 User-Agent: curl/7.54.03 4 要上传的数据 我们可以得出结论一个完整的HTTP请求包含4个部分，分别为请求行、请求头、空行、其他的消息体，其中第四部分有时也可以为空。 如何用 Chrome 查看请求内容 打开 Chrome浏览器F12进入开发者工具点击Network 地址栏输入网址，比如：www.baidu.com 在 Network 点击，查看 request，点击「view source」 如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到了 响应请求了之后，应该都能得到一个响应，除非断网了，或者服务器宕机了。 响应示例上面两个请求的响应分别为 1234567891011121314HTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 2443Content-Type: text/htmlDate: Tue, 10 Oct 2017 09:14:05 GMTEtag: &quot;5886041d-98b&quot;Last-Modified: Mon, 23 Jan 2017 13:24:45 GMTPragma: no-cacheServer: bfe/1.0.8.18Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/[2443 bytes data] 123456789HTTP/1.1 302 FoundConnection: Keep-AliveContent-Length: 17931Content-Type: text/htmlDate: Thu, 01 Nov 2018 13:08:49 GMTEtag: &quot;54d9749e-460b&quot;Server: bfe/1.0.8.18[3824 bytes data] GET 请求和 POST 请求对应的响应可以一样，也可以不一样 响应的第四部分可以很长很长很长 响应的格式12345671 协议/版本号 状态码 状态解释2 Key1: value12 Key2: value22 Content-Length: 179312 Content-Type: text/html34 要下载的内容 如何用 Chrome 查看响应内容 打开 Chrome浏览器F12进入开发者工具点击Network 地址栏输入网址，比如：www.baidu.com 在 Network 点击，查看 Response Headers，点击「view source」 如果有请求的第四部分，点击查看Response或者Preview就可以了]]></content>
      <categories>
        <category>前端</category>
        <category>http</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
</search>
